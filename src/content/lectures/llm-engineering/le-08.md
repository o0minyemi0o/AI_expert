# 에이전트와 도구 사용

## 왜 에이전트가 중요한가

LLM 단독으로는 실시간 정보 검색, 계산, 외부 시스템 조작이 불가능합니다. 에이전트(Agent)는 LLM을 "두뇌"로 사용하면서 도구(Tool)를 호출하여 실세계와 상호작용하는 시스템입니다. RAG([le-03](/lectures/llm-engineering/le-03))가 "읽기 전용" 외부 지식 접근이라면, 에이전트는 "읽기-쓰기" 양방향 상호작용을 가능하게 합니다. 이 강의에서는 함수 호출, 에이전트 아키텍처, 계획-실행 루프, 멀티에이전트 시스템을 다룹니다.

## 1. 함수 호출 (Function Calling)

함수 호출은 에이전트의 기본 빌딩 블록입니다. LLM이 자연어 입력을 분석하여 적절한 함수와 인자를 결정합니다.

```python
from openai import OpenAI

client = OpenAI()

# 도구 정의
tools = [
    {
        "type": "function",
        "function": {
            "name": "get_weather",
            "description": "지정 도시의 현재 날씨를 조회합니다.",
            "parameters": {
                "type": "object",
                "properties": {
                    "city": {"type": "string", "description": "도시 이름"},
                    "unit": {"type": "string", "enum": ["celsius", "fahrenheit"]},
                },
                "required": ["city"],
            },
        },
    }
]

# LLM이 도구 호출 결정
response = client.chat.completions.create(
    model="gpt-4o",
    messages=[{"role": "user", "content": "서울 날씨 알려줘"}],
    tools=tools,
    tool_choice="auto",
)

# 도구 호출 결과 확인
tool_call = response.choices[0].message.tool_calls[0]
print(f"함수: {tool_call.function.name}")       # get_weather
print(f"인자: {tool_call.function.arguments}")   # {"city": "서울"}
```

> **핵심 직관**: 함수 호출에서 LLM은 "함수를 실행"하는 것이 아니라 "어떤 함수를 어떤 인자로 호출할지 결정"합니다. 실제 실행은 애플리케이션 코드에서 이루어지며, 이 분리가 안전성과 제어권의 핵심입니다.

## 2. 에이전트 아키텍처

### ReAct 패턴 (Reasoning + Acting)

가장 널리 사용되는 에이전트 패턴은 Thought-Action-Observation 루프입니다.

```
┌──────────────────────────────────────────┐
│              에이전트 루프                 │
│                                          │
│  [사용자 입력] ──▶ [Thought: 추론]        │
│                        │                 │
│                   ┌────▼────┐            │
│                   │도구 호출 │            │
│                   │필요한가? │            │
│                   └────┬────┘            │
│                Yes │       No            │
│               ┌────▼────┐ ┌──▼────────┐  │
│               │Action:  │ │최종 응답   │  │
│               │도구 실행 │ │생성       │  │
│               └────┬────┘ └───────────┘  │
│                    │                     │
│               ┌────▼────────┐            │
│               │Observation: │            │
│               │결과 관찰    │─────▶ 루프  │
│               └─────────────┘            │
└──────────────────────────────────────────┘
```

```python
from langchain.agents import create_react_agent, AgentExecutor
from langchain_openai import ChatOpenAI
from langchain.tools import Tool
from langchain import hub

llm = ChatOpenAI(model="gpt-4o", temperature=0)

# 도구 정의
tools = [
    Tool(name="Search", func=search_fn, description="웹 검색"),
    Tool(name="Calculator", func=calc_fn, description="수학 계산"),
    Tool(name="Database", func=db_fn, description="데이터베이스 조회"),
]

# ReAct 에이전트 생성
prompt = hub.pull("hwchase17/react")
agent = create_react_agent(llm, tools, prompt)
executor = AgentExecutor(agent=agent, tools=tools, verbose=True, max_iterations=5)

result = executor.invoke({"input": "지난 분기 매출 대비 이번 분기 성장률을 계산해주세요"})
```

### 에이전트 아키텍처 비교

| 패턴 | 설명 | 장점 | 단점 |
|------|------|------|------|
| ReAct | 추론-행동 반복 | 단순, 투명 | 긴 체인에서 불안정 |
| Plan-and-Execute | 먼저 계획, 후 실행 | 체계적 | 계획 수정 어려움 |
| LATS | 트리 탐색 기반 | 탐색적 | 비용 높음 |
| Reflexion | 자기 반성 포함 | 오류 복구 | 지연 증가 |

## 3. 계획-실행 (Plan-and-Execute) 패턴

복잡한 태스크에서는 먼저 전체 계획을 세우고, 각 단계를 순차적으로 실행하는 패턴이 효과적입니다.

```python
from langchain.chat_models import ChatOpenAI
from langchain_experimental.plan_and_execute import (
    PlanAndExecute, load_agent_executor, load_chat_planner,
)

llm = ChatOpenAI(model="gpt-4o", temperature=0)
planner = load_chat_planner(llm)
executor_agent = load_agent_executor(llm, tools, verbose=True)

agent = PlanAndExecute(planner=planner, executor=executor_agent, verbose=True)
result = agent.run("경쟁사 3곳의 최신 제품을 조사하고, 비교 보고서를 작성해주세요.")
```

```
[Plan-and-Execute 실행 흐름]

Step 1: 경쟁사 A 제품 정보 검색 ──▶ Search Tool
Step 2: 경쟁사 B 제품 정보 검색 ──▶ Search Tool
Step 3: 경쟁사 C 제품 정보 검색 ──▶ Search Tool
Step 4: 수집 정보 비교 분석     ──▶ LLM 추론
Step 5: 보고서 형식으로 정리     ──▶ LLM 생성
```

## 4. 멀티에이전트 시스템

단일 에이전트의 한계를 넘어, 여러 전문화된 에이전트가 협업하는 시스템입니다.

```python
# LangGraph를 활용한 멀티에이전트 예시
from langgraph.graph import StateGraph, MessagesState

# 전문 에이전트 정의
def researcher(state: MessagesState):
    """정보 수집 전문 에이전트"""
    # 검색 도구를 활용하여 정보 수집
    return {"messages": [research_result]}

def analyst(state: MessagesState):
    """분석 전문 에이전트"""
    # 수집된 정보를 분석
    return {"messages": [analysis_result]}

def writer(state: MessagesState):
    """보고서 작성 전문 에이전트"""
    # 분석 결과를 보고서로 작성
    return {"messages": [report_result]}

# 그래프 구성
graph = StateGraph(MessagesState)
graph.add_node("researcher", researcher)
graph.add_node("analyst", analyst)
graph.add_node("writer", writer)
graph.add_edge("researcher", "analyst")
graph.add_edge("analyst", "writer")
app = graph.compile()
```

> **핵심 직관**: 멀티에이전트 시스템에서 각 에이전트는 "하나의 역할"에 집중해야 합니다. 범용 에이전트 하나보다 전문화된 에이전트 여럿이 더 안정적이며, 이는 소프트웨어 공학의 단일 책임 원칙과 같습니다.

## 5. 에이전트 설계 시 고려사항

### 도구 설계 원칙

| 원칙 | 설명 | 예시 |
|------|------|------|
| 명확한 설명 | LLM이 이해할 수 있는 도구 설명 | "지정 기간의 매출 데이터를 조회" |
| 최소 권한 | 필요한 작업만 허용 | 읽기 전용 DB 접근 |
| 에러 처리 | 실패 시 유용한 에러 메시지 | "잘못된 날짜 형식" 반환 |
| 멱등성 | 동일 호출 시 동일 결과 | GET 요청 우선 |

### 시나리오 1: 고객 지원 자동화 에이전트

이커머스 고객 지원 에이전트를 구축합니다. 주문 조회(DB), 환불 처리(API), FAQ 검색(RAG, [le-03](/lectures/llm-engineering/le-03)) 도구를 갖추고, ReAct 패턴으로 고객 요청을 처리합니다. 환불 등 민감한 작업은 인간 승인 단계를 추가합니다(Human-in-the-Loop).

### 시나리오 2: 데이터 분석 에이전트

비즈니스 분석가를 위한 자연어 데이터 분석 에이전트입니다. SQL 실행, Python 코드 실행, 차트 생성 도구를 제공합니다. Plan-and-Execute 패턴으로 "지난 6개월간 카테고리별 매출 트렌드를 분석하고 예측해줘"와 같은 복합 요청을 처리합니다. MLOps 파이프라인([mo-03](/lectures/mlops/mo-03))과 연동하여 자동 보고서를 생성합니다.

> **핵심 직관**: 에이전트의 최대 위험은 "잘못된 도구를 확신에 차서 호출하는 것"입니다. max_iterations 제한, 위험 작업의 인간 승인, 실행 로그 기록은 프로덕션 에이전트의 필수 안전장치입니다 ([le-11](/lectures/llm-engineering/le-11) 참조).

## 핵심 정리

- 함수 호출은 LLM이 도구를 "결정"하고 애플리케이션이 "실행"하는 분리 구조이며, 에이전트의 기본 빌딩 블록입니다
- ReAct 패턴은 Thought-Action-Observation 루프로 동작하며, 단순하고 투명한 에이전트 구현에 적합합니다
- Plan-and-Execute는 복잡한 다단계 태스크에서 먼저 계획을 세우고 순차 실행하여 체계적 결과를 도출합니다
- 멀티에이전트 시스템은 전문화된 에이전트들의 협업으로 단일 에이전트의 복잡도 한계를 극복합니다
- 프로덕션 에이전트에는 반복 횟수 제한, 인간 승인 단계, 실행 로그 기록 등의 안전장치가 반드시 필요합니다
