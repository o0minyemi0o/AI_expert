# 프롬프트 엔지니어링

## 왜 프롬프트 엔지니어링이 중요한가

프롬프트 엔지니어링은 LLM의 성능을 극대화하는 가장 비용 효율적인 방법입니다. 모델을 파인튜닝하지 않고도 프롬프트만으로 출력 품질을 극적으로 개선할 수 있습니다. 이 강의에서는 체계적인 프롬프트 설계 기법과 구조화된 출력 생성, 그리고 프롬프트 최적화 전략을 다룹니다 ([le-01](/lectures/llm-engineering/le-01)에서 다룬 LLM 기초 위에 구축합니다).

## 1. 프롬프트의 구조와 시스템 프롬프트

프롬프트는 일반적으로 세 부분으로 구성됩니다.

| 구성 요소 | 역할 | 예시 |
|-----------|------|------|
| System Prompt | 모델의 역할과 행동 규칙 정의 | "당신은 금융 분석가입니다" |
| User Prompt | 사용자의 실제 요청 | "삼성전자 실적을 분석해주세요" |
| Assistant Prefix | 응답 형식 유도 | "분석 결과:" |

```python
from openai import OpenAI

client = OpenAI()

response = client.chat.completions.create(
    model="gpt-4o",
    messages=[
        {"role": "system", "content": "당신은 금융 데이터 분석가입니다. 항상 수치 근거를 포함하여 답변합니다."},
        {"role": "user", "content": "2024년 반도체 시장 전망을 요약해주세요."},
    ],
    temperature=0.3,
)
```

> **핵심 직관**: 시스템 프롬프트는 "모델의 페르소나와 행동 규칙을 설정하는 운영 체제"입니다. 구체적이고 명확한 시스템 프롬프트가 출력 품질의 80%를 결정합니다.

## 2. Few-Shot 프롬프팅

Few-shot은 입력-출력 예시를 제공하여 모델이 패턴을 학습하게 하는 기법입니다.

```python
few_shot_prompt = """다음 리뷰의 감성을 분석하세요.

리뷰: "배송이 빠르고 포장이 깔끔했습니다."
감성: 긍정
카테고리: 배송

리뷰: "제품 품질이 기대 이하입니다. 환불 요청합니다."
감성: 부정
카테고리: 품질

리뷰: "가격 대비 괜찮은 편이지만 색상이 사진과 다릅니다."
감성: """
```

### Few-Shot 예시 수에 따른 성능 변화

| 예시 수 | 일반 분류 정확도 | 복잡한 태스크 정확도 | 토큰 비용 |
|---------|----------------|-------------------|----------|
| 0 (Zero-shot) | ~70% | ~45% | 최저 |
| 1-2 (Few-shot) | ~82% | ~65% | 낮음 |
| 3-5 (Few-shot) | ~88% | ~78% | 중간 |
| 5+ | ~90% | ~80% (수렴) | 높음 |

## 3. Chain-of-Thought (CoT) 프롬프팅

CoT는 모델이 단계별로 추론하도록 유도하는 기법입니다. 수학, 논리, 코딩 등 추론이 필요한 태스크에서 특히 효과적입니다 ([pt-03](/lectures/probability-theory/pt-03)의 베이지안 추론과 유사한 단계적 사고).

```python
# Zero-shot CoT: 단순히 "단계별로 생각하세요"를 추가
zero_shot_cot = """
문제: 한 상점에서 사과 3개를 1200원에 판매합니다. 사과 17개의 가격은?

단계별로 생각하여 풀어보세요.
"""

# Manual CoT: 명시적인 추론 단계 제공
manual_cot = """
문제: 한 상점에서 사과 3개를 1200원에 판매합니다. 사과 17개의 가격은?

풀이:
1단계: 사과 1개의 가격 = 1200 / 3 = 400원
2단계: 사과 17개의 가격 = 400 × 17 = 6800원
답: 6800원
"""
```

> **핵심 직관**: CoT는 모델의 "작업 기억(working memory)"을 확장하는 기법입니다. 중간 추론 단계를 명시적으로 생성함으로써 복잡한 문제를 작은 하위 문제로 분해할 수 있게 됩니다.

### CoT 변형 기법 비교

```
[추론이 필요한 태스크]
        │
   ┌────▼────┐
   │ 난이도?  │
   └────┬────┘
    낮음 │    높음
   ┌────▼──┐ ┌──▼──────────┐
   │Zero-  │ │ 세부 전략    │
   │shot   │ │ 선택        │
   │CoT    │ └──┬──────────┘
   └───────┘    │
          ┌─────┼──────┐
          ▼     ▼      ▼
       Manual  Self-  Tree-
       CoT    Consist. of-Thought
       (정확성) (안정성) (탐색)
```

## 4. 구조화된 출력 (Structured Output)

실무에서 LLM 출력은 다운스트림 시스템에서 파싱할 수 있어야 합니다.

```python
from openai import OpenAI
from pydantic import BaseModel

client = OpenAI()

class SentimentResult(BaseModel):
    sentiment: str
    confidence: float
    keywords: list[str]
    summary: str

response = client.beta.chat.completions.parse(
    model="gpt-4o",
    messages=[
        {"role": "system", "content": "리뷰를 분석하여 JSON 형식으로 반환합니다."},
        {"role": "user", "content": "이 제품 정말 최고입니다! 디자인도 예쁘고 성능도 좋아요."},
    ],
    response_format=SentimentResult,
)
result = response.choices[0].message.parsed
print(f"감성: {result.sentiment}, 신뢰도: {result.confidence}")
```

### 구조화된 출력 전략 비교

| 방법 | 신뢰성 | 유연성 | 지원 모델 |
|------|--------|--------|----------|
| JSON Mode | 높음 | 중간 | GPT-4o, Claude |
| Function Calling | 매우 높음 | 높음 | GPT-4o, Gemini |
| Pydantic + parse | 매우 높음 | 높음 | GPT-4o |
| 프롬프트 지시 | 낮음 | 높음 | 모든 모델 |
| Outlines/Guidance | 높음 | 높음 | 오픈소스 모델 |

## 5. 프롬프트 최적화 전략

### 반복적 개선 프로세스

```python
# DSPy를 활용한 프롬프트 자동 최적화
import dspy

lm = dspy.LM("openai/gpt-4o-mini")
dspy.configure(lm=lm)

class ClassifyReview(dspy.Signature):
    """리뷰 텍스트를 분석하여 카테고리를 분류합니다."""
    review: str = dspy.InputField(desc="고객 리뷰 텍스트")
    category: str = dspy.OutputField(desc="품질/배송/가격/서비스 중 하나")

classifier = dspy.ChainOfThought(ClassifyReview)
result = classifier(review="배송은 빨랐지만 포장이 부실했어요")
print(result.category)
```

### 시나리오 1: 법률 문서 요약 시스템

법률 사무소에서 계약서를 자동 요약하는 시스템을 구축합니다. 핵심 조항(위약금, 계약 기간, 면책 조항)을 구조화된 형식으로 추출해야 합니다. 시스템 프롬프트에 법률 용어 정의를 포함하고, Few-shot으로 3개의 예시 계약서-요약 쌍을 제공하며, Pydantic 모델로 출력 스키마를 강제합니다.

### 시나리오 2: 코드 리뷰 자동화

개발팀에서 PR(Pull Request)에 대한 자동 코드 리뷰 시스템을 구축합니다. CoT를 활용하여 "1) 버그 가능성 분석 → 2) 성능 이슈 확인 → 3) 코드 스타일 검토 → 4) 개선 제안"의 단계적 리뷰를 수행하도록 프롬프트를 설계합니다 ([le-08](/lectures/llm-engineering/le-08)의 에이전트 패턴과 연결).

## 6. 프롬프트 안티패턴과 모범 사례

| 안티패턴 | 문제점 | 모범 사례 |
|---------|--------|----------|
| 모호한 지시 | 일관성 없는 출력 | 구체적 형식과 제약 명시 |
| 과도한 제약 | 모델 능력 제한 | 핵심 제약만 명시 |
| 예시 없는 복잡 태스크 | 낮은 정확도 | Few-shot 예시 추가 |
| 단일 프롬프트 의존 | 취약한 시스템 | 프롬프트 체인 구성 |

> **핵심 직관**: 좋은 프롬프트는 "좋은 업무 지시서"와 같습니다. 역할, 맥락, 형식, 제약 조건을 명확히 전달하면 신입 사원(LLM)도 양질의 결과물을 만들어낼 수 있습니다.

## 핵심 정리

- 시스템 프롬프트는 모델의 행동 규칙을 정의하며, 구체적일수록 출력 품질이 향상됩니다
- Few-shot 예시는 3-5개가 비용 대비 효과가 가장 높으며, 예시의 다양성이 수량보다 중요합니다
- Chain-of-Thought는 추론 태스크에서 10-40%의 정확도 향상을 가져오며, 복잡도에 따라 변형을 선택합니다
- 구조화된 출력(JSON/Pydantic)은 프로덕션 시스템에서 필수이며, 모델별 지원 방식이 다릅니다
- 프롬프트 최적화는 일회성이 아닌 반복적 프로세스이며, DSPy 같은 도구로 자동화할 수 있습니다
