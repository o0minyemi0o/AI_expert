# 최소 신장 트리

## 왜 MST가 중요한가

네트워크 설계에서 "모든 도시를 최소 비용으로 연결하라"는 문제가 **최소 신장 트리(MST)**입니다. 통신망 설계, 클러스터링(ga-09에서 MST 기반 클러스터링), 근사 TSP(ad-07) 등에 핵심적으로 사용됩니다. Kruskal과 Prim이 대표 알고리즘이며, ads-06의 Union-Find가 Kruskal의 핵심 도구입니다.

> **핵심 직관**: MST의 **컷 성질(Cut Property)**이 핵심입니다. 어떤 컷(그래프를 둘로 나누는 분할)에서 가장 가벼운 간선은 반드시 MST에 포함됩니다. Kruskal과 Prim 모두 이 성질을 다른 방식으로 활용합니다.

## 1. Kruskal 알고리즘

```python
def kruskal(n, edges):
    edges.sort()  # 가중치 순 정렬
    uf = UnionFind(n)
    mst, total = [], 0
    for w, u, v in edges:
        if uf.union(u, v):
            mst.append((w, u, v))
            total += w
            if len(mst) == n - 1: break
    return total, mst
```

```
동작: 가장 가벼운 간선부터, 사이클 안 만들면 추가
시간: O(E log E) (정렬) + O(E·α(V)) (Union-Find)
     = O(E log E)
적합: 희소 그래프, 간선 리스트 형태
```

## 2. Prim 알고리즘

```python
def prim(graph, n):
    """graph[u] = [(v, weight), ...]"""
    visited = [False] * n
    pq = [(0, 0)]  # (weight, node)
    total = 0
    count = 0
    while pq and count < n:
        w, u = heapq.heappop(pq)
        if visited[u]: continue
        visited[u] = True
        total += w
        count += 1
        for v, weight in graph[u]:
            if not visited[v]:
                heapq.heappush(pq, (weight, v))
    return total
```

```
동작: 트리에서 가장 가벼운 간선으로 확장 (Dijkstra와 유사)
시간: O((V + E) log V) — 이진 힙
     O(V log V + E) — Fibonacci Heap
적합: 밀집 그래프
```

| 알고리즘 | 시간 | 전략 | 적합 |
|---------|------|------|------|
| Kruskal | $O(E \log E)$ | 전역 정렬 | 희소 |
| Prim | $O((V+E)\log V)$ | 지역 확장 | 밀집 |
| Borůvka | $O(E \log V)$ | 병렬 가능 | 병렬 환경 |

> **핵심 직관**: Kruskal은 "전체 간선을 보고 가장 싼 것 선택"(전역), Prim은 "현재 트리에서 가장 싼 확장"(지역)입니다. 결과는 같지만 접근이 다릅니다.

## 3. MST 성질과 응용

```
MST 성질:

  1. 컷 성질: 컷의 최소 간선 → MST에 포함
  2. 사이클 성질: 사이클의 최대 간선 → MST에 미포함
  3. 유일성: 모든 간선 가중치가 다르면 MST는 유일

응용:
  ├─ 네트워크 설계: 최소 비용 연결
  ├─ 클러스터링: MST에서 가장 무거운 K-1개 간선 제거
  │   → K개 클러스터 (Single-linkage clustering)
  ├─ 근사 TSP: MST 가중치 ≤ 최적 TSP의 2배 (ad-07)
  └─ 차선 MST: MST에서 간선 하나를 교체한 차선 최적
```

## 4. 차선 MST와 병목 경로

```
차선 MST:
  MST에서 간선 하나를 제거하고 다른 것으로 교체

  방법:
  1. MST 구축
  2. 각 비MST 간선 (u,v,w)에 대해:
     MST에서 u→v 경로의 최대 간선 = max_edge
     교체 비용 = w - max_edge
  3. 교체 비용이 최소인 간선 교체

  최대 간선 쿼리: LCA + 경로 최대값 (ga-07)
  → O(E log V) 전체
```

> **핵심 직관**: MST는 "모든 노드 쌍 사이의 병목(최대 간선)을 최소화하는 트리"이기도 합니다. 이 성질이 클러스터링과 네트워크 설계에서 MST가 유용한 이유입니다.

## 5. Borůvka 알고리즘

```
Borůvka:
  각 연결 요소에서 최소 간선을 동시에 선택
  → 연결 요소 수가 절반으로 줄어듦
  → O(log V)번 반복

  과정:
  Phase 1: 각 노드의 최소 간선 선택 → V/2 요소
  Phase 2: 각 요소의 최소 간선 선택 → V/4 요소
  ...
  O(log V) phases × O(E) per phase = O(E log V)

  장점: 병렬화 가능 (각 요소가 독립적으로 최소 간선 선택)
  → 분산/GPU 환경에서 유리
```

## 6. 실전 팁

```
MST 구현 선택:

  V < 1000, E < 10000: Kruskal (간단)
  밀집 그래프 (E ≈ V²): Prim
  병렬 환경: Borůvka
  동적 (간선 추가/삭제): Link-Cut Tree

  주의:
  - 그래프가 연결되지 않으면 MST 없음 (MSF: 최소 신장 포레스트)
  - 간선 가중치가 같으면 MST가 여러 개 가능
  - 음수 가중치도 문제 없음 (최단 경로와 다름)
```

MST는 ga-09의 클러스터링, ad-07의 근사 TSP, ga-08의 스펙트럴 그래프와 연결됩니다.

## 핵심 정리

- **Kruskal**은 간선 정렬 + Union-Find로 $O(E \log E)$, **Prim**은 힙 기반 확장으로 $O((V+E)\log V)$에 MST를 구합니다
- **컷 성질**이 MST 알고리즘의 정당성 기반이며, 컷의 최소 간선은 반드시 MST에 포함됩니다
- MST 기반 **클러스터링**은 가장 무거운 간선을 제거하여 자연스러운 클러스터를 형성합니다
- **Borůvka**는 각 요소의 최소 간선을 동시에 선택하여 병렬 환경에 적합합니다
- MST는 "모든 노드 쌍의 **병목 경로를 최소화**하는 트리"라는 관점에서도 이해할 수 있습니다
