# 최단 경로 알고리즘

## 왜 최단 경로가 중요한가

내비게이션, 네트워크 라우팅, 게임 AI 경로 탐색 모두 최단 경로 문제입니다. ga-01의 BFS는 무가중 그래프만 처리하지만, **가중 그래프의 최단 경로**에는 Dijkstra, Bellman-Ford 등 전문 알고리즘이 필요합니다. 상황에 맞는 알고리즘 선택이 성능을 좌우합니다.

> **핵심 직관**: 최단 경로 알고리즘 선택의 핵심 기준은 "음수 가중치가 있는가?"와 "단일 출발점인가 전체 쌍인가?"입니다.

## 1. Dijkstra 알고리즘

```python
import heapq

def dijkstra(graph, start):
    """graph[u] = [(v, weight), ...]"""
    dist = {start: 0}
    pq = [(0, start)]
    while pq:
        d, u = heapq.heappop(pq)
        if d > dist.get(u, float('inf')):
            continue  # lazy deletion
        for v, w in graph[u]:
            nd = d + w
            if nd < dist.get(v, float('inf')):
                dist[v] = nd
                heapq.heappush(pq, (nd, v))
    return dist
```

```
동작 원리: 그리디 — 항상 최소 거리 노드를 확정

  전제: 음수 가중치 없음
  → 한 번 확정된 거리는 더 줄어들 수 없음

  시간: O((V + E) log V) — 이진 힙
        O(V log V + E) — Fibonacci Heap (ads-08)
```

## 2. Bellman-Ford

```python
def bellman_ford(n, edges, start):
    """edges = [(u, v, w), ...]"""
    dist = [float('inf')] * n
    dist[start] = 0
    for _ in range(n - 1):
        for u, v, w in edges:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
    # 음수 사이클 검출
    for u, v, w in edges:
        if dist[u] + w < dist[v]:
            return None  # 음수 사이클!
    return dist
```

```
특징:
  - 음수 가중치 허용
  - 음수 사이클 검출 가능
  - 시간: O(VE) — Dijkstra보다 느림
  - V-1번 반복: 최단 경로는 최대 V-1개 간선
```

## 3. Floyd-Warshall

```python
def floyd_warshall(n, dist):
    """dist[i][j] = i→j 가중치 (없으면 inf)"""
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    return dist
```

```
모든 쌍 최단 경로: O(V³)

  핵심 아이디어: "중간 노드 k를 거쳐가는 것이 더 짧은가?"
  dp[k][i][j] = 0..k를 중간에 사용할 때 i→j 최단 거리

  음수 가중치 허용, 음수 사이클 검출 (dist[i][i] < 0)
  적합: V ≤ 500 정도의 소규모 그래프
```

## 4. Johnson's Algorithm

```
Johnson's: 희소 그래프의 모든 쌍 최단 경로

  Floyd-Warshall O(V³) vs Johnson O(V² log V + VE)
  → E << V²인 희소 그래프에서 Johnson이 유리

  과정:
  1. 가상 노드 s 추가, 모든 노드에 가중치 0 간선
  2. Bellman-Ford(s) → h[v] = s에서 v까지 거리
  3. 재가중치: w'(u,v) = w(u,v) + h[u] - h[v] ≥ 0
  4. 각 노드에서 Dijkstra (재가중치는 양수!)
  5. 원래 거리로 복원
```

| 알고리즘 | 시간 | 음수 가중치 | 음수 사이클 | 적합 |
|---------|------|-----------|-----------|------|
| BFS | $O(V+E)$ | 불가 | 불가 | 무가중 |
| Dijkstra | $O((V+E)\log V)$ | 불가 | 불가 | 양수 가중, 단일 출발 |
| Bellman-Ford | $O(VE)$ | 가능 | 검출 | 음수 가중, 단일 출발 |
| Floyd-Warshall | $O(V^3)$ | 가능 | 검출 | 모든 쌍, 밀집 |
| Johnson | $O(V^2\log V+VE)$ | 가능 | 검출 | 모든 쌍, 희소 |

> **핵심 직관**: 실무에서 최단 경로의 90%는 **Dijkstra**로 충분합니다. 음수 가중치는 대부분의 실제 그래프에서 없으며, Dijkstra + 이진 힙이 가장 실용적입니다.

## 5. A* 알고리즘

```
A*: Dijkstra + 휴리스틱

  f(n) = g(n) + h(n)
  g(n): 시작점에서 n까지의 실제 비용
  h(n): n에서 목표까지의 추정 비용 (휴리스틱)

  h(n) 조건 (Admissible):
  h(n) ≤ 실제 비용 → 최적 해 보장

  격자에서: h = 맨해튼 거리 또는 유클리드 거리
  → 목표 방향으로 탐색 집중
  → Dijkstra보다 탐색 노드 수 크게 감소

  def a_star(graph, start, goal, heuristic):
      pq = [(heuristic(start, goal), 0, start)]
      g_score = {start: 0}
      while pq:
          f, g, u = heapq.heappop(pq)
          if u == goal: return g
          for v, w in graph[u]:
              ng = g + w
              if ng < g_score.get(v, float('inf')):
                  g_score[v] = ng
                  heapq.heappush(pq, (ng + heuristic(v, goal), ng, v))
      return -1
```

> **핵심 직관**: A*는 "목표를 아는 Dijkstra"입니다. 휴리스틱이 정확할수록 탐색 범위가 좁아지며, 완벽한 휴리스틱이면 일직선으로 목표에 도달합니다. 게임 AI 경로 탐색의 표준입니다.

## 6. 실전 최적화

```
Dijkstra 최적화:

  1. Bidirectional Dijkstra:
     시작과 끝에서 동시에 Dijkstra
     만나면 종료 → 탐색 범위 절반

  2. 계층적 전처리 (Contraction Hierarchies):
     도로 네트워크: 중요 노드(고속도로)에 지름길 추가
     → 쿼리 시간 수 ms (수백만 노드)
     Google Maps, OSRM 등이 사용

  3. Multi-source BFS:
     여러 시작점에서 동시에 BFS
     → "가장 가까운 시설" 문제
```

최단 경로는 ga-03의 MST와 비교되며, ga-04의 네트워크 플로우에서 증가 경로 탐색에 사용됩니다.

## 핵심 정리

- **Dijkstra**는 양수 가중치 그래프에서 $O((V+E)\log V)$로 단일 출발점 최단 경로를 구합니다
- **Bellman-Ford**는 음수 가중치를 허용하고 음수 사이클을 검출하지만 $O(VE)$로 느립니다
- **Floyd-Warshall**은 모든 쌍 최단 경로를 $O(V^3)$으로, **Johnson**은 희소 그래프에서 더 효율적으로 구합니다
- **A\***는 휴리스틱으로 탐색 범위를 줄여 목표 지향적 최단 경로를 효율적으로 찾습니다
- 실무 내비게이션은 **Contraction Hierarchies** 전처리로 수백만 노드에서도 ms 단위 쿼리를 달성합니다
