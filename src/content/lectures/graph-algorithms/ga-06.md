# 강연결 요소와 2-SAT

## 왜 강연결 요소가 중요한가

방향 그래프에서 "A에서 B로도, B에서 A로도 갈 수 있는" 노드들의 집합이 **강연결 요소(SCC, Strongly Connected Component)**입니다. 웹 페이지 분석, 컴파일러 의존성 해결, 회로 분석 등에 핵심적으로 사용됩니다. 특히 SCC를 하나의 노드로 **응축(Condensation)**하면 임의의 방향 그래프가 DAG가 되어, ga-01의 위상 정렬을 적용할 수 있습니다. 그리고 이 구조가 **2-SAT**이라는 논리 만족 가능성 문제를 다항 시간에 풀 수 있게 합니다.

> **핵심 직관**: SCC의 핵심은 **"상호 도달 가능성"**입니다. 같은 SCC 안의 임의의 두 노드는 서로 갈 수 있으므로, SCC 내부는 "하나의 덩어리"로 취급할 수 있습니다. 이 관점이 복잡한 방향 그래프를 단순한 DAG로 변환하는 열쇠입니다.

## 1. SCC의 정의와 성질

```
강연결 요소 (Strongly Connected Component):

  방향 그래프에서, 모든 노드 쌍 (u, v)에 대해
  u → ... → v 경로와 v → ... → u 경로가 모두 존재하는
  최대(maximal) 노드 부분집합

  예:
  1 → 2 → 3 → 1    (SCC₁: {1, 2, 3})
  ↓
  4 → 5 → 4         (SCC₂: {4, 5})
  ↓
  6                  (SCC₃: {6})

  성질:
  1. 모든 노드는 정확히 하나의 SCC에 속함
  2. SCC를 하나의 노드로 축소 → DAG (응축 그래프)
  3. DAG의 위상 순서 = SCC 간의 의존 관계

  응축 그래프 (Condensation):
  SCC₁ → SCC₂ → SCC₃

  이 DAG에서 위상 정렬, 최장 경로 등 DAG 기법 적용 가능
```

## 2. Kosaraju 알고리즘

```python
def kosaraju(graph, graph_rev, n):
    """graph: 원래 그래프, graph_rev: 역방향 그래프"""
    # 1단계: 원래 그래프에서 DFS 후위 순서
    visited = [False] * n
    finish_order = []

    def dfs1(u):
        visited[u] = True
        for v in graph[u]:
            if not visited[v]:
                dfs1(v)
        finish_order.append(u)

    for i in range(n):
        if not visited[i]:
            dfs1(i)

    # 2단계: 역방향 그래프에서, 후위 역순으로 DFS
    visited = [False] * n
    sccs = []

    def dfs2(u, component):
        visited[u] = True
        component.append(u)
        for v in graph_rev[u]:
            if not visited[v]:
                dfs2(v, component)

    for u in reversed(finish_order):
        if not visited[u]:
            comp = []
            dfs2(u, comp)
            sccs.append(comp)

    return sccs
```

```
Kosaraju의 핵심 아이디어:

  왜 2번의 DFS인가?

  1차 DFS (원래 그래프): 후위 순서 결정
  → "깊이 들어간 것부터" 기록
  → 후위 역순 = 대략적 위상 순서

  2차 DFS (역방향 그래프): SCC 추출
  → 역방향에서 도달 가능 = 원래에서 역으로 도달 가능
  → 양방향 도달 가능한 노드만 같은 SCC

  시간: O(V + E) — DFS 2번
  공간: O(V + E) — 역방향 그래프 저장

  직관적 이해:
  u → ... → v 경로 (원래 그래프)
  v → ... → u 경로 (원래) = u → ... → v (역방향)
  양쪽 DFS에서 모두 방문 → 같은 SCC
```

> **핵심 직관**: Kosaraju의 2단계 DFS가 작동하는 이유는 **"후위 역순"**에 있습니다. 1차 DFS에서 늦게 끝난 SCC가 먼저 처리되므로, 2차 DFS에서 다른 SCC로 "넘어가지" 않습니다. 이는 DAG에서 소스 SCC를 먼저 처리하는 것과 같습니다.

## 3. Tarjan 알고리즘

```python
def tarjan_scc(graph, n):
    idx_counter = [0]
    stack = []
    on_stack = [False] * n
    index = [-1] * n      # DFS 방문 순서
    lowlink = [-1] * n     # 도달 가능한 최소 index
    sccs = []

    def strongconnect(v):
        index[v] = lowlink[v] = idx_counter[0]
        idx_counter[0] += 1
        stack.append(v)
        on_stack[v] = True

        for w in graph[v]:
            if index[w] == -1:       # 미방문
                strongconnect(w)
                lowlink[v] = min(lowlink[v], lowlink[w])
            elif on_stack[w]:        # 스택에 있음 = 현재 SCC 후보
                lowlink[v] = min(lowlink[v], index[w])

        # v가 SCC의 루트인지 확인
        if lowlink[v] == index[v]:
            component = []
            while True:
                w = stack.pop()
                on_stack[w] = False
                component.append(w)
                if w == v:
                    break
            sccs.append(component)

    for v in range(n):
        if index[v] == -1:
            strongconnect(v)
    return sccs
```

```
Tarjan의 핵심: lowlink

  index[v]: v가 DFS에서 몇 번째로 방문되었는가
  lowlink[v]: v에서 도달 가능한 노드 중 최소 index

  DFS 스택에 있는 노드 = "아직 SCC가 확정되지 않은 노드"

  lowlink[v] == index[v]이면:
  → v는 SCC의 "루트" (가장 먼저 방문된 노드)
  → 스택에서 v까지 팝 → 하나의 SCC

  예: 1 → 2 → 3 → 1
  DFS: index = [0, 1, 2], 3에서 1로 Back Edge
  lowlink = [0, 0, 0] → 1이 루트 → SCC = {1, 2, 3}

  Kosaraju vs Tarjan:
  Kosaraju: DFS 2번 + 역방향 그래프 필요 → 이해 쉬움
  Tarjan: DFS 1번 + 스택만 필요 → 실무에서 더 효율적
```

| 알고리즘 | DFS 횟수 | 추가 공간 | 장점 |
|---------|---------|----------|------|
| Kosaraju | 2번 | 역방향 그래프 $O(V+E)$ | 직관적, 증명 쉬움 |
| Tarjan | 1번 | 스택 $O(V)$ | 더 빠름, 실무 표준 |

## 4. 응축 그래프와 DAG 활용

```
응축 그래프 구축:

  1. SCC 계산 → 각 노드에 SCC ID 부여
  2. 원래 간선 (u, v)에서 SCC(u) ≠ SCC(v)이면
     → 응축 그래프에 SCC(u) → SCC(v) 간선 추가
  3. 중복 간선 제거

  def build_condensation(graph, n, scc_id):
      """scc_id[v] = v가 속한 SCC 번호"""
      dag = defaultdict(set)
      for u in range(n):
          for v in graph[u]:
              if scc_id[u] != scc_id[v]:
                  dag[scc_id[u]].add(scc_id[v])
      return dag

  응용:
  ├─ SCC 단위 위상 정렬: 작업 단위 스케줄링
  ├─ 모든 노드 도달: DAG의 소스 수 = 필요한 시작점 수
  ├─ 강연결 만들기: max(소스 수, 싱크 수)개 간선 추가
  └─ SCC 내 최단 사이클: 각 SCC에서 BFS
```

## 5. 2-SAT 문제

```
2-SAT (2-Satisfiability):

  (x₁ ∨ x₂) ∧ (¬x₁ ∨ x₃) ∧ (¬x₂ ∨ ¬x₃) ...

  각 절(clause)이 정확히 2개의 리터럴
  → 다항 시간에 풀 수 있음! (3-SAT은 NP-완전, ad-10)

  핵심 변환: 절 → 함의 간선

  (a ∨ b) ⟺ (¬a → b) ∧ (¬b → a)

  "a가 거짓이면 b는 참이어야 하고,
   b가 거짓이면 a는 참이어야 한다"

  예: (x₁ ∨ x₂) ∧ (¬x₁ ∨ x₃) ∧ (¬x₂ ∨ ¬x₃)
  → ¬x₁ → x₂, ¬x₂ → x₁    (1번 절)
  → x₁ → x₃, ¬x₃ → ¬x₁    (2번 절)
  → x₂ → ¬x₃, x₃ → ¬x₂    (3번 절)

  함의 그래프 (Implication Graph):
  2N개 노드: x₁, ¬x₁, x₂, ¬x₂, x₃, ¬x₃
  6개 방향 간선 (위의 함의들)
```

```python
def solve_2sat(n, clauses):
    """
    n: 변수 수 (1~n)
    clauses: [(a, b), ...] a, b는 리터럴
      양수 = 변수, 음수 = NOT
    """
    # 함의 그래프 구축 (2N 노드: 0~2N-1)
    # 변수 x → 2*(x-1), ¬x → 2*(x-1)+1
    def node(literal):
        if literal > 0:
            return 2 * (literal - 1)
        else:
            return 2 * (-literal - 1) + 1

    def neg(v):
        return v ^ 1  # 0↔1, 2↔3, ...

    size = 2 * n
    graph = [[] for _ in range(size)]

    for a, b in clauses:
        # (a ∨ b) → (¬a → b) ∧ (¬b → a)
        graph[neg(node(a))].append(node(b))
        graph[neg(node(b))].append(node(a))

    # SCC 계산 (Tarjan)
    scc_id = tarjan_scc_ids(graph, size)

    # 판별: x와 ¬x가 같은 SCC → 불만족
    for i in range(n):
        if scc_id[2 * i] == scc_id[2 * i + 1]:
            return None  # UNSAT

    # 해 구성: SCC 위상 순서에서 x와 ¬x 중
    # 나중에 나오는 쪽이 True
    assignment = [False] * n
    for i in range(n):
        assignment[i] = scc_id[2 * i] > scc_id[2 * i + 1]
    return assignment
```

```
2-SAT 판별 정리:

  만족 가능 ⟺ 어떤 변수 xᵢ에 대해서도
             xᵢ와 ¬xᵢ가 같은 SCC에 속하지 않음

  증명 직관:
  xᵢ와 ¬xᵢ가 같은 SCC → xᵢ → ... → ¬xᵢ → ... → xᵢ
  → xᵢ = True이면 ¬xᵢ = True (모순!)

  해 구성:
  Tarjan의 SCC 순서 (역위상 순서) 활용
  xᵢ의 SCC가 ¬xᵢ의 SCC보다 나중 → xᵢ = True
  → 자동으로 모순 없는 해 생성

  시간: O(V + E) = O(N + M) (N: 변수 수, M: 절 수)
```

> **핵심 직관**: 2-SAT의 핵심 통찰은 **"논리적 함의(→)가 그래프 간선"**이라는 변환입니다. "a이면 b이다"라는 논리적 연쇄가 그래프의 경로가 되고, 순환적 함의(SCC)가 모순을 의미합니다. 논리 문제를 그래프 문제로 환원하는 아름다운 예입니다.

## 6. 실전 응용

```
응용 1: 웹 그래프 분석
  웹 페이지 → 노드, 하이퍼링크 → 간선
  SCC = 상호 링크된 페이지 커뮤니티
  → 검색 엔진의 페이지 분류 (ga-09 커뮤니티 탐지와 연결)

응용 2: 컴파일러 의존성
  모듈 의존성 그래프에서 순환 의존성 = SCC
  → SCC 단위로 동시 컴파일, 응축 DAG로 빌드 순서 결정

응용 3: 2-SAT 활용
  ├─ 그래프 2-색 칠하기: (u, v) 간선 → (color_u ∨ color_v) 등
  ├─ 시간표 충돌 해결: "A와 B가 같은 시간 불가" 제약
  ├─ 네트워크 설정: "서버에 프로토콜 A 또는 B 적용" 제약
  └─ ad-10의 NP-완전과 대비: 2-SAT은 P, 3-SAT은 NP-완전

면접 팁:
  SCC 문제가 직접 나오기보다,
  "순환 의존성 탐지", "상호 도달 가능성" 형태로 출제됨
  → DFS 기반 사이클 탐지(ga-01)와 구분 필요
```

SCC는 ga-01의 DFS 간선 분류를 심화한 것이며, ga-09의 커뮤니티 탐지와 ad-10의 복잡도 이론(2-SAT vs 3-SAT)에 연결됩니다.

## 핵심 정리

- **SCC**는 방향 그래프에서 상호 도달 가능한 최대 노드 집합이며, 임의의 방향 그래프를 DAG로 **응축**하는 핵심 도구입니다
- **Kosaraju**는 DFS 2번(원래 + 역방향)으로 직관적이고, **Tarjan**은 DFS 1번 + lowlink로 실무에서 더 효율적입니다
- **응축 그래프**는 SCC를 노드로 축소한 DAG로, 위상 정렬과 DAG DP 기법을 적용할 수 있게 합니다
- **2-SAT**은 논리적 함의를 그래프 간선으로 변환하여, SCC로 $O(N+M)$에 만족 가능성을 판별합니다
- $x$와 $\neg x$가 같은 SCC에 속하면 불만족이며, Tarjan의 역위상 순서를 이용해 모순 없는 해를 구성합니다
