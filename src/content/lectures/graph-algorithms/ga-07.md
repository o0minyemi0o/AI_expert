# 트리 알고리즘

## 왜 트리 알고리즘이 중요한가

트리는 "사이클 없는 연결 그래프"로, 계층적 데이터의 자연스러운 표현입니다. 파일 시스템, 조직도, 계통수, XML/JSON 구조 모두 트리입니다. 일반 그래프에서는 어려운 문제들이 트리에서는 효율적으로 풀리며, ga-03의 MST도 결국 트리입니다. 이 강의에서는 **LCA(최소 공통 조상)**, **Heavy-Light Decomposition**, **Euler Tour**, **트리 DP**라는 핵심 기법을 다룹니다.

> **핵심 직관**: 트리 알고리즘의 대부분은 **"트리를 배열로 펼치는 것(linearization)"**에서 시작합니다. Euler Tour로 트리를 배열로 펼치면 서브트리 쿼리가 구간 쿼리가 되고, HLD로 펼치면 경로 쿼리가 구간 쿼리가 됩니다. ads-01의 세그먼트 트리와 결합하면 강력한 도구가 됩니다.

## 1. 최소 공통 조상 (LCA)

```
LCA (Lowest Common Ancestor):

  루트 트리에서 두 노드 u, v의 공통 조상 중 가장 깊은 것

         1
        / \
       2   3
      / \   \
     4   5   6
    /
   7

  LCA(7, 5) = 2   (4의 부모이자 5의 부모)
  LCA(7, 6) = 1   (루트)
  LCA(4, 2) = 2   (2가 4의 조상)

  응용:
  ├─ 두 노드 간 거리: dist(u,v) = depth[u] + depth[v] - 2·depth[LCA(u,v)]
  ├─ 경로 위 최대/최소 가중치 (ga-03 차선 MST)
  └─ 트리 위의 다양한 경로 쿼리
```

```python
# Binary Lifting (Sparse Table) — O(N log N) 전처리, O(log N) 쿼리
def build_lca(graph, root, n):
    LOG = 20  # log₂(N)
    depth = [0] * n
    parent = [[-1] * n for _ in range(LOG)]

    # BFS로 깊이와 직접 부모 계산
    from collections import deque
    queue = deque([root])
    visited = [False] * n
    visited[root] = True
    while queue:
        u = queue.popleft()
        for v in graph[u]:
            if not visited[v]:
                visited[v] = True
                depth[v] = depth[u] + 1
                parent[0][v] = u
                queue.append(v)

    # Sparse Table: parent[k][v] = v의 2^k번째 조상
    for k in range(1, LOG):
        for v in range(n):
            if parent[k-1][v] != -1:
                parent[k][v] = parent[k-1][parent[k-1][v]]

    return depth, parent

def query_lca(u, v, depth, parent, LOG=20):
    # 깊이 맞추기
    if depth[u] < depth[v]:
        u, v = v, u
    diff = depth[u] - depth[v]
    for k in range(LOG):
        if (diff >> k) & 1:
            u = parent[k][u]
    if u == v:
        return u
    # 동시에 올라가기
    for k in range(LOG - 1, -1, -1):
        if parent[k][u] != parent[k][v]:
            u = parent[k][u]
            v = parent[k][v]
    return parent[0][u]
```

```
Binary Lifting의 핵심:

  parent[k][v] = v에서 2^k 칸 위의 조상
  → 임의의 거리를 이진수 분해하여 O(log N) 점프

  예: 13칸 위로 = 8 + 4 + 1칸
  parent[3][v] → parent[2][...] → parent[0][...]

  대안: Euler Tour + Sparse Table RMQ → O(1) 쿼리
  (전처리 O(N log N), 쿼리 O(1))
```

> **핵심 직관**: Binary Lifting의 아이디어는 이진수 표현과 같습니다. "37칸 위의 조상"을 한 칸씩 37번 올라가는 대신, $32 + 4 + 1$로 분해하여 3번만 점프합니다. 이 **"2의 거듭제곱 점프"** 패턴은 Sparse Table(ads-01)과 동일한 원리입니다.

## 2. Euler Tour

```
Euler Tour Technique:

  DFS로 트리를 방문하며, 들어갈 때와 나올 때 기록

         1
        / \
       2   3
      / \
     4   5

  DFS 순서: 1 → 2 → 4 → 4 → 5 → 5 → 2 → 3 → 3 → 1
  tin:       0    1    2         4         6    7
  tout:                    3         5         8    9

  tin[v]: v에 들어간 시점
  tout[v]: v에서 나온 시점

  핵심 성질:
  u가 v의 조상 ⟺ tin[u] ≤ tin[v] ≤ tout[v] ≤ tout[u]

  서브트리 쿼리:
  v의 서브트리 = euler[tin[v] ... tout[v]] 구간!
  → 세그먼트 트리로 구간 합/최대/최소 = O(log N)
```

```python
def euler_tour(graph, root, n):
    tin = [0] * n
    tout = [0] * n
    euler = []
    timer = [0]

    def dfs(u, parent):
        tin[u] = timer[0]
        euler.append(u)
        timer[0] += 1
        for v in graph[u]:
            if v != parent:
                dfs(v, u)
        tout[u] = timer[0] - 1

    dfs(root, -1)
    return tin, tout, euler
```

```
Euler Tour + 세그먼트 트리 조합:

  문제: "서브트리 내 노드 값의 합"을 반복 쿼리
  → euler 순서로 배열에 매핑
  → seg_tree[tin[v] : tout[v]+1]의 구간 합

  문제: "서브트리 내 모든 노드에 값 더하기"
  → 구간 업데이트 = ads-02의 Lazy Propagation

  이 변환이 강력한 이유:
  트리의 2차원적 구조 → 1차원 배열
  서브트리 연산 → 연속 구간 연산
  → O(log N)에 처리 가능
```

## 3. Heavy-Light Decomposition

```
HLD (Heavy-Light Decomposition):

  목표: 트리의 "경로 쿼리"를 효율적으로 처리
  (서브트리가 아닌, 노드 u에서 v까지의 경로)

  핵심 아이디어:
  각 노드에서 가장 큰 서브트리의 자식 = heavy child
  나머지 = light child

         1 (size=7)
        / \
  heavy→2(5)  3(1)
      / \
 heavy→4(3)  5(1)
    / \
   6(1) 7(1)

  Heavy 간선: 1→2, 2→4 (가장 큰 자식)
  Heavy 체인: [1, 2, 4] (연속 배열 구간)

  성질:
  임의의 경로에서 light 간선 ≤ O(log N)개
  → 경로가 최대 O(log N)개의 heavy 체인 구간으로 분해
  → 각 구간을 세그먼트 트리로 O(log N) 처리
  → 총 O(log²N) per 경로 쿼리

  경로 쿼리 처리:
  1. u, v에서 LCA까지 올라가며
  2. 같은 heavy 체인이면 → 세그먼트 트리 구간 쿼리
  3. 다른 체인이면 → 체인 top까지 쿼리 후 light 간선 넘기
```

```python
def hld_decompose(graph, root, n):
    parent = [0] * n
    depth = [0] * n
    size = [1] * n
    heavy = [-1] * n  # heavy child
    head = [0] * n    # 체인의 head 노드
    pos = [0] * n     # 세그먼트 트리에서의 위치

    # 1단계: 서브트리 크기, heavy child 결정 (DFS)
    # 2단계: heavy 체인 따라 연속 번호 부여 (DFS)

    # heavy 체인의 노드들은 세그먼트 트리에서 연속 구간
    # → 경로 쿼리 = O(log N)개 구간의 쿼리
    # → 총 O(log²N)

    return head, pos, parent, depth
```

> **핵심 직관**: HLD의 핵심은 **"무거운 간선을 따라가면 구간이 연속"**이라는 점입니다. 트리의 경로를 $O(\log N)$개의 연속 구간으로 분해하고, 각 구간에 세그먼트 트리를 적용합니다. 경쟁 프로그래밍에서 트리 경로 쿼리의 표준 기법입니다.

## 4. 트리 DP

```
트리 DP: DFS 후위 순서로 자식 → 부모 방향 계산

문제 1: 트리의 지름 (가장 먼 두 노드 거리)

  def tree_diameter(graph, n):
      # 방법 1: BFS 2번
      # 임의 노드에서 BFS → 가장 먼 노드 u
      # u에서 BFS → 가장 먼 노드까지 거리 = 지름

      # 방법 2: 트리 DP
      diameter = [0]
      def dfs(u, parent):
          depths = [0]  # 자식 방향 최대 깊이들
          for v in graph[u]:
              if v != parent:
                  d = dfs(v, u) + 1
                  depths.append(d)
          depths.sort(reverse=True)
          # 가장 깊은 두 경로를 합치면 u를 지나는 최장 경로
          if len(depths) >= 2:
              diameter[0] = max(diameter[0], depths[0] + depths[1])
          return depths[0]
      dfs(0, -1)
      return diameter[0]

문제 2: 트리에서 독립 집합 (인접하지 않은 노드 최대 선택)

  dp[v][0] = v를 선택하지 않을 때 서브트리 최대
  dp[v][1] = v를 선택할 때 서브트리 최대

  dp[v][0] = Σ max(dp[child][0], dp[child][1])
  dp[v][1] = weight[v] + Σ dp[child][0]
```

```
트리 DP 패턴 정리:

  ├─ 서브트리 집계: 각 노드에서 서브트리의 합/최대/개수
  ├─ 선택/비선택: 각 노드를 포함/미포함으로 나눠 DP
  ├─ 경로 합치기: 자식 방향 최장 두 경로 → 지름
  ├─ Rerooting: 루트를 바꿔가며 DP (전체 노드에 대해)
  └─ 트리 배낭: 서브트리에서 k개 선택 최적화

  Rerooting Technique:
  1차 DFS: 루트 기준 DP 계산
  2차 DFS: 부모로부터 받는 기여분을 전파
  → 모든 노드를 루트로 한 DP를 O(N)에 계산
```

## 5. 실전 응용

```
응용 1: 파일 시스템 쿼리
  "이 디렉토리의 총 파일 크기?" → 서브트리 합 (Euler Tour + ST)
  "이 파일의 루트까지 경로?" → LCA 응용

응용 2: 네트워크 라우팅
  트리 네트워크에서 두 노드 간 경로의 최소 대역폭
  → 경로 최솟값 쿼리 (HLD + 세그먼트 트리)

응용 3: 계통 분석
  생물 분류 체계에서 두 종의 공통 조상
  → LCA

응용 4: 게임 트리
  미니맥스 알고리즘 = 트리 DP의 특수 형태
  각 노드에서 max/min을 번갈아 적용

응용 5: 경쟁 프로그래밍 빈출
  ├─ 트리에서 K번째 조상: Binary Lifting
  ├─ 경로 위 노드 개수/합: HLD + 세그먼트 트리
  ├─ 서브트리 업데이트: Euler Tour + Lazy Propagation
  └─ 트리 지름/중심: 트리 DP 또는 BFS 2번
```

트리 알고리즘은 ads-01의 세그먼트 트리, ads-02의 Lazy Propagation과 결합되며, ga-03의 MST에서 생성된 트리에 적용됩니다.

## 핵심 정리

- **LCA**는 Binary Lifting으로 $O(N \log N)$ 전처리, $O(\log N)$ 쿼리로 구하며, 경로 거리/최대값 등 다양한 경로 쿼리의 기반입니다
- **Euler Tour**는 트리를 1차원 배열로 펼쳐서, 서브트리 쿼리를 구간 쿼리로 변환합니다 ($O(\log N)$)
- **HLD**는 heavy 체인으로 경로를 $O(\log N)$개 구간으로 분해하여, 경로 쿼리를 $O(\log^2 N)$에 처리합니다
- **트리 DP**는 DFS 후위 순서로 자식→부모 방향으로 계산하며, 지름/독립 집합/Rerooting 등의 패턴이 있습니다
- 트리 알고리즘의 핵심은 **"트리를 배열로 펼치고 세그먼트 트리와 결합"**하는 linearization 기법입니다
