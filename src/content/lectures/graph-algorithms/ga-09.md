# 커뮤니티 탐지

## 왜 커뮤니티 탐지가 중요한가

소셜 네트워크에서 친구 그룹, 논문 인용 네트워크에서 연구 분야, 단백질 상호작용 네트워크에서 기능 모듈—이들은 모두 그래프의 **커뮤니티(Community)** 구조입니다. 커뮤니티 내부는 간선이 밀집하고 외부는 희소한 부분 그래프를 찾는 것이 목표입니다. ga-08의 스펙트럴 방법이 이론적 기반이라면, 이 강의에서는 **실용적 대규모 커뮤니티 탐지** 알고리즘을 다룹니다.

> **핵심 직관**: 커뮤니티 탐지의 핵심 척도가 **모듈러리티(Modularity)**입니다. "실제 커뮤니티 내부 간선 수"와 "랜덤 그래프에서의 기대값"의 차이를 측정합니다. 이 차이가 클수록 커뮤니티 구조가 뚜렷합니다.

## 1. 모듈러리티 (Modularity)

```
모듈러리티 Q:

  Q = (1/2m) Σᵢⱼ [Aᵢⱼ - (dᵢdⱼ/2m)] δ(cᵢ, cⱼ)

  m: 총 간선 수
  Aᵢⱼ: 인접 행렬
  dᵢ: 노드 i의 차수
  cᵢ: 노드 i가 속한 커뮤니티
  δ(cᵢ, cⱼ): 같은 커뮤니티면 1, 아니면 0

  직관:
  Aᵢⱼ = 실제 간선 존재 여부
  dᵢdⱼ/2m = 랜덤(Configuration Model)에서의 기대 간선 확률

  Q > 0: 커뮤니티 내부 간선이 랜덤보다 많음 → 좋은 분할
  Q ≈ 0: 랜덤과 차이 없음 → 커뮤니티 구조 없음
  Q의 범위: [-0.5, 1), 실제 네트워크에서 0.3~0.7이 일반적

  커뮤니티 단위로 정리:
  Q = Σ_c [eₒ/m - (dₒ/2m)²]

  eₒ: 커뮤니티 c 내부 간선 수
  dₒ: 커뮤니티 c 내 노드들의 총 차수
```

```
모듈러리티의 한계:

  1. 해상도 한계 (Resolution Limit):
     작은 커뮤니티를 감지하지 못함
     → 총 간선 m이 크면, 작은 클리크도 합쳐버림

  2. 최적화가 NP-hard:
     Q를 최대화하는 분할을 찾는 것은 NP-hard
     → 휴리스틱 사용 (Louvain, Leiden)

  3. 해상도 매개변수 γ로 완화:
     Q_γ = (1/2m) Σ [Aᵢⱼ - γ(dᵢdⱼ/2m)] δ(cᵢ, cⱼ)
     γ > 1: 더 작은 커뮤니티 선호
     γ < 1: 더 큰 커뮤니티 선호
```

## 2. Louvain 알고리즘

```
Louvain: 가장 널리 쓰이는 커뮤니티 탐지 알고리즘

  Phase 1 (Local Moving):
  1. 각 노드를 자신만의 커뮤니티로 초기화
  2. 각 노드를 이웃 커뮤니티로 옮겨보며 ΔQ 계산
  3. ΔQ가 최대인 커뮤니티로 이동
  4. 변화가 없을 때까지 반복

  Phase 2 (Aggregation):
  5. 각 커뮤니티를 하나의 "슈퍼 노드"로 축소
  6. 커뮤니티 간 간선을 합산
  7. Phase 1로 돌아가 반복

  수렴까지 반복 → 계층적 커뮤니티 구조

  ΔQ 계산 (노드 i를 커뮤니티 C로 이동):
  ΔQ = [Σ_in + 2kᵢ_in] / 2m - [(Σ_tot + kᵢ)/2m]²
     - [Σ_in/2m - (Σ_tot/2m)² - (kᵢ/2m)²]

  Σ_in: C 내부 간선 가중치 합
  Σ_tot: C 노드들의 총 차수
  kᵢ_in: i와 C 내 노드들 사이 간선 가중치 합
  kᵢ: i의 차수
```

```python
def louvain_one_phase(graph, n):
    """Phase 1: Local Moving"""
    community = list(range(n))  # 초기: 각 노드 = 커뮤니티
    improved = True
    while improved:
        improved = False
        for i in range(n):
            best_community = community[i]
            best_delta = 0
            # 현재 커뮤니티에서 제거
            current_comm = community[i]
            # 이웃 커뮤니티들 시도
            neighbor_comms = set()
            for j, w in graph[i]:
                neighbor_comms.add(community[j])
            for c in neighbor_comms:
                delta = compute_delta_q(i, c, graph, community)
                if delta > best_delta:
                    best_delta = delta
                    best_community = c
            if best_community != current_comm:
                community[i] = best_community
                improved = True
    return community
```

```
Louvain의 특성:

  시간: O(E) per pass (실용적으로 매우 빠름)
  전체: O(E × number_of_passes)
  → 수억 간선 그래프도 분 단위 처리

  장점: 빠름, 구현 간단, 계층 구조 제공
  단점: 비결정적 (노드 순서에 의존)
        잘못 연결된 커뮤니티 (poorly connected)

  Leiden 알고리즘 (Louvain 개선):
  ├─ Louvain의 "잘못 연결된 커뮤니티" 문제 해결
  ├─ Refinement Phase 추가
  ├─ 수렴 보장
  └─ 실무에서 Louvain 대체 추세
```

> **핵심 직관**: Louvain의 속도 비결은 **"지역 최적화의 반복"**입니다. 각 노드가 이웃 커뮤니티 중 ΔQ를 최대화하는 곳으로 이동하고, 수렴 후 축소하여 다시 반복합니다. 전역 최적은 아니지만, 실무에서 충분히 좋은 결과를 매우 빠르게 제공합니다.

## 3. Label Propagation

```
Label Propagation Algorithm (LPA):

  가장 단순한 커뮤니티 탐지

  1. 각 노드에 고유 라벨 부여
  2. 각 노드의 라벨을 이웃 중 최다 라벨로 변경
  3. 변화가 없을 때까지 반복

  예:
  초기:    A(1) — B(2) — C(3)
           |             |
           D(4) — E(5) — F(6)

  1라운드: A(2) — B(1) — C(6)  (이웃 중 최다)
           |             |
           D(1) — E(4) — F(3)

  ...수렴: {A,B,D} = 라벨1, {C,E,F} = 라벨6

  장점:
  - O(E) per iteration, 매우 빠름
  - 구현 극히 간단
  - 사전에 커뮤니티 수 지정 불필요

  단점:
  - 비결정적 (타이 브레이킹에 의존)
  - 불안정할 수 있음 (진동)
  - 해상도 한계 없음 (너무 큰 커뮤니티 가능)

  변형:
  ├─ 비동기 LPA: 노드를 랜덤 순서로 갱신 (수렴 개선)
  ├─ 가중 LPA: 간선 가중치 고려
  └─ Semi-supervised LPA: 일부 노드 라벨 고정
```

## 4. Stochastic Block Model (SBM)

```
SBM: 커뮤니티 구조의 확률적 생성 모델

  설정:
  - N개 노드, K개 커뮤니티
  - 각 노드가 커뮤니티에 속할 확률
  - 커뮤니티 i, j 사이 간선 확률 = pᵢⱼ

  예: K=2, N=100
  같은 커뮤니티 내 간선: p_in = 0.3
  다른 커뮤니티 간 간선: p_out = 0.01

  연결 확률 행렬:
  P = [[0.3,  0.01],
       [0.01, 0.3 ]]

  → 두 개의 밀집 클러스터 + 약한 연결

  SBM의 역할:
  1. 벤치마크: 알고리즘 성능 평가
  2. 탐지 한계 이론: 언제 커뮤니티를 구분할 수 있는가?
  3. 추론: 관측된 그래프에서 SBM 매개변수 추정
```

```
SBM 탐지 한계 (Detection Threshold):

  두 커뮤니티 대칭 SBM (각 N/2 노드):
  p_in = a/N, p_out = b/N

  탐지 가능 조건:
  (a - b)² > 2(a + b)

  이 조건 이하에서는 어떤 알고리즘도
  랜덤보다 유의미하게 좋은 결과를 낼 수 없음!

  정보 이론적 한계:
  ├─ 약한 탐지: 랜덤보다 약간 나은 분류
  ├─ 정확한 복원: 모든 노드를 올바른 커뮤니티에 배치
  └─ (a-b)²/2(a+b) > 1에서 약한 탐지 가능

  Degree-Corrected SBM:
  실제 네트워크의 차수 분포(멱법칙, ga-10)를 반영
  → 순수 SBM보다 현실적인 모델
```

> **핵심 직관**: SBM의 탐지 한계 이론은 **"아무리 좋은 알고리즘도 넘을 수 없는 벽"**을 보여줍니다. 커뮤니티 간 차이가 충분히 크지 않으면 구조적으로 구분이 불가능합니다. 이는 알고리즘 성능을 평가할 때 중요한 기준선입니다.

## 5. 알고리즘 비교와 선택

```
알고리즘별 특성:

  | 알고리즘 | 시간 | K 필요 | 장점 | 단점 |
  |---------|------|--------|------|------|
  | Louvain | O(E) | 불필요 | 빠름, 계층적 | 비결정적 |
  | Leiden | O(E) | 불필요 | Louvain 개선 | 구현 복잡 |
  | LPA | O(E) | 불필요 | 매우 빠름/간단 | 불안정 |
  | 스펙트럴 | O(N²~³) | 필요 | 이론적 보장 | 대규모 불가 |
  | SBM 추론 | O(NE) | 필요 | 통계적 엄밀 | 느림 |

  선택 기준:
  ├─ 대규모 (>10M 노드): Louvain/Leiden 또는 LPA
  ├─ 중규모 + 품질: Leiden
  ├─ 이론적 분석: SBM 추론
  ├─ K 알려진 + 비볼록: 스펙트럴 (ga-08)
  └─ 겹치는 커뮤니티: BIGCLAM, NMF 기반
```

## 6. 실전 응용

```
응용 1: 소셜 네트워크 분석
  사용자 → 노드, 팔로우/친구 → 간선
  커뮤니티 = 관심사 그룹, 지역 커뮤니티
  → 추천 시스템: 같은 커뮤니티 내 추천 (dl-14)

응용 2: 생물정보학
  단백질 상호작용 네트워크에서 기능 모듈 발견
  유전자 공동 발현 네트워크 → 질병 관련 유전자군

응용 3: 사기 탐지
  금융 거래 네트워크에서 비정상 커뮤니티 탐지
  정상 거래와 다른 패턴의 노드 그룹 → 조직적 사기

응용 4: 지식 그래프
  개체-관계 그래프에서 주제별 클러스터
  → NLP 질의 응답, 추천 (llm-09)

평가 지표:
  ├─ NMI (Normalized Mutual Information): 실제 레이블 대비
  ├─ ARI (Adjusted Rand Index): 쌍 기반 평가
  ├─ 모듈러리티 Q: 레이블 없이 평가
  └─ 분할 밀도: 내부 밀도 vs 외부 밀도
```

커뮤니티 탐지는 ga-08의 스펙트럴 이론을 실용화한 것이며, ga-10의 네트워크 모델이 벤치마크를, ga-12의 GNN이 학습 기반 대안을 제공합니다.

## 핵심 정리

- **모듈러리티** $Q$는 커뮤니티 내부 간선이 랜덤 대비 얼마나 많은지 측정하며, 0.3~0.7이 좋은 분할입니다
- **Louvain**은 지역적 ΔQ 최대화 + 그래프 축소를 반복하여 $O(E)$에 대규모 그래프를 처리합니다
- **Label Propagation**은 이웃 최다 라벨을 복사하는 가장 단순한 방법이며 $O(E)$로 매우 빠릅니다
- **SBM**은 커뮤니티의 확률적 생성 모델로, $(a-b)^2 > 2(a+b)$이 탐지 가능 조건이라는 이론적 한계를 제공합니다
- 실무에서는 **Leiden**(Louvain 개선)이 품질과 속도의 균형이 가장 좋으며, 겹치는 커뮤니티에는 별도 모델이 필요합니다
