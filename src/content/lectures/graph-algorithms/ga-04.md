# 네트워크 플로우

## 왜 네트워크 플로우가 중요한가

"서울에서 부산까지 고속도로 네트워크를 통해 최대 몇 대의 차량을 보낼 수 있는가?" 이것이 **최대 유량(Maximum Flow)** 문제입니다. 단순해 보이지만, 이분 매칭(ga-05), 최소 컷, 프로젝트 선택, 이미지 분할 등 놀랍도록 다양한 문제가 플로우로 환원됩니다. 조합 최적화의 핵심 도구입니다.

> **핵심 직관**: 최대 유량-최소 컷 정리(Max-Flow Min-Cut Theorem)가 이 분야의 근간입니다. "네트워크를 통해 보낼 수 있는 최대 유량 = 네트워크를 두 쪽으로 자르는 최소 비용". 이 쌍대성이 수많은 문제를 연결합니다.

## 1. 플로우 네트워크 기본 개념

```
플로우 네트워크:

  방향 그래프 G = (V, E)
  소스(s): 유량 발생지
  싱크(t): 유량 도착지
  용량(capacity): 각 간선의 최대 유량

  제약:
  1. 용량 제약: 0 ≤ f(u,v) ≤ c(u,v)
  2. 유량 보존: s, t 제외한 모든 노드에서
     들어오는 유량 = 나가는 유량

  예:
       10     8
  s ───→ a ───→ t
  │      ↑      ↑
  │  5   │ 3    │ 7
  └──→ b ┘──→ c─┘

  최대 유량: s→a→t (8) + s→b→c→t (5) = 13? 아니면 더?
  → 알고리즘이 필요
```

## 2. Ford-Fulkerson 방법

```
Ford-Fulkerson:

  핵심 아이디어: 잔여 그래프(Residual Graph)에서
  s→t 경로(증가 경로)를 반복적으로 찾아 유량을 보냄

  잔여 그래프:
  간선 (u,v)에 유량 f, 용량 c일 때:
  - 정방향 잔여: c - f (아직 보낼 수 있는 양)
  - 역방향 잔여: f (유량을 취소할 수 있는 양)

  역방향 간선이 핵심!
  → 잘못된 경로 선택을 나중에 "되돌릴" 수 있음

  알고리즘:
  1. 모든 유량 = 0
  2. 잔여 그래프에서 s→t 경로 찾기
  3. 경로의 최소 잔여 용량(병목)만큼 유량 추가
  4. 잔여 그래프 갱신
  5. 경로가 없을 때까지 반복

  예:
  원래:    s ─(10)→ a ─(8)→ t
  유량 8:  s ─(2/10)→ a ─(0/8)→ t
  잔여:    s ─(2)→ a ─(0)→ t
           s ←(8)─ a ←(8)─ t  (역방향)
```

```python
def ford_fulkerson_bfs(graph, source, sink, n):
    """Edmonds-Karp: BFS로 증가 경로 탐색"""
    def bfs(source, sink, parent):
        visited = {source}
        queue = deque([source])
        while queue:
            u = queue.popleft()
            for v in range(n):
                if v not in visited and graph[u][v] > 0:
                    visited.add(v)
                    parent[v] = u
                    if v == sink:
                        return True
                    queue.append(v)
        return False

    max_flow = 0
    parent = [-1] * n
    while bfs(source, sink, parent):
        # 병목 찾기
        path_flow = float('inf')
        v = sink
        while v != source:
            u = parent[v]
            path_flow = min(path_flow, graph[u][v])
            v = u
        # 잔여 그래프 갱신
        v = sink
        while v != source:
            u = parent[v]
            graph[u][v] -= path_flow
            graph[v][u] += path_flow
            v = u
        max_flow += path_flow
        parent = [-1] * n
    return max_flow
```

> **핵심 직관**: 역방향 간선이 Ford-Fulkerson의 핵심입니다. "이전에 보낸 유량을 취소하고 다른 경로로 보내는" 효과를 만들어, 그리디하게 선택해도 최적에 도달할 수 있게 합니다.

## 3. Edmonds-Karp와 시간 복잡도

```
증가 경로 탐색 방법에 따른 복잡도:

  Ford-Fulkerson (DFS): O(E × max_flow)
  → 최대 유량이 크면 매우 느림
  → 무한 루프 가능 (무리수 용량 시)

  Edmonds-Karp (BFS): O(VE²)
  → 항상 최단 증가 경로 선택
  → 증가 경로 수가 O(VE)로 제한됨
  → 가장 많이 사용되는 변형

  Dinic's Algorithm: O(V²E)
  → 레벨 그래프 + 블로킹 플로우
  → 단위 용량 그래프: O(E√V)
  → 이분 매칭에서 매우 효율적

  Push-Relabel: O(V²E) 또는 O(V³)
  → 글로벌 증가 경로 대신 로컬 푸시
  → 실무에서 가장 빠른 경우 많음
```

| 알고리즘 | 시간 | 특징 |
|---------|------|------|
| Edmonds-Karp | $O(VE^2)$ | BFS, 구현 쉬움 |
| Dinic | $O(V^2E)$ | 레벨 그래프, 이분 매칭에 빠름 |
| Push-Relabel | $O(V^2E)$ | 로컬 연산, 실무 최고 |

## 4. 최대 유량-최소 컷 정리

```
최소 컷 (Minimum Cut):

  그래프를 S(소스 포함)와 T(싱크 포함)로 분할
  S→T로 가는 간선의 용량 합 = 컷 용량

  Max-Flow Min-Cut Theorem:
  최대 유량 = 최소 컷 용량

  최소 컷 찾기:
  1. 최대 유량 실행
  2. 잔여 그래프에서 소스에서 도달 가능한 노드 = S
  3. 나머지 = T
  4. S→T 간선이 최소 컷

  응용:
  ├─ 네트워크 신뢰성: 최소 컷 = 가장 취약한 부분
  ├─ 이미지 분할: 전경(S)과 배경(T)으로 분리
  └─ 프로젝트 선택: 이익 최대화 = 최소 컷
```

## 5. 플로우 네트워크 모델링

```
다양한 문제를 플로우로 변환:

  1. 이분 매칭 → 단위 용량 플로우 (ga-05)
     s → L의 각 노드(용량 1) → R의 각 노드(용량 1) → t

  2. 노드 용량 → 노드 분할
     용량 c인 노드 v → v_in ─(c)→ v_out
     들어오는 간선 → v_in, 나가는 간선 ← v_out

  3. 하한 있는 플로우 (Lower Bound)
     l ≤ f(u,v) ≤ c → 변환으로 처리

  4. 최소 비용 최대 유량
     각 간선에 비용 추가: 같은 유량 중 최소 비용
     → 벨만-포드로 최소 비용 증가 경로 탐색
```

> **핵심 직관**: 플로우 문제의 어려운 부분은 "알고리즘 실행"이 아니라 **"실세계 문제를 플로우 네트워크로 모델링하는 것"**입니다. 소스/싱크 설정, 용량 배정, 노드 분할 등의 모델링 기법이 핵심 스킬입니다.

## 6. 실전 응용

```
응용 1: 항공편 스케줄링
  승무원을 비행편에 최소 인원으로 배정
  → 최소 플로우 문제

응용 2: 네트워크 대역폭
  라우터 간 최대 데이터 전송량
  → 최대 유량

응용 3: 야구 순위 결정
  "팀 X가 아직 우승할 수 있는가?"
  → 최대 유량으로 판별 (나머지 경기 결과 분배)

응용 4: 이미지 분할 (Graph Cut)
  각 픽셀 → 노드, 인접 픽셀 → 간선
  s = 전경, t = 배경
  최소 컷 = 최적 분할 경계
```

네트워크 플로우는 ga-05의 이분 매칭으로 이어지며, ad-07의 근사 알고리즘에서 LP 이완과 연결됩니다.

## 핵심 정리

- **최대 유량**은 소스에서 싱크로 보낼 수 있는 최대 양이며, 잔여 그래프에서 증가 경로를 반복 탐색하여 구합니다
- **역방향 간선**이 Ford-Fulkerson의 핵심으로, 이전 선택을 "되돌리는" 효과를 만들어 최적해에 도달합니다
- **Max-Flow Min-Cut 정리**에 의해 최대 유량 = 최소 컷이며, 이 쌍대성이 다양한 문제를 연결합니다
- **Edmonds-Karp**(BFS)는 $O(VE^2)$로 가장 구현이 쉽고, **Dinic**은 이분 매칭에서 $O(E\sqrt{V})$로 빠릅니다
- 플로우의 핵심 스킬은 알고리즘 자체보다 **실세계 문제를 플로우 네트워크로 모델링**하는 것입니다
