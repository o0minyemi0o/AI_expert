# 그래프 표현과 탐색

## 왜 그래프 기초가 중요한가

그래프는 CS에서 가장 범용적인 추상화입니다. 소셜 네트워크, 도로망, 의존성 관리, 웹 페이지 링크, 신경망 구조 모두 그래프로 모델링됩니다. 이 강의에서 다루는 **표현 방법, BFS, DFS, 위상 정렬**은 이후 모든 그래프 알고리즘(ga-02~12)의 기반입니다.

> **핵심 직관**: 그래프 문제 풀이의 첫 단계는 "이 문제가 BFS인가 DFS인가"를 판단하는 것입니다. **최단 경로/최소 단계 → BFS**, **연결성/사이클 탐지/위상 정렬 → DFS**가 기본 선택입니다.

## 1. 그래프 표현

```
인접 리스트 (Adjacency List):
  graph = {
      0: [1, 2],
      1: [0, 3],
      2: [0, 3],
      3: [1, 2]
  }
  공간: O(V + E)
  간선 존재 확인: O(degree)
  적합: 희소 그래프 (대부분의 실제 그래프)

인접 행렬 (Adjacency Matrix):
  [[0,1,1,0],
   [1,0,0,1],
   [1,0,0,1],
   [0,1,1,0]]
  공간: O(V²)
  간선 존재 확인: O(1)
  적합: 밀집 그래프, 행렬 연산 (ga-08 스펙트럴)

간선 리스트 (Edge List):
  [(0,1), (0,2), (1,3), (2,3)]
  공간: O(E)
  적합: 정렬 후 처리 (크루스칼 MST, ga-03)
```

| 표현 | 공간 | 간선 확인 | 이웃 순회 | 적합 |
|------|------|----------|----------|------|
| 인접 리스트 | $O(V+E)$ | $O(d)$ | $O(d)$ | 대부분 |
| 인접 행렬 | $O(V^2)$ | $O(1)$ | $O(V)$ | 밀집, 행렬 연산 |
| 간선 리스트 | $O(E)$ | $O(E)$ | $O(E)$ | 정렬 기반 |

## 2. BFS (너비 우선 탐색)

```python
from collections import deque

def bfs(graph, start):
    visited = {start}
    queue = deque([start])
    order = []
    while queue:
        node = queue.popleft()
        order.append(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    return order
```

```
BFS 특성:
  - 레벨 순서로 탐색 (시작점에서 가까운 순)
  - 무가중 그래프의 최단 경로 보장
  - 시간: O(V + E), 공간: O(V)

  응용:
  ├─ 최단 경로 (무가중): BFS 레벨 = 거리
  ├─ 이분 그래프 판별: 인접 노드에 다른 색
  ├─ 연결 요소: 미방문 노드에서 BFS 반복
  └─ 미로 탈출: 격자 그래프 BFS
```

## 3. DFS (깊이 우선 탐색)

```python
def dfs(graph, start):
    visited = set()
    order = []

    def _dfs(node):
        visited.add(node)
        order.append(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                _dfs(neighbor)

    _dfs(start)
    return order
```

```
DFS 시간 분류 (방향 그래프):

  각 간선 (u, v)를 DFS 중 분류:
  ├─ Tree Edge: DFS 트리의 간선
  ├─ Back Edge: 조상으로 가는 간선 → 사이클 존재!
  ├─ Forward Edge: 자손으로 가는 비트리 간선
  └─ Cross Edge: 다른 서브트리로 가는 간선

  사이클 탐지:
  Back Edge가 존재 ↔ 사이클 존재
```

> **핵심 직관**: DFS의 간선 분류가 강력한 이유는, **Back Edge = 사이클**, **모든 간선이 Tree Edge = DAG**이기 때문입니다. 이 성질이 위상 정렬과 SCC(ga-06)의 기반입니다.

## 4. 위상 정렬

```
위상 정렬 (Topological Sort):
  DAG(방향 비순환 그래프)의 노드를 순서대로 나열
  모든 간선 (u, v)에 대해 u가 v보다 앞에 위치

  방법 1: DFS 후위 순서의 역순
  def topological_sort_dfs(graph, n):
      visited = [False] * n
      order = []
      def dfs(u):
          visited[u] = True
          for v in graph[u]:
              if not visited[v]:
                  dfs(v)
          order.append(u)  # 후위
      for i in range(n):
          if not visited[i]:
              dfs(i)
      return order[::-1]  # 역순

  방법 2: Kahn's Algorithm (BFS 기반)
  1. 진입 차수(in-degree) 0인 노드를 큐에
  2. 큐에서 꺼내 결과에 추가
  3. 이웃의 진입 차수 감소, 0이 되면 큐에
  4. 반복, 결과 크기 < V이면 사이클 존재
```

```
응용:
  ├─ 과목 선수과목 순서
  ├─ 빌드 시스템 의존성 (Make, Gradle)
  ├─ dp-08의 Airflow DAG 실행 순서
  └─ 스프레드시트 셀 계산 순서
```

## 5. 연결 요소

```
무방향 연결 요소:
  BFS/DFS로 미방문 노드에서 탐색 반복
  → 탐색 횟수 = 연결 요소 수
  또는 Union-Find (ads-06)로 O(Eα(V))

이분 그래프 판별:
  BFS로 인접 노드에 다른 색 배정
  인접 노드가 같은 색이면 → 이분 그래프 아님

  def is_bipartite(graph, n):
      color = [-1] * n
      for start in range(n):
          if color[start] != -1: continue
          queue = deque([start])
          color[start] = 0
          while queue:
              u = queue.popleft()
              for v in graph[u]:
                  if color[v] == -1:
                      color[v] = 1 - color[u]
                      queue.append(v)
                  elif color[v] == color[u]:
                      return False
      return True
```

> **핵심 직관**: 이분 그래프 판별은 "2-색 칠하기"와 동치입니다. 그래프가 이분이면 ga-05의 이분 매칭 알고리즘을 적용할 수 있으므로, 이분 판별은 매칭 문제의 첫 단계입니다.

## 6. 격자 그래프와 BFS 응용

```
격자 (Grid) 그래프:

  2D 격자에서 BFS = 최단 경로 (미로, 게임)

  dx = [0, 0, 1, -1]
  dy = [1, -1, 0, 0]

  def grid_bfs(grid, start, end):
      rows, cols = len(grid), len(grid[0])
      queue = deque([(start[0], start[1], 0)])
      visited = {start}
      while queue:
          x, y, dist = queue.popleft()
          if (x, y) == end:
              return dist
          for i in range(4):
              nx, ny = x + dx[i], y + dy[i]
              if 0 <= nx < rows and 0 <= ny < cols \
                 and (nx, ny) not in visited \
                 and grid[nx][ny] != '#':
                  visited.add((nx, ny))
                  queue.append((nx, ny, dist + 1))
      return -1

  0-1 BFS:
  간선 가중치가 0 또는 1일 때 → 덱(Deque) 사용
  가중치 0: 앞에 추가 (appendleft)
  가중치 1: 뒤에 추가 (append)
  → Dijkstra 없이 O(V+E)
```

BFS/DFS는 ga-02의 최단 경로, ga-06의 SCC, ga-07의 트리 알고리즘의 기반입니다.

## 핵심 정리

- **인접 리스트**가 대부분의 그래프 문제에서 표준 표현이며, $O(V+E)$ 공간으로 효율적입니다
- **BFS**는 레벨 순서 탐색으로 무가중 최단 경로를 보장하며, 격자/미로 문제의 핵심입니다
- **DFS**의 간선 분류(Back Edge = 사이클)가 사이클 탐지, 위상 정렬, SCC의 기반입니다
- **위상 정렬**은 DAG의 노드를 의존성 순서로 나열하며, DFS 후위 역순 또는 Kahn's Algorithm으로 구현합니다
- 최단 경로/최소 단계는 **BFS**, 연결성/사이클/재귀적 구조는 **DFS**가 기본 선택입니다
