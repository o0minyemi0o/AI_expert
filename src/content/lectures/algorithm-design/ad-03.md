# DP 고급 패턴

## 왜 고급 DP 패턴이 필요한가

ad-02의 기초 DP가 "상태를 인덱스나 용량으로 정의"했다면, 고급 DP는 **비트마스크, 구간, 트리, 최적화 기법**으로 더 복잡한 문제를 다룹니다. 외판원 문제(TSP)의 비트마스크 DP, 행렬 체인 곱셈의 구간 DP, ga-07의 트리 DP, 그리고 Knuth/CHT 같은 DP 점화식 자체의 최적화까지 포괄합니다.

> **핵심 직관**: 고급 DP의 핵심은 **"상태 공간의 창의적 설계"**입니다. 어떤 정보를 비트로 압축할지(비트마스크), 어떤 구간을 상태로 잡을지(구간 DP), 트리의 어떤 관점을 상태로 잡을지(트리 DP)가 문제 해결의 열쇠입니다.

## 1. 비트마스크 DP

```
비트마스크 DP: 집합을 정수로 표현

  N개 원소의 부분집합 → N비트 정수
  {0, 2, 3} → 1101₂ = 13

  비트 연산:
  ├─ i번째 원소 포함? mask & (1 << i)
  ├─ i번째 추가: mask | (1 << i)
  ├─ i번째 제거: mask & ~(1 << i)
  ├─ 부분집합 순회: sub = mask; while sub > 0: sub = (sub - 1) & mask
  └─ 원소 수: bin(mask).count('1')

  상태 공간: O(2^N × N) — N ≤ 20~25에서 실용적
```

```python
# TSP (외판원 문제) — 비트마스크 DP
def tsp(dist, n):
    """
    dist[i][j]: 도시 i→j 거리
    n: 도시 수 (n ≤ 20)
    """
    INF = float('inf')
    # dp[mask][i] = mask에 포함된 도시를 방문하고 i에 있을 때 최소 비용
    dp = [[INF] * n for _ in range(1 << n)]
    dp[1][0] = 0  # 시작: 도시 0만 방문, 위치 0

    for mask in range(1 << n):
        for u in range(n):
            if dp[mask][u] == INF:
                continue
            if not (mask & (1 << u)):
                continue
            for v in range(n):
                if mask & (1 << v):  # 이미 방문
                    continue
                new_mask = mask | (1 << v)
                dp[new_mask][v] = min(dp[new_mask][v],
                                     dp[mask][u] + dist[u][v])

    full = (1 << n) - 1
    return min(dp[full][i] + dist[i][0] for i in range(n))
```

```
비트마스크 DP 응용:

  ├─ TSP: O(2^N × N²) — 브루트포스 O(N!)보다 훨씬 빠름
  │   N=20: 2^20 × 400 ≈ 4억 (가능)
  │   N=15: 2^15 × 225 ≈ 7백만 (쉬움)
  ├─ 할당 문제: N명을 N개 작업에 배정 (ga-05 Hungarian 대안)
  ├─ 집합 커버: 최소 부분집합으로 전체 커버
  └─ 해밀턴 경로: 모든 노드 방문 경로 존재 여부
```

> **핵심 직관**: 비트마스크 DP는 **"어떤 원소를 선택했는가?"**라는 집합 상태를 정수 하나로 표현합니다. N!개의 순열을 2^N개의 집합 상태로 압축하여, TSP를 O(N!)에서 O(2^N × N²)로 개선합니다.

## 2. 구간 DP

```
구간 DP: dp[i][j] = 구간 [i, j]에 대한 최적값

  계산 순서: 구간 길이가 짧은 것부터!
  len=1 → len=2 → ... → len=n

  핵심: 구간을 어디서 나눌지 결정 (분할점 k)
  dp[i][j] = min/max over k in [i, j-1] of
             f(dp[i][k], dp[k+1][j])
```

```python
# 행렬 체인 곱셈 (Matrix Chain Multiplication)
def matrix_chain(dims):
    """
    dims = [d₀, d₁, ..., dₙ]
    행렬 i: dims[i] × dims[i+1]
    """
    n = len(dims) - 1
    dp = [[0] * n for _ in range(n)]

    for length in range(2, n + 1):       # 구간 길이
        for i in range(n - length + 1):   # 시작점
            j = i + length - 1            # 끝점
            dp[i][j] = float('inf')
            for k in range(i, j):         # 분할점
                cost = (dp[i][k] + dp[k+1][j] +
                       dims[i] * dims[k+1] * dims[j+1])
                dp[i][j] = min(dp[i][j], cost)
    return dp[0][n-1]

# 예: dims = [10, 30, 5, 60]
# (A₁×A₂)×A₃ = 10×30×5 + 10×5×60 = 1500+3000 = 4500
# A₁×(A₂×A₃) = 30×5×60 + 10×30×60 = 9000+18000 = 27000
# → 괄호 위치에 따라 6배 차이!
```

```
구간 DP 응용:

  ├─ 행렬 체인: O(N³) — 최적 곱셈 순서
  ├─ 최적 이진 탐색 트리: O(N³) — 빈도 기반 트리 구축
  ├─ 팔린드롬 분할: 최소 컷으로 팔린드롬 부분 문자열 분리
  ├─ 풍선 터뜨리기 (Burst Balloons): 순서 최적화
  └─ 석 합치기: 연속 돌무더기 합치기 최소 비용

  공통 패턴:
  1. 구간 [i, j]를 상태로 정의
  2. 분할점 k를 모두 시도
  3. 짧은 구간부터 계산
  4. O(N³) — N ≤ 500에서 실용적
```

## 3. 트리 DP

```
트리 DP: ga-07에서 다룬 트리 DP의 고급 패턴

  기본: DFS 후위 순서로 자식 → 부모 방향 계산

  패턴 1: 선택/비선택 (트리 독립 집합)
  dp[v][0] = v 미선택 시 서브트리 최대
  dp[v][1] = v 선택 시 서브트리 최대
  dp[v][0] = Σ max(dp[c][0], dp[c][1])
  dp[v][1] = val[v] + Σ dp[c][0]

  패턴 2: 트리 배낭 (Tree Knapsack)
  dp[v][k] = v를 루트로 한 서브트리에서 k개 선택 최대 가치
  → 자식 병합 시 O(k²) → 전체 O(NK)

  패턴 3: Rerooting (전방향 DP)
  "모든 노드를 루트로 한 답"을 O(N)에 계산
  1차 DFS: 루트 기준 dp 계산
  2차 DFS: 부모의 "다른 자식 기여분"을 전파
```

```python
# Rerooting 예: 각 노드에서 가장 먼 노드까지의 거리
def rerooting(graph, n):
    # 1차 DFS: 아래 방향 최대 깊이
    down = [0] * n   # 서브트리 내 최대 깊이
    down2 = [0] * n  # 서브트리 내 두 번째 최대 깊이

    def dfs1(u, parent):
        for v in graph[u]:
            if v == parent:
                continue
            dfs1(v, u)
            d = down[v] + 1
            if d >= down[u]:
                down2[u] = down[u]
                down[u] = d
            elif d > down2[u]:
                down2[u] = d

    # 2차 DFS: 위 방향 포함한 최대 거리
    up = [0] * n  # 부모 방향 최대 깊이

    def dfs2(u, parent):
        for v in graph[u]:
            if v == parent:
                continue
            # v가 u의 최대 자식이면 두 번째 사용
            if down[v] + 1 == down[u]:
                up[v] = max(up[u], down2[u]) + 1
            else:
                up[v] = max(up[u], down[u]) + 1
            dfs2(v, u)

    dfs1(0, -1)
    dfs2(0, -1)
    return [max(down[i], up[i]) for i in range(n)]
```

## 4. DP 최적화 기법

```
Knuth 최적화:

  구간 DP에서 dp[i][j] = min_{k} (dp[i][k] + dp[k+1][j] + C[i][j])
  C가 사각 부등식(Quadrangle Inequality) 만족 시:

  opt[i][j-1] ≤ opt[i][j] ≤ opt[i+1][j]

  (opt = 최적 분할점)
  → 분할점 탐색 범위 제한 → O(N³) → O(N²)

  적용 예:
  ├─ 최적 이진 탐색 트리
  └─ 석 합치기 (구간 합이 비용)

Divide and Conquer 최적화:

  dp[i][j] = min_{k<j} (dp[i-1][k] + C[k][j])
  opt[i][j] ≤ opt[i][j+1] (단조성) 만족 시:

  각 i 레이어를 분할 정복으로 계산
  O(KN²) → O(KN log N)

Convex Hull Trick (CHT):

  dp[j] = min_{i<j} (dp[i] + a[i]·x[j] + b[i])
  → 직선들의 최소 엔벨로프 (하부 볼록 껍질)
  → O(N²) → O(N log N) 또는 O(N)

  Li Chao Tree로 온라인 쿼리 O(log N)
```

> **핵심 직관**: DP 최적화의 공통 핵심은 **"최적 분할점의 단조성"**입니다. 분할점이 왼쪽에서 오른쪽으로만 이동한다면, 전체 탐색 대신 이전 최적점 근처만 살펴보면 됩니다. 이 관찰로 O(N³) → O(N²), O(KN²) → O(KN log N) 개선이 가능합니다.

## 5. 상태 압축과 프로파일 DP

```
프로파일 DP (Broken Profile DP):

  격자에서 타일링/배치 문제
  → 한 행/열의 상태를 비트마스크로 압축

  예: 2×N 격자를 1×2 도미노로 채우기
  상태: 현재 열의 채움 상태 (2비트)
  00: 두 칸 비어있음
  01: 아래만 채워짐
  10: 위만 채워짐
  11: 두 칸 채워짐

  전이: 현재 열의 빈 칸을 가로/세로 도미노로 채우는 방법

  M×N 격자 (M 작음, N 큼):
  dp[j][mask] = j열까지 채우고, j열 상태가 mask일 때 경우의 수
  상태 수: O(N × 2^M)
  → M ≤ 20 정도에서 실용적
```

## 6. DP 문제 분류와 판별

```
DP 유형 판별 가이드:

  "최소/최대/경우의 수"가 보이면 → DP 의심
  "모든 경우를 시도"해야 하면 → DP or 백트래킹

  유형별 상태 설계:
  ├─ 선형: dp[i] — 인덱스 i까지의 최적
  ├─ 그리드: dp[i][j] — 좌표 (i,j)까지의 최적
  ├─ 문자열 쌍: dp[i][j] — s1[0..i], s2[0..j]
  ├─ 배낭: dp[i][w] — i번째 아이템, 용량 w
  ├─ 구간: dp[i][j] — 구간 [i,j]의 최적
  ├─ 비트마스크: dp[mask][i] — 방문 집합, 현재 위치
  ├─ 트리: dp[v][state] — 노드 v, 추가 상태
  └─ 프로파일: dp[col][mask] — 현재 열, 프로파일 상태

  시간 복잡도:
  상태 수 × 전이 비용

  공간 최적화:
  현재 레이어가 이전 레이어만 참조 → 롤링 배열
```

DP 고급 패턴은 ad-01의 분할 정복에서 중복 문제가 생기면 적용되며, ga-07의 트리 DP와 ad-05의 백트래킹 + 메모이제이션과 연결됩니다.

## 핵심 정리

- **비트마스크 DP**는 집합 상태를 정수로 압축하여, TSP를 $O(N!)$에서 $O(2^N \cdot N^2)$로 개선합니다 ($N \leq 20$)
- **구간 DP**는 $dp[i][j]$로 구간 $[i,j]$의 최적값을 구하며, 분할점 $k$를 시도하는 $O(N^3)$ 패턴입니다
- **트리 DP**는 자식→부모 후위 순서로 계산하며, **Rerooting**으로 모든 노드 기준 답을 $O(N)$에 구합니다
- **Knuth 최적화**는 사각 부등식 조건에서 구간 DP를 $O(N^2)$로, **CHT**는 선형 전이를 $O(N \log N)$으로 개선합니다
- DP 문제의 핵심은 **상태 정의**이며, 유형(선형/그리드/구간/비트마스크/트리)을 빠르게 판별하는 것이 실력입니다
