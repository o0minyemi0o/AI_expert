# 백트래킹과 분기 한정

## 왜 백트래킹이 중요한가

그리디(ad-04)가 한 방향만 탐색하고, DP(ad-02)가 모든 부분 문제를 채운다면, **백트래킹(Backtracking)**은 "가능한 모든 경우를 체계적으로 탐색하되, 불필요한 가지는 잘라낸다"는 전략입니다. N-Queens, 스도쿠, 조합 생성 등 **제약 만족 문제(CSP)**의 핵심 기법이며, **분기 한정(Branch and Bound)**으로 확장하면 최적화 문제도 다룰 수 있습니다.

> **핵심 직관**: 백트래킹의 핵심은 **"가지치기(Pruning)"**입니다. 상태 공간 트리를 DFS로 탐색하면서, 현재 경로가 해를 만들 수 없다고 판단되면 즉시 되돌아갑니다. 좋은 가지치기가 지수 시간을 현실적 시간으로 줄여줍니다.

## 1. 상태 공간 트리

```
상태 공간 트리 (State Space Tree):

  각 레벨: 하나의 결정 (Decision)
  각 가지: 가능한 선택지 (Choice)
  리프: 완성된 후보 해 (Candidate Solution)

  예: {1,2,3}의 순열 생성
  Level 0:          [ ]
                  /  |  \
  Level 1:     [1]  [2]  [3]
              / \   / \   / \
  Level 2: [1,2][1,3][2,1][2,3][3,1][3,2]
             |    |    |    |    |    |
  Level 3: [123][132][213][231][312][321]

  가지치기 없이: 모든 리프 탐색 = O(N!)
  가지치기: 제약 위반 시 즉시 백트래킹

  백트래킹 = DFS + 가지치기
  핵심: "어떤 조건에서 가지를 자를 것인가?"
```

## 2. N-Queens 문제

```python
def n_queens(n):
    """N×N 체스판에 N개의 퀸을 공격 안 받게 배치"""
    solutions = []
    cols = set()       # 사용된 열
    diag1 = set()      # 주대각선 (row - col)
    diag2 = set()      # 부대각선 (row + col)

    def backtrack(row, queens):
        if row == n:
            solutions.append(queens[:])
            return
        for col in range(n):
            if col in cols or (row-col) in diag1 or (row+col) in diag2:
                continue  # 가지치기!
            # 선택
            queens.append(col)
            cols.add(col)
            diag1.add(row - col)
            diag2.add(row + col)
            # 재귀
            backtrack(row + 1, queens)
            # 되돌리기 (Undo)
            queens.pop()
            cols.remove(col)
            diag1.remove(row - col)
            diag2.remove(row + col)

    backtrack(0, [])
    return solutions
```

```
N-Queens 분석:

  N=8: 92개 해, 브루트포스 8^8 = 1600만 → 백트래킹 ~15000 노드
  N=12: ~14200 해, 탐색 노드 수 크게 감소 (가지치기 효과)

  가지치기의 핵심:
  1. 같은 열 배제: O(1) 체크 (set)
  2. 같은 대각선 배제: O(1) 체크 (row±col)
  → 각 레벨에서 평균적으로 선택지가 급격히 줄어듦

  백트래킹 패턴:
  def backtrack(state):
      if is_solution(state):
          record(state)
          return
      for choice in candidates(state):
          if is_valid(choice):    # 가지치기
              make_choice(choice)
              backtrack(next_state)
              undo_choice(choice)  # 되돌리기
```

> **핵심 직관**: 백트래킹의 **"선택(Choose) → 탐색(Explore) → 되돌리기(Undo)"** 3단계가 핵심입니다. "되돌리기"가 상태를 원래대로 복원하므로, 다른 가지에서 깨끗한 상태로 탐색할 수 있습니다. 이 패턴을 정확히 구현하면 대부분의 백트래킹 문제를 풀 수 있습니다.

## 3. 조합론적 생성

```python
# 부분집합 생성
def subsets(nums):
    result = []
    def backtrack(start, current):
        result.append(current[:])
        for i in range(start, len(nums)):
            current.append(nums[i])
            backtrack(i + 1, current)
            current.pop()
    backtrack(0, [])
    return result

# 조합 (N개에서 K개 선택)
def combinations(nums, k):
    result = []
    def backtrack(start, current):
        if len(current) == k:
            result.append(current[:])
            return
        # 가지치기: 남은 원소가 부족하면 중단
        remaining = len(nums) - start
        needed = k - len(current)
        if remaining < needed:
            return
        for i in range(start, len(nums)):
            current.append(nums[i])
            backtrack(i + 1, current)
            current.pop()
    backtrack(0, [])
    return result

# 순열
def permutations(nums):
    result = []
    used = [False] * len(nums)
    def backtrack(current):
        if len(current) == len(nums):
            result.append(current[:])
            return
        for i in range(len(nums)):
            if used[i]:
                continue
            # 중복 순열 방지: 같은 값이면 이전 것이 사용 중일 때만
            if i > 0 and nums[i] == nums[i-1] and not used[i-1]:
                continue
            used[i] = True
            current.append(nums[i])
            backtrack(current)
            current.pop()
            used[i] = False
    nums.sort()
    backtrack([])
    return result
```

```
생성 패턴 정리:

  부분집합: "포함/미포함" 선택 → 2^N개
  조합: "start부터 선택" → C(N,K)개
  순열: "미사용 원소 선택" → N!개

  중복 방지:
  ├─ 부분집합/조합: start 파라미터로 이전 원소 건너뜀
  ├─ 순열: used 배열 + 정렬 후 중복 스킵
  └─ 핵심: "같은 레벨에서 같은 값을 두 번 선택하지 않기"
```

## 4. 분기 한정 (Branch and Bound)

```
Branch and Bound: 백트래킹 + 한계값(Bound) 계산

  백트래킹: 불가능한 해를 가지치기
  B&B: 불가능 + "최적보다 나쁜" 해도 가지치기

  구성 요소:
  1. Branching: 상태 공간을 분기
  2. Bounding: 현재 노드의 하한(Lower Bound) 계산
  3. Pruning: 하한 ≥ 현재 최적 → 가지치기

  예: 0/1 배낭 문제

  정렬: 가치/무게 비율 순 (분수 배낭 해 = 하한)

  def knapsack_bnb(values, weights, capacity):
      n = len(values)
      best = [0]

      def bound(level, weight, value):
          """분수 배낭으로 상한 계산"""
          if weight > capacity:
              return 0
          ub = value
          w = weight
          for i in range(level, n):
              if w + weights[i] <= capacity:
                  w += weights[i]
                  ub += values[i]
              else:
                  ub += values[i] * (capacity - w) / weights[i]
                  break
          return ub

      def solve(level, weight, value):
          if weight > capacity:
              return
          best[0] = max(best[0], value)
          if level == n:
              return
          if bound(level, weight, value) <= best[0]:
              return  # 가지치기!
          # 포함
          solve(level+1, weight+weights[level], value+values[level])
          # 미포함
          solve(level+1, weight, value)

      solve(0, 0, 0)
      return best[0]
```

```
B&B의 핵심 요소:

  상한 (Upper Bound for 최대화):
  현재 노드에서 얻을 수 있는 최대 가능 값
  → 이 값이 현재 최적보다 작으면 가지치기

  하한 (Lower Bound for 최소화):
  현재 노드에서 최소 비용
  → 이 값이 현재 최적보다 크면 가지치기

  좋은 Bound의 조건:
  1. 계산이 빠를 것 (O(N) 이하)
  2. 실제 최적값에 가까울 것 (Tight Bound)
  → 느슨한 Bound = 가지치기 효과 없음

  TSP의 B&B:
  하한 = MST 비용 (ga-03)
  → MST ≤ 최적 TSP ≤ 2×MST (ad-07)
  → 꽤 좋은 하한!
```

> **핵심 직관**: B&B의 핵심은 **"완화된 문제(Relaxation)의 해가 한계값"**이라는 점입니다. 0/1 배낭의 분수 완화, TSP의 MST 완화처럼, 제약을 느슨하게 한 문제의 최적값이 원래 문제의 한계가 됩니다. 이 아이디어는 ad-07의 근사 알고리즘과 co-15의 LP 완화에서도 핵심입니다.

## 5. 실전 최적화 기법

```
백트래킹 가속화:

  1. 변수 순서 (Variable Ordering):
     가장 제약이 많은 변수를 먼저 선택
     → 일찍 가지치기 가능
     스도쿠: 후보가 가장 적은 셀 먼저

  2. 값 순서 (Value Ordering):
     가장 유망한 값을 먼저 시도
     → 최적해를 빨리 발견 → B&B에서 더 빠른 가지치기

  3. 제약 전파 (Constraint Propagation):
     선택 후 영향받는 다른 변수의 도메인 축소
     스도쿠: 한 셀에 값 넣으면 행/열/박스에서 후보 제거
     → Arc Consistency (AC-3)

  4. 대칭 제거 (Symmetry Breaking):
     대칭적 해를 한 번만 탐색
     N-Queens: 첫 행의 절반만 탐색 (좌우 대칭)

  5. 메모이제이션 결합:
     백트래킹 + 캐싱 = 상향식 DP와 동일한 효과
     상태가 같으면 결과 재사용
```

## 6. 문제 유형별 선택

```
문제 유형에 따른 접근법 선택:

  ├─ 모든 해 열거: 백트래킹 (부분집합, 순열, N-Queens)
  ├─ 최적해 탐색: B&B (배낭, TSP)
  ├─ 제약 만족: 백트래킹 + 제약 전파 (스도쿠, 그래프 색칠)
  └─ 결정 문제: 백트래킹 (해 존재 여부)

  시간 복잡도 기대:
  가지치기 없이: O(b^d) (분기수^깊이)
  좋은 가지치기: 문제에 따라 극적으로 감소
  → 최악은 여전히 지수적, 평균은 실용적

  백트래킹 vs DP:
  상태 공간이 너무 크면 (N! 등) → 백트래킹
  부분 문제 중복이 많으면 → DP
  둘 다 해당 → 메모이제이션 백트래킹
```

백트래킹은 ad-02의 DP와 보완 관계이며, B&B는 ad-07의 근사 알고리즘과 ad-10의 NP-완전 문제에서 정확한 해법으로 사용됩니다.

## 핵심 정리

- **백트래킹**은 상태 공간 트리를 DFS로 탐색하며, **"선택 → 탐색 → 되돌리기"** 패턴으로 제약 만족 문제를 해결합니다
- **가지치기**가 백트래킹의 성능을 결정하며, 유효성 검사를 빠르게 수행하는 것이 핵심입니다 (N-Queens: set으로 O(1))
- **조합론적 생성**(부분집합, 조합, 순열)은 start 파라미터와 used 배열로 중복을 방지합니다
- **분기 한정(B&B)**은 완화된 문제의 해를 한계값으로 사용하여, "최적보다 나쁜 가지"도 가지치기합니다
- 변수/값 순서, 제약 전파, 대칭 제거 등의 **최적화 기법**이 지수적 탐색을 실용적 시간으로 줄여줍니다
