# DP 기초 패턴

## 왜 DP가 중요한가

**동적 프로그래밍(Dynamic Programming)**은 "중복되는 부분 문제를 한 번만 풀겠다"는 아이디어입니다. ad-01의 분할 정복이 독립적 부분 문제를 다룬다면, DP는 **겹치는 부분 문제(Overlapping Subproblems)**를 다룹니다. 피보나치부터 최장 공통 부분 수열까지, 코딩 면접의 40% 이상이 DP입니다. 패턴을 인식하면 대부분의 DP 문제를 체계적으로 풀 수 있습니다.

> **핵심 직관**: DP의 두 가지 필수 조건은 **최적 부분 구조(Optimal Substructure)**와 **중복 부분 문제(Overlapping Subproblems)**입니다. 최적 해가 부분 문제의 최적 해로 구성되고, 같은 부분 문제가 여러 번 등장할 때 DP가 적합합니다.

## 1. DP의 두 가지 접근법

```
Top-Down (메모이제이션):
  재귀 + 결과 캐싱
  "필요할 때 계산"

  def fib_memo(n, memo={}):
      if n <= 1: return n
      if n in memo: return memo[n]
      memo[n] = fib_memo(n-1) + fib_memo(n-2)
      return memo[n]

Bottom-Up (타뷸레이션):
  작은 문제부터 순서대로 계산
  "미리 다 계산"

  def fib_tab(n):
      if n <= 1: return n
      dp = [0] * (n + 1)
      dp[1] = 1
      for i in range(2, n + 1):
          dp[i] = dp[i-1] + dp[i-2]
      return dp[n]

비교:
  Top-Down: 직관적, 필요한 부분만 계산, 스택 오버플로우 위험
  Bottom-Up: 반복문, 모든 부분 문제 계산, 공간 최적화 용이

피보나치 공간 최적화:
  def fib_opt(n):
      a, b = 0, 1
      for _ in range(2, n + 1):
          a, b = b, a + b
      return b
  → O(1) 공간! (직전 2개만 필요)
```

## 2. DP 문제 풀이 프레임워크

```
DP 설계 5단계:

  1. 상태 정의: dp[i]가 무엇을 의미하는가?
  2. 점화식: dp[i]를 이전 상태로 어떻게 표현하는가?
  3. 기저 조건: 가장 작은 문제의 답은?
  4. 계산 순서: 어떤 순서로 채워야 하는가?
  5. 최종 답: dp의 어느 위치가 답인가?

  예: 계단 오르기 (한 번에 1 or 2칸)
  1. dp[i] = i번째 계단에 도달하는 방법 수
  2. dp[i] = dp[i-1] + dp[i-2]
  3. dp[0] = 1, dp[1] = 1
  4. i = 2, 3, ..., n
  5. dp[n]

  예: 동전 교환 (coins로 amount 만들기, 최소 동전 수)
  1. dp[j] = 금액 j를 만드는 최소 동전 수
  2. dp[j] = min(dp[j-c] + 1) for c in coins, if j-c ≥ 0
  3. dp[0] = 0, dp[j] = inf (j > 0)
  4. j = 1, 2, ..., amount
  5. dp[amount]
```

> **핵심 직관**: DP 설계의 80%는 **"상태 정의"**에 달려 있습니다. 상태가 결정되면 점화식은 거의 자동으로 따라옵니다. "이 시점에서 의사결정에 필요한 최소한의 정보가 무엇인가?"가 상태를 결정하는 핵심 질문입니다.

## 3. 1D DP 패턴

```python
# 패턴 1: 최장 증가 부분 수열 (LIS)
def lis(nums):
    n = len(nums)
    dp = [1] * n  # dp[i] = nums[i]로 끝나는 LIS 길이
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
# O(N²), 이진 탐색 최적화 → O(N log N)

# 패턴 2: 최대 부분 배열 합 (Kadane's Algorithm)
def max_subarray(nums):
    dp = nums[0]  # 현재 위치에서 끝나는 최대 합
    result = dp
    for i in range(1, len(nums)):
        dp = max(nums[i], dp + nums[i])
        result = max(result, dp)
    return result
# O(N), 공간 O(1)

# 패턴 3: House Robber (인접 불가)
def rob(nums):
    # dp[i] = i번째까지 고려했을 때 최대 이익
    # dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    prev2, prev1 = 0, 0
    for num in nums:
        prev2, prev1 = prev1, max(prev1, prev2 + num)
    return prev1
```

```
1D DP 핵심 패턴:

  선형 스캔:
  ├─ dp[i] = f(dp[i-1], dp[i-2], ...) — 고정 범위 참조
  │   예: 피보나치, 계단, House Robber
  └─ dp[i] = f(dp[j] for all j < i) — 전체 스캔
      예: LIS, 점프 게임

  상태 축소:
  dp[i]가 dp[i-1], dp[i-2]만 참조 → O(1) 공간
  dp[i]가 dp[0..i-1] 전체 참조 → O(N) 필수

  결정 문제 (True/False):
  dp[i] = any(dp[j] and condition(j, i)) for j < i
  예: Word Break, 점프 게임
```

## 4. 2D DP 패턴

```python
# 패턴 1: 최장 공통 부분 수열 (LCS)
def lcs(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[m][n]
# O(MN) 시간, O(MN) 공간 → O(N) 공간 가능 (행 하나만 유지)

# 패턴 2: 0/1 배낭 (Knapsack)
def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [0] * (capacity + 1)
    for i in range(n):
        for w in range(capacity, weights[i] - 1, -1):  # 역순!
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    return dp[capacity]
# O(N×W) — 의사 다항 시간 (W가 입력 크기에 비례하지 않음)

# 패턴 3: 편집 거리 (Edit Distance)
def edit_distance(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j],      # 삭제
                                   dp[i][j-1],      # 삽입
                                   dp[i-1][j-1])    # 교체
    return dp[m][n]
```

```
2D DP 핵심 패턴:

  두 시퀀스 비교:
  ├─ dp[i][j] = s1[0..i]와 s2[0..j]에 대한 최적값
  ├─ LCS, 편집 거리, 문자열 인터리빙
  └─ 전이: dp[i-1][j-1], dp[i-1][j], dp[i][j-1]

  선택/비선택:
  ├─ dp[i][j] = i번째 아이템까지, 용량 j에서의 최적값
  ├─ 0/1 배낭, 부분집합 합
  └─ 전이: dp[i-1][j] (비선택), dp[i-1][j-w] + v (선택)

  격자 경로:
  ├─ dp[i][j] = (0,0)에서 (i,j)까지의 경로 수/최소 비용
  ├─ 전이: dp[i-1][j], dp[i][j-1]
  └─ 장애물 있으면: dp[i][j] = 0
```

> **핵심 직관**: 2D DP에서 **공간 최적화**의 핵심은 "현재 행이 이전 행만 참조하면 O(N) 공간"입니다. 배낭 문제에서 역순 순회가 필요한 이유는, 같은 아이템을 두 번 사용하지 않기 위해서입니다(순서대로면 무한 배낭이 됩니다).

## 5. 경로 복원

```
DP에서 최적값만이 아닌 최적 경로도 필요할 때:

  방법 1: 역추적 (Backtracking)
  dp 테이블에서 역으로 선택 추적

  def lcs_with_path(s1, s2):
      m, n = len(s1), len(s2)
      dp = [[0]*(n+1) for _ in range(m+1)]
      for i in range(1, m+1):
          for j in range(1, n+1):
              if s1[i-1] == s2[j-1]:
                  dp[i][j] = dp[i-1][j-1] + 1
              else:
                  dp[i][j] = max(dp[i-1][j], dp[i][j-1])
      # 역추적
      result = []
      i, j = m, n
      while i > 0 and j > 0:
          if s1[i-1] == s2[j-1]:
              result.append(s1[i-1])
              i -= 1; j -= 1
          elif dp[i-1][j] > dp[i][j-1]:
              i -= 1
          else:
              j -= 1
      return ''.join(reversed(result))

  방법 2: 선택 기록 배열
  choice[i][j] = 어떤 전이를 선택했는지 저장
  → 메모리 추가 O(MN)이지만 역추적 간단
```

## 6. DP 함정과 팁

```
흔한 실수와 팁:

  1. 상태 부족:
     "현재 위치"만으로 부족 → "현재 위치 + 이전 선택" 필요
     예: 주식 문제에서 "보유 여부"가 상태에 포함

  2. 기저 조건 오류:
     dp[0] = 0? 1? inf?
     "빈 집합/빈 문자열에서의 답"을 신중하게 결정

  3. 순서 오류:
     Bottom-Up에서 dp[i]가 참조하는 dp[j]가
     아직 계산되지 않았으면 오답!
     → 의존성 방향 확인

  4. 오버플로우:
     경우의 수 문제: MOD = 10⁹ + 7 사용
     최적화 문제: float('inf') 초기화

  면접 팁:
  ├─ 1단계: 재귀로 정확한 해 구현
  ├─ 2단계: 메모이제이션 추가
  ├─ 3단계: Bottom-Up 변환
  └─ 4단계: 공간 최적화
  이 순서로 설명하면 사고 과정이 명확히 드러남
```

DP 기초는 ad-03의 고급 패턴(비트마스크, 구간, 트리 DP)으로 확장되며, ad-04의 그리디와 "DP vs 그리디" 판단 기준에서 비교됩니다.

## 핵심 정리

- DP의 핵심 조건은 **최적 부분 구조**와 **중복 부분 문제**이며, Top-Down(메모이제이션)과 Bottom-Up(타뷸레이션) 두 접근법이 있습니다
- DP 설계의 80%는 **상태 정의**에 달려 있으며, "의사결정에 필요한 최소 정보"가 상태를 결정합니다
- **1D DP**는 선형 스캔(피보나치, LIS, Kadane)이 기본이며, 참조 범위가 고정이면 O(1) 공간으로 축소 가능합니다
- **2D DP**의 대표 패턴은 두 시퀀스 비교(LCS, 편집 거리)와 선택/비선택(배낭)이며, 행 단위 참조면 O(N) 공간으로 축소합니다
- 면접에서는 **재귀 → 메모이제이션 → Bottom-Up → 공간 최적화** 순서로 발전시키면 사고 과정이 명확히 전달됩니다
