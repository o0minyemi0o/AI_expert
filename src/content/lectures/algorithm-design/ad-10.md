# 복잡도 이론

## 왜 복잡도 이론이 중요한가

"이 문제에 다항 시간 알고리즘이 존재하는가?" 이 질문에 답하는 것이 **복잡도 이론(Complexity Theory)**입니다. 어떤 문제가 NP-완전임을 증명하면, "다항 시간 정확해를 포기하고 근사(ad-07)나 휴리스틱(ad-05)을 써야 한다"는 전략적 판단이 가능합니다. P vs NP 문제는 컴퓨터 과학의 가장 중요한 미해결 문제이며, 이를 이해하는 것은 알고리즘 설계의 근본입니다.

> **핵심 직관**: 복잡도 이론의 핵심 아이디어는 **"환원(Reduction)"**입니다. "문제 A를 풀 수 있으면 문제 B도 풀 수 있다"를 보이면, B가 어렵다면 A도 어렵습니다. 이 논리 체인이 수백 개의 NP-완전 문제를 연결합니다.

## 1. P, NP, NP-완전

```
결정 문제 (Decision Problem):
  답이 YES 또는 NO인 문제
  예: "이 그래프에 크기 k인 클리크가 있는가?"

P (Polynomial Time):
  다항 시간에 "풀 수 있는" 문제
  예: 정렬, 최단 경로, MST, 2-SAT

NP (Nondeterministic Polynomial Time):
  다항 시간에 "검증할 수 있는" 문제
  YES 인스턴스에 대해 "증거(certificate)"를 주면
  다항 시간에 맞는지 확인 가능

  예: 해밀턴 경로
  검증: 경로를 주면 O(N)에 모든 노드 방문 확인
  풀기: 알려진 다항 시간 알고리즘 없음

  핵심:
  P ⊆ NP (풀 수 있으면 당연히 검증도 가능)
  P = NP? → 미해결! (대부분 P ≠ NP로 추정)
```

```
NP-완전 (NP-Complete):
  NP에서 가장 어려운 문제들의 집합

  정의: 문제 L이 NP-완전 ⟺
  1. L ∈ NP (다항 시간 검증 가능)
  2. 모든 NP 문제가 L로 다항 시간 환원 가능

  의미: NP-완전 문제 하나라도 다항 시간에 풀리면
       → 모든 NP 문제가 다항 시간에 풀림
       → P = NP

NP-난해 (NP-Hard):
  NP의 모든 문제가 환원되지만, 자신은 NP에 있을 필요 없음
  (결정 문제가 아닐 수도 있음)
  예: TSP 최적화 버전 (결정: "비용 ≤ k인 투어 존재?"는 NP-완전)

  관계:
  ┌────────────────────────┐
  │      NP-Hard           │
  │  ┌──────────────────┐  │
  │  │   NP-Complete     │  │
  │  │  ┌──────────────┐│  │
  │  │  │    NP        ││  │
  │  │  │  ┌────────┐  ││  │
  │  │  │  │  P     │  ││  │
  │  │  │  └────────┘  ││  │
  │  │  └──────────────┘│  │
  │  └──────────────────┘  │
  └────────────────────────┘
  (P ≠ NP 가정 시)
```

## 2. 다항 시간 환원

```
다항 시간 환원 (Polynomial-Time Reduction):

  A ≤_p B: "A가 B로 환원된다"

  A의 인스턴스 x를 다항 시간에 B의 인스턴스 f(x)로 변환
  x ∈ A ⟺ f(x) ∈ B

  의미: B를 풀 수 있으면 A도 풀 수 있다
  대우: A가 어려우면 B도 어렵다

  NP-완전 증명 절차:
  1. L ∈ NP임을 보인다 (증거 + 다항 시간 검증)
  2. 알려진 NP-완전 문제 L'에서 L로 환원
     L' ≤_p L

  환원의 방향 주의!
  "알려진 어려운 문제 → 새 문제"로 환원
  새 문제가 어려움을 보이는 것!

  잘못된 방향:
  "새 문제 → 알려진 어려운 문제"는
  새 문제가 쉬울 수도 있음을 보여줄 뿐
```

> **핵심 직관**: 환원은 **"어려운 문제를 새 문제의 특수 케이스로 만드는 것"**입니다. SAT를 3-SAT로 변환할 수 있다면, SAT가 어렵다는 것이 3-SAT도 어렵다는 것을 보입니다. 환원의 방향을 헷갈리면 안 됩니다—항상 "알려진 NP-완전 → 새 문제"입니다.

## 3. Cook-Levin 정리

```
Cook-Levin 정리 (1971):

  SAT (Boolean Satisfiability)는 NP-완전

  SAT: 불리언 수식 φ(x₁, ..., xₙ)을 참으로 만드는
       변수 할당이 존재하는가?

  증명 직관:
  1. SAT ∈ NP: 변수 할당이 주어지면 O(|φ|)에 검증
  2. 모든 NP 문제 → SAT: 비결정적 튜링 머신의 계산을
     불리언 수식으로 인코딩
     - 시간 t, 위치 p, 상태 s를 변수로
     - 전이 규칙을 절(clause)로
     → 다항 크기의 수식

  이것이 최초의 NP-완전 문제!
  이후 SAT에서 다른 문제로 환원하여 NP-완전성 증명

  환원 체인:
  SAT → 3-SAT → Clique → Vertex Cover → ...
  각 화살표가 다항 시간 환원
```

## 4. 주요 NP-완전 문제와 환원 체인

```
환원 체인 (일부):

  SAT
  ├→ 3-SAT (절 크기 제한)
  │  ├→ Independent Set (독립 집합)
  │  │  └→ Vertex Cover (여집합)
  │  │     └→ Set Cover
  │  ├→ 3-Coloring (그래프 3-색 칠하기)
  │  ├→ Clique (완전 부분 그래프)
  │  └→ Hamiltonian Cycle
  │     └→ TSP (결정 버전)
  ├→ Subset Sum (부분집합 합)
  │  └→ Partition
  │     └→ 0/1 Knapsack (결정)
  └→ Integer Programming

  3-SAT → Independent Set 환원 예:
  각 절의 리터럴 → 노드 3개
  같은 절 내 노드끼리 → 간선 (최대 1개 선택)
  모순 리터럴 쌍 (xᵢ, ¬xᵢ) → 간선
  크기 m의 독립 집합 존재 ⟺ m개 절 모두 만족 가능
```

```
"P 인가 NP-완전인가" 판별:

  유사하지만 복잡도가 다른 문제들:

  P:                    NP-완전:
  2-SAT (ga-06)        3-SAT
  2-Coloring           3-Coloring
  최단 경로 (ga-02)    최장 경로
  오일러 회로           해밀턴 회로
  최소 컷 (ga-04)      최대 컷
  매칭 (ga-05)         3D 매칭

  패턴: "2"에서 "3"으로, "최소"에서 "최대"로 바뀌면
  종종 P에서 NP-완전으로 점프!
```

## 5. NP-완전 문제 대처 전략

```
NP-완전 문제를 만났을 때:

  1. 근사 알고리즘 (ad-07):
     최적은 아니지만 보장된 비율
     정점 커버 2-근사, TSP 1.5-근사

  2. 특수 구조 활용:
     일반은 NP-hard이지만 특수한 경우 P
     ├─ 트리 위의 문제: 트리 DP (ga-07)
     ├─ 이분 그래프 매칭: 다항 시간 (ga-05)
     ├─ 평면 그래프: 일부 문제에서 PTAS
     └─ 고정 매개변수: FPT 알고리즘

  3. 휴리스틱/메타휴리스틱:
     보장은 없지만 실무에서 잘 작동
     유전 알고리즘, 시뮬레이티드 어닐링, 타부 서치

  4. 정확한 지수 시간 알고리즘:
     O(2^N)이지만 상수 개선
     TSP: O(N! → 2^N × N²) (ad-03 비트마스크 DP)

  5. 랜덤화 (ad-08):
     확률적으로 좋은 해 + 빠른 실행
```

> **핵심 직관**: NP-완전 증명은 **"포기의 정당화"**가 아니라 **"전략 전환의 근거"**입니다. "이 문제는 NP-완전이므로 정확한 다항 시간 해는 없지만, 근사/특수 구조/휴리스틱으로 실용적 해를 구할 수 있다"가 올바른 대응입니다.

## 6. P vs NP를 넘어서

```
복잡도 클래스 지도:

  P ⊆ NP ⊆ PSPACE ⊆ EXP
  (모두 ⊂인지 =인지 미해결!)

  co-NP: NO 인스턴스가 다항 시간에 검증 가능
  예: "이 수식은 항상 참인가?" (TAUT)
  NP ∩ co-NP: 소수 판별 (AKS 알고리즘으로 P에도)

  BPP: 양측 오류 확률적 다항 시간
  → BPP ⊆ P로 추정 (탈랜덤화 가설)

  #P: 해의 "개수"를 세는 문제
  예: SAT 만족 할당의 수 → NP보다 어려움

  실무적 의미:
  ├─ P ≠ NP: 정확한 효율적 해 불가 → 근사/휴리스틱
  ├─ NP-중간: P도 NP-완전도 아닌 문제 (그래프 동형 등)
  └─ 양자 컴퓨팅: BQP ⊇ P, NP와의 관계 미해결
      Shor의 알고리즘: 소인수분해를 다항 시간에 풀지만
      NP-완전 문제를 풀지는 못하는 것으로 추정
```

복잡도 이론은 ad-07의 근사 알고리즘의 존재 이유이며, ad-11에서 구체적 NP-완전 문제들의 환원 체인을 상세히 다룹니다. ga-06의 2-SAT(P)과 3-SAT(NP-완전)의 대비가 대표적 예입니다.

## 핵심 정리

- **P**는 다항 시간에 "풀 수 있는" 문제, **NP**는 다항 시간에 "검증할 수 있는" 문제이며, P = NP인지는 미해결입니다
- **NP-완전**은 NP에서 가장 어려운 문제로, 하나라도 다항 시간에 풀리면 P = NP가 됩니다
- **다항 시간 환원** $A \leq_p B$는 "A가 B로 변환 가능"을 의미하며, B가 어려우면 A도 어렵다는 것을 보입니다
- **Cook-Levin 정리**가 SAT의 NP-완전성을 증명한 후, SAT에서의 환원 체인으로 수백 개의 NP-완전 문제가 발견되었습니다
- NP-완전 문제는 **근사 알고리즘, 특수 구조 활용, 휴리스틱, 정확한 지수 알고리즘**으로 대처하며, "포기가 아닌 전략 전환"이 핵심입니다
