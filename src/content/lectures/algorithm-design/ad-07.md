# 근사 알고리즘

## 왜 근사 알고리즘이 중요한가

ad-10에서 다룰 NP-완전 문제는 다항 시간 정확해가 없다고 믿어집니다. 그렇다면 실무에서 어떻게 처리할까요? **근사 알고리즘(Approximation Algorithm)**은 "최적은 아니지만, 최적에서 얼마나 떨어져 있는지 보장할 수 있는" 다항 시간 알고리즘입니다. "2배 이내 보장", "1.5배 이내 보장" 같은 **근사비(Approximation Ratio)**가 핵심입니다.

> **핵심 직관**: 근사 알고리즘의 핵심 전략은 **"LP 완화(Relaxation)나 구조적 하한을 이용해 최적값을 추정하고, 그 추정값 대비 성능을 보장"**하는 것입니다. 최적값을 모르더라도, 하한을 통해 "내 해는 최적의 α배 이내"라고 증명할 수 있습니다.

## 1. 근사비 정의

```
근사비 (Approximation Ratio):

  최소화 문제: α = ALG(I) / OPT(I) ≥ 1
  최대화 문제: α = OPT(I) / ALG(I) ≥ 1

  α-근사: 모든 입력 I에 대해 비율이 α 이하

  예: 2-근사 = 최적의 2배 이내 보장
      (1+ε)-근사 = 최적의 (1+ε)배 이내 보장

  근사 체계:
  ├─ PTAS (Polynomial Time Approx. Scheme):
  │   ε > 0마다 (1+ε)-근사, 시간 = poly(n) × f(1/ε)
  │   ε 고정이면 다항 시간, ε→0이면 느려질 수 있음
  ├─ FPTAS (Fully PTAS):
  │   시간 = poly(n, 1/ε)
  │   ε에 대해서도 다항 시간!
  └─ APX: 상수 근사비는 있지만 PTAS 없음
```

## 2. 정점 커버 (Vertex Cover)

```
문제: 모든 간선의 적어도 한쪽 끝을 포함하는 최소 노드 집합
NP-완전 (ad-11)

2-근사 알고리즘: 극대 매칭(Maximal Matching) 기반

  def vertex_cover_2approx(graph):
      cover = set()
      edges = set(graph.edges())
      while edges:
          u, v = edges.pop()  # 아무 간선 선택
          cover.add(u)
          cover.add(v)
          # u 또는 v에 인접한 간선 모두 제거
          edges = {(a,b) for (a,b) in edges
                   if a != u and a != v and b != u and b != v}
      return cover

  시간: O(V + E)

  왜 2-근사?
  극대 매칭의 간선 수 = k
  알고리즘: 2k개 노드 선택
  최적 커버 ≥ k (매칭의 각 간선에서 최소 1개 필요)
  → ALG = 2k ≤ 2 × OPT

  König의 정리 (ga-05):
  이분 그래프에서는 최대 매칭 = 최소 커버
  → 이분 그래프에서는 정확한 해 가능!
```

> **핵심 직관**: 정점 커버 2-근사의 핵심 관찰은 **"매칭의 각 간선은 최소 한 끝점이 커버에 있어야 한다"**는 것입니다. 매칭 크기가 OPT의 하한이 되고, 양 끝점을 모두 넣어도 2배를 넘지 않습니다.

## 3. TSP 근사

```
메트릭 TSP (삼각 부등식 만족):

  d(a,c) ≤ d(a,b) + d(b,c)

  2-근사: MST 기반

  def tsp_2approx(dist, n):
      # 1. MST 구축 (ga-03)
      mst = prim(dist, n)
      # 2. MST를 DFS 순회 (각 간선 2번 통과)
      # 3. DFS 방문 순서 = 투어
      tour = dfs_preorder(mst)
      return tour

  왜 2-근사?
  MST 비용 ≤ OPT (TSP에서 간선 하나 제거 → 신장 트리)
  DFS 순회 = 2 × MST (각 간선 2번)
  삼각 부등식으로 지름길: 실제 투어 ≤ DFS 순회
  → ALG ≤ 2 × MST ≤ 2 × OPT

  1.5-근사: Christofides 알고리즘

  1. MST 구축
  2. MST에서 홀수 차수 노드에 최소 가중 완전 매칭
  3. MST + 매칭 = 오일러 회로
  4. 오일러 회로에서 지름길로 해밀턴 회로

  왜 1.5-근사?
  MST ≤ OPT
  최소 매칭 ≤ OPT/2 (홀수 차수 쌍의 최적 매칭)
  ALG ≤ MST + 매칭 ≤ OPT + OPT/2 = 1.5 × OPT
```

```
일반 TSP (삼각 부등식 없음):

  근사 불가능!
  정리: P ≠ NP이면, 일반 TSP의 α-근사 알고리즘은
  어떤 상수 α에 대해서도 존재하지 않음

  증명 직관: 해밀턴 경로 문제(NP-완전)를
  일반 TSP로 환원 가능
  → 근사가 가능하면 NP-완전 판별 가능 → 모순
```

## 4. Set Cover

```
문제: 전체 집합 U를 덮는 최소 개수의 부분집합 선택
NP-완전

그리디 근사:

  def set_cover_greedy(universe, subsets):
      covered = set()
      selected = []
      while covered != universe:
          # 가장 많은 미커버 원소를 덮는 집합 선택
          best = max(subsets, key=lambda s: len(s - covered))
          selected.append(best)
          covered |= best
      return selected

  근사비: O(ln n)

  정확히: H(n) = 1 + 1/2 + 1/3 + ... + 1/n ≈ ln n

  증명 직관:
  매 단계에서 미커버 원소의 1/OPT 이상을 덮음
  → OPT × ln(n) 단계면 모두 커버

  이것이 최선:
  P ≠ NP이면 (1-ε)ln(n)-근사도 불가능!
  → 그리디의 ln(n)이 (거의) 최적의 근사비
```

## 5. 배낭 문제 FPTAS

```
0/1 배낭의 FPTAS:

  핵심: 가치를 "반올림"하여 DP의 상태 수를 줄임

  def knapsack_fptas(values, weights, capacity, epsilon):
      n = len(values)
      v_max = max(values)
      K = epsilon * v_max / n  # 스케일링 팩터

      # 가치를 K로 나누어 반올림 (정수화)
      scaled_values = [int(v / K) for v in values]

      # 축소된 가치로 DP (최대 가치 ≤ n/ε)
      max_val = sum(scaled_values)
      # dp[v] = 가치 합 v를 달성하는 최소 무게
      dp = [float('inf')] * (max_val + 1)
      dp[0] = 0

      for i in range(n):
          for v in range(max_val, scaled_values[i] - 1, -1):
              dp[v] = min(dp[v], dp[v - scaled_values[i]] + weights[i])

      best = max(v for v in range(max_val + 1) if dp[v] <= capacity)
      return best * K  # 원래 스케일 복원

  시간: O(n² / ε) — n과 1/ε 모두에 다항!
  → FPTAS (Fully Polynomial Time Approximation Scheme)
```

```
FPTAS의 핵심 아이디어:

  원래 DP: O(n × V_total) — 가치 합이 크면 느림
  스케일링 후: 가치를 n/ε 이하로 축소 → O(n²/ε)

  반올림 오차: 각 아이템에서 최대 K = εv_max/n
  n개 아이템 → 총 오차 ≤ εv_max ≤ εOPT
  → (1-ε)OPT ≤ ALG ≤ OPT

  FPTAS가 가능한 이유: 배낭은 "약한 NP-hard"
  (W나 V가 작으면 의사 다항)
  강한 NP-hard 문제(TSP)에는 FPTAS 없음 (P≠NP 시)
```

> **핵심 직관**: FPTAS의 핵심은 **"정밀도와 속도의 교환"**입니다. 가치를 $\epsilon$만큼 반올림하면 정확도를 $(1-\epsilon)$배 포기하지만, 상태 수가 $1/\epsilon$에 비례하게 줄어 다항 시간이 됩니다.

## 6. 근사 알고리즘 지도

```
문제별 최고 알려진 근사비:

  문제         │ 근사비      │ 근사 불가능 하한
  ─────────────│────────────│──────────────
  정점 커버     │ 2          │ 2-ε (UGC 가정)
  메트릭 TSP   │ 1.5        │ 123/122 ≈ 1.008
  Set Cover    │ ln(n)      │ (1-ε)ln(n)
  0/1 배낭     │ FPTAS      │ — (FPTAS 존재)
  MAX-SAT      │ 3/4        │ 7/8+ε (ad-11)
  그래프 색칠   │ O(n^{0.2}) │ n^{1-ε} (P≠NP)

  근사 전략 도구 상자:
  ├─ 그리디: Set Cover, 스케줄링
  ├─ LP 완화 + 반올림: 정점 커버, MAX-SAT
  ├─ MST/구조적 하한: TSP, Steiner Tree
  ├─ 스케일링/반올림: 배낭 FPTAS
  └─ 랜덤화: MAX-SAT (ad-08)

  면접에서:
  "NP-hard이니 근사를 사용하겠습니다"라고 말한 후
  구체적 근사비와 간단한 정당성을 설명하면 높은 평가
```

근사 알고리즘은 ad-10의 복잡도 이론, ad-11의 NP-완전 문제와 직접 연결되며, ga-03의 MST(TSP 하한)와 ga-05의 König 정리(정점 커버)를 활용합니다.

## 핵심 정리

- **근사비** α는 "알고리즘 해 / 최적 해"의 최대값이며, NP-hard 문제에 대한 다항 시간 보장입니다
- **정점 커버 2-근사**는 극대 매칭의 양 끝점을 선택하며, 매칭 크기 ≤ OPT라는 하한에서 보장됩니다
- **메트릭 TSP**는 MST 기반 2-근사, Christofides의 1.5-근사가 있으며, 일반 TSP는 근사 자체가 불가능합니다
- **Set Cover**의 그리디 $O(\ln n)$-근사는 거의 최적이며, 이보다 나은 근사는 P≠NP 시 불가능합니다
- **배낭 FPTAS**는 가치 스케일링으로 $(1-\epsilon)$-근사를 $O(n^2/\epsilon)$에 달성하며, "정밀도와 속도의 교환"이 핵심입니다
