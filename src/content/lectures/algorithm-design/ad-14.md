# 알고리즘 설계 종합 연습

## 왜 종합 연습이 중요한가

ad-01~13에서 개별 패러다임을 배웠다면, 실전에서는 **"이 문제에 어떤 패러다임을 적용할 것인가?"**가 핵심입니다. 같은 문제도 분할 정복, DP, 그리디 등 여러 접근이 가능하며, 시간/공간 트레이드오프에 따라 최적 선택이 달라집니다. 이 강의에서는 패러다임 선택의 프레임워크와 복합 문제 풀이를 다룹니다.

> **핵심 직관**: 알고리즘 설계의 핵심 역량은 **"문제의 구조를 읽는 능력"**입니다. 최적 부분 구조가 보이면 DP/그리디, 독립적 분할이 가능하면 분할 정복, 조합 폭발이면 백트래킹+가지치기, NP-hard면 근사를 선택합니다. 이 판별이 자동화되면 대부분의 문제를 체계적으로 접근할 수 있습니다.

## 1. 패러다임 선택 프레임워크

```
문제를 만났을 때의 판별 흐름:

  1단계: 문제 유형 파악
  ├─ 탐색/순회 → 그래프 알고리즘 (ga-01~12)
  ├─ 정렬/선택 → 분할 정복 기반 (ad-01)
  ├─ 최적화 → 2단계로
  ├─ 패턴 매칭 → 문자열 알고리즘 (ad-06)
  └─ 결정 문제 → 이진 탐색 or NP-완전 검사 (ad-10)

  2단계: 최적화 문제의 패러다임 선택
  ├─ 그리디 선택 성질? → 그리디 (ad-04)
  │   (반례가 없고 교환 논증 성립)
  ├─ 최적 부분 구조 + 중복 부분 문제? → DP (ad-02, 03)
  ├─ 독립 부분 문제? → 분할 정복 (ad-01)
  ├─ 제약 만족 (모든 해 필요)? → 백트래킹 (ad-05)
  └─ NP-hard? → 근사 (ad-07) or 휴리스틱

  3단계: 세부 기법 선택
  DP → 1D? 2D? 비트마스크? 구간? (ad-03)
  그래프 → BFS? DFS? Dijkstra? 플로우? (ga-01~05)
  문자열 → KMP? Suffix Array? Aho-Corasick? (ad-06)
```

## 2. 복합 문제 풀이 1: 경로 최적화

```
문제: 격자에서 좌상단→우하단, 최대 k번 장애물 제거 가능

  접근 1: BFS + 상태 확장
  상태: (x, y, 남은 제거 횟수)
  → 0-1 BFS 또는 Dijkstra (ga-02 + ga-01)
  시간: O(MNK)

  접근 2: DP
  dp[x][y][r] = (x,y)까지 r번 제거하며 도달하는 최소 거리
  → 2D 격자 + 추가 차원 DP (ad-02)
  시간: O(MNK)

  접근 3 (K가 작을 때): 레이어 BFS
  각 제거 횟수를 별도 레이어로
  → 레이어 간 이동 = 제거 사용

  판별:
  최단 경로 → BFS/Dijkstra가 자연스러움
  상태에 "추가 정보(남은 횟수)" → 상태 확장
  두 접근 모두 같은 복잡도, BFS가 구현 간결
```

## 3. 복합 문제 풀이 2: 스케줄링 최적화

```
문제: N개 작업, 각 (처리시간, 마감, 이익), 1개 머신
      마감 내 완료한 작업의 이익 합 최대화

  분석:
  ├─ 그리디? 이익 순? 마감 순? → 반례 존재
  │   이익 큰 것 먼저 → 마감 놓칠 수 있음
  ├─ DP? 상태 = (작업 인덱스, 현재 시간)
  │   → O(N × max_deadline) — 의사 다항
  └─ 그리디 + 자료구조?
     이익 내림차순 정렬
     각 작업을 마감 직전 슬롯에 배치
     Union-Find(ads-06)로 빈 슬롯 빠르게 찾기
     → O(N log N)

  핵심: 그리디만으로는 부족하지만,
  정렬 + 적절한 자료구조로 최적해 달성 가능
  → "패러다임 조합"이 실전의 핵심
```

## 4. 시간/공간 트레이드오프

```
대표적 트레이드오프:

  1. 전처리 vs 쿼리:
     ├─ 전처리 없음: 매 쿼리 O(N)
     ├─ Prefix Sum: 전처리 O(N), 쿼리 O(1)
     ├─ 세그먼트 트리: 전처리 O(N), 쿼리 O(log N), 업데이트 O(log N)
     ├─ Sparse Table: 전처리 O(N log N), 쿼리 O(1), 업데이트 불가
     └─ 판단 기준: 쿼리 빈도, 업데이트 유무

  2. 시간 vs 공간:
     ├─ 해시 테이블: O(1) 시간, O(N) 공간
     ├─ 이진 탐색: O(log N) 시간, O(1) 추가 공간
     ├─ DP 테이블: O(NM) 시간+공간 → 롤링 O(N) 공간
     └─ 비트마스크 DP: O(2^N) 공간 — N≤20 필수

  3. 정확도 vs 속도:
     ├─ 정확 알고리즘: 최적해, 느릴 수 있음
     ├─ 근사 알고리즘: α-최적, 다항 시간 (ad-07)
     ├─ 확률적 자료구조: 오차 허용, O(1) (ads-04)
     └─ 휴리스틱: 보장 없지만 실무에서 빠름

  4. 온라인 vs 오프라인:
     ├─ 온라인: 즉시 결정, 경쟁비 α (ad-12)
     ├─ 오프라인: 전체 입력 후 결정, 최적 가능
     └─ 하이브리드: 배치 + 실시간 (dp-04 스트림)
```

> **핵심 직관**: 트레이드오프 판단의 핵심은 **"병목이 어디인가?"**입니다. 쿼리가 많으면 전처리 투자, 메모리가 부족하면 공간 절약, 실시간이면 온라인 알고리즘. 제약 조건이 최적 전략을 결정합니다.

## 5. 면접 문제 풀이 전략

```
면접에서의 알고리즘 설계 흐름:

  1. 문제 이해 (2-3분):
     입력/출력 명확히, 제약 조건 확인
     예시로 이해도 검증
     "이 문제는 ___를 최소화/최대화하는 것이군요"

  2. 브루트포스 (1-2분):
     가장 간단한 해법 제시 (시간 복잡도 언급)
     "모든 부분집합을 시도하면 O(2^N)입니다"

  3. 최적화 탐색 (3-5분):
     패러다임 후보 나열, 적합성 검토
     ├─ "정렬하면 해결되지 않을까?"
     ├─ "DP 상태를 어떻게 정의할까?"
     ├─ "그리디가 되려면 어떤 성질이 필요할까?"
     └─ "자료구조로 병목을 줄일 수 있을까?"

  4. 구현 (10-15분):
     핵심 로직 먼저, 엣지 케이스 후처리
     변수명 명확하게, 주석 간결하게

  5. 검증 (3-5분):
     예시 입력으로 수동 추적
     시간/공간 복잡도 분석
     엣지 케이스: 빈 입력, 크기 1, 중복, 최대값

  흔한 최적화 패턴:
  O(N²) → O(N log N): 정렬 + 이진 탐색 or 투 포인터
  O(N²) → O(N): 해시맵, 슬라이딩 윈도우, 스택/큐
  O(2^N) → O(2^(N/2)): Meet in the Middle
  O(N!) → O(2^N × N): 비트마스크 DP
```

## 6. 패러다임 간 관계 지도

```
알고리즘 설계 패러다임의 전체 그림:

  분할 정복 (ad-01)
  ├─ 부분 문제 독립 → 병렬화 (ad-13)
  └─ 부분 문제 중복 → DP (ad-02, 03)

  DP (ad-02, 03)
  ├─ 최적 부분 구조만 + 그리디 선택 → 그리디 (ad-04)
  └─ 상태 공간 제한 → 메모이제이션 백트래킹

  그리디 (ad-04)
  ├─ 증명 가능 → 최적 해
  └─ 증명 불가 → 근사 (ad-07)의 시작점

  백트래킹 (ad-05)
  ├─ 한계값 추가 → 분기 한정 (B&B)
  └─ NP-hard 확인 → 근사/휴리스틱으로 전환

  NP-완전 (ad-10, 11)
  ├─ 근사 (ad-07): 보장된 비율
  ├─ 랜덤화 (ad-08): 확률적 보장
  ├─ 특수 구조: 트리/이분 그래프에서 P
  └─ FPT: 매개변수 고정 시 다항

  모든 알고리즘의 분석:
  ├─ 최악: Big-O
  ├─ 상각: 연산 시퀀스 평균 (ad-09)
  └─ 기대: 랜덤화 알고리즘 (ad-08)

  핵심 원칙:
  "먼저 올바르게, 그 다음 빠르게, 그 다음 우아하게"
  — 정확성 → 효율성 → 단순성의 순서
```

> **핵심 직관**: 알고리즘 설계의 궁극적 목표는 **"문제의 본질적 구조를 활용하여 불필요한 계산을 제거"**하는 것입니다. 정렬이 비교를 줄이고, DP가 중복 계산을 제거하고, 그리디가 탐색 공간을 줄이고, 자료구조가 접근 시간을 줄입니다. 모든 기법은 이 하나의 원칙의 변형입니다.

이 강의는 ad-01~13의 모든 패러다임을 종합하며, 실전에서 "어떤 도구를 언제 꺼내는가"의 판단력을 기르는 것이 목표입니다.

## 핵심 정리

- 패러다임 선택의 핵심은 **문제 구조 판별**: 독립 분할→분할 정복, 중복+최적 부분구조→DP, 그리디 선택 성질→그리디, NP-hard→근사
- **복합 문제**는 여러 패러다임을 조합하며, "정렬 + 자료구조", "그래프 모델링 + BFS", "DP + 이진 탐색" 등의 조합이 실전에서 빈번합니다
- **시간/공간 트레이드오프**에서 병목이 어디인지(쿼리 빈도, 메모리 제한, 실시간 여부)가 최적 전략을 결정합니다
- 면접에서는 **브루트포스 → 패러다임 탐색 → 최적화 → 구현 → 검증** 순서로 진행하며, 사고 과정을 명확히 전달하는 것이 핵심입니다
- 알고리즘 설계의 궁극 원칙은 **"문제의 구조를 활용하여 불필요한 계산을 제거"**하는 것이며, 모든 기법은 이 원칙의 변형입니다
