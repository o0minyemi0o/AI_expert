# 그리디 알고리즘

## 왜 그리디가 중요한가

"매 순간 최선의 선택이 전체 최선이 된다"—이것이 **그리디(Greedy)**의 본질입니다. DP가 모든 선택지를 탐색하는 반면, 그리디는 한 번의 선택으로 결정합니다. 문제는 **"언제 그리디가 정당한가?"**를 증명하는 것입니다. ga-02의 Dijkstra, ga-03의 Kruskal/Prim, 허프만 코딩 모두 그리디이며, 면접에서 DP와 그리디의 구분이 핵심 역량입니다.

> **핵심 직관**: 그리디가 작동하는 문제에는 **"그리디 선택 성질(Greedy Choice Property)"**이 있습니다. 현재 최적 선택을 포함하는 전역 최적해가 반드시 존재한다는 성질입니다. 이를 증명하는 표준 기법이 **교환 논증(Exchange Argument)**입니다.

## 1. 그리디 선택 성질과 증명 기법

```
그리디가 최적인 조건:

  1. 그리디 선택 성질 (Greedy Choice Property):
     지역적 최적 선택이 전역 최적해에 포함됨
     "첫 번째 선택으로 가장 좋은 것을 고르면,
      나머지도 최적으로 풀 수 있다"

  2. 최적 부분 구조 (Optimal Substructure):
     부분 문제의 최적해가 전체 최적해를 구성
     (DP와 공유하는 성질)

  증명 기법 — 교환 논증 (Exchange Argument):
  1. 최적해 OPT와 그리디해 GREEDY가 다르다고 가정
  2. OPT에서 GREEDY와 다른 첫 번째 선택을 찾음
  3. 그 선택을 GREEDY의 선택으로 "교환"
  4. 교환 후에도 최적성이 유지됨을 보임
  5. → GREEDY가 최적해에 포함될 수 있음 증명

  교환 논증이 실패하면 → 그리디가 아닌 DP 필요!
```

## 2. 활동 선택 문제

```
문제: 겹치지 않는 최대 활동 수

  활동 i: [시작, 종료) = [sᵢ, fᵢ)
  겹치지 않는 활동을 최대한 많이 선택

  그리디: 종료 시간이 빠른 순으로 선택

  why? 일찍 끝나는 활동을 선택하면
  남은 시간이 최대 → 더 많은 활동 가능
```

```python
def activity_selection(activities):
    """activities = [(start, finish), ...]"""
    activities.sort(key=lambda x: x[1])  # 종료 시간 정렬
    result = [activities[0]]
    last_finish = activities[0][1]

    for start, finish in activities[1:]:
        if start >= last_finish:  # 겹치지 않으면 선택
            result.append((start, finish))
            last_finish = finish
    return result
```

```
교환 논증:

  최적해 OPT = {a₁, a₂, ..., aₖ} (종료 순 정렬)
  그리디 선택: g₁ (가장 빨리 끝나는 활동)

  만약 a₁ ≠ g₁이면:
  f(g₁) ≤ f(a₁) (g₁이 가장 빨리 끝나므로)
  → a₁을 g₁으로 교체해도 나머지와 겹치지 않음
  → {g₁, a₂, ..., aₖ}도 최적해
  → 그리디 선택 포함 가능 증명!

  주의: 시작 시간 기준은 최적이 아님!
  반례: [1, 10), [2, 3), [4, 5)
  시작 순: [1,10) 선택 → 1개
  종료 순: [2,3), [4,5) → 2개
```

> **핵심 직관**: 활동 선택에서 "종료 시간이 빠른 것"을 고르는 이유는 **"자원(시간)을 가장 적게 소비하는 선택"**이기 때문입니다. 이 "자원 절약" 관점은 많은 그리디 문제에서 공통적으로 나타납니다.

## 3. 스케줄링 문제

```
문제 1: 가중 작업 스케줄링 (Weighted Job Scheduling)
  각 작업에 가중치(이익)가 있을 때 → 그리디 실패!
  → DP 필요 (ad-02)
  dp[i] = i번째 작업까지 최대 이익
  → 이분 탐색 + DP: O(N log N)

문제 2: 최소 지연 스케줄링 (Minimize Maximum Lateness)
  각 작업: 처리 시간 tᵢ, 마감 dᵢ
  목표: 최대 지연 min(max(완료시간ᵢ - dᵢ))

  그리디: 마감 시간이 빠른 순 (EDD: Earliest Due Date)
  → 최적 (교환 논증으로 증명 가능)

문제 3: 최소 완료 시간 합 (SJF: Shortest Job First)
  각 작업의 처리 시간 tᵢ
  목표: 평균/총 완료 시간 최소화
  그리디: 짧은 작업 먼저 (SJF)

  직관: 짧은 작업을 먼저 하면 뒤의 모든 작업이 혜택
  n명이 줄 서있을 때, 처리 시간 짧은 사람이 앞에 서면
  전체 대기 시간 최소!
```

## 4. 허프만 코딩

```
허프만 코딩: 최적 접두어 코드 (Optimal Prefix Code)

  빈도 높은 문자 → 짧은 코드
  빈도 낮은 문자 → 긴 코드
  접두어 조건: 한 코드가 다른 코드의 접두어가 아님

  구성 알고리즘:
  1. 각 문자를 빈도로 힙에 삽입
  2. 가장 작은 두 노드를 꺼내 합쳐 새 노드 생성
  3. 새 노드를 힙에 삽입
  4. 노드가 1개 남을 때까지 반복
  → 이진 트리의 좌/우 간선이 0/1 코드
```

```python
import heapq

def huffman(freq):
    """freq = {'a': 45, 'b': 13, 'c': 12, ...}"""
    heap = [(f, c) for c, f in freq.items()]
    heapq.heapify(heap)

    while len(heap) > 1:
        f1, left = heapq.heappop(heap)
        f2, right = heapq.heappop(heap)
        heapq.heappush(heap, (f1 + f2, (left, right)))

    # 트리에서 코드 추출
    codes = {}
    def build_codes(node, code=""):
        if isinstance(node, str):
            codes[node] = code
            return
        build_codes(node[0], code + "0")
        build_codes(node[1], code + "1")

    build_codes(heap[0][1])
    return codes

# 예: {a:45, b:13, c:12, d:16, e:9, f:5}
# a→0, c→100, b→101, f→1100, e→1101, d→111
# 평균: 45×1 + 13×3 + 12×3 + 16×3 + 9×4 + 5×4 = 224비트
# 균등 3비트: 100×3 = 300비트 → 25% 절약
```

```
허프만이 최적인 이유:

  교환 논증:
  빈도가 가장 낮은 두 문자는 최적 코드에서
  가장 깊은 레벨의 형제(sibling)여야 함

  증명: 만약 빈도 낮은 문자가 얕으면
  빈도 높은 문자와 교환해도 비트 수 감소
  → 모순

  시간: O(N log N) — 힙 기반
  응용:
  ├─ 데이터 압축 (ZIP, GZIP의 구성 요소)
  ├─ 정보 이론: 허프만 코드 ≈ 엔트로피 H (pt-12)
  └─ 최적 병합 비용: N개 파일 합치기
```

> **핵심 직관**: 허프만 코딩의 그리디 선택은 **"가장 빈도 낮은 두 노드를 먼저 합치기"**입니다. 이는 "가장 비용이 적은 것을 맨 아래에 배치"하는 전략으로, ads-08의 힙을 이용해 효율적으로 구현됩니다.

## 5. 그리디 vs DP 판별

```
그리디가 되는 문제 vs DP가 필요한 문제:

  활동 선택 (비가중) → 그리디 ✓
  활동 선택 (가중)   → DP 필요 (가중치가 순서를 바꿈)

  동전 교환 (1, 5, 10, 25) → 그리디 ✓ (특수 화폐 체계)
  동전 교환 (1, 3, 4)     → DP 필요 (6 = 3+3, 그리디는 4+1+1)

  분수 배낭 → 그리디 ✓ (가치/무게 비율 순)
  0/1 배낭 → DP 필요 (쪼갤 수 없음)

  판별 기준:
  1. 그리디 해가 직관적으로 떠오르는가?
  2. 반례를 찾을 수 있는가?
  3. 교환 논증이 성립하는가?

  "그리디가 될 것 같다" → 반례 먼저 찾기!
  반례 없으면 → 교환 논증 시도
  교환 논증 실패 → DP

  Matroid와 그리디:
  "Matroid 구조"를 가진 문제에서 그리디가 최적
  MST (ga-03): 그래프 Matroid
  → 이론적이지만 면접에서는 직관적 판별이 더 실용적
```

## 6. 실전 그리디 패턴

```
패턴별 정리:

  자원 할당:
  ├─ 겹치지 않는 최대 선택: 종료 순 그리디
  ├─ 모든 작업 커버: 시작 순 그리디
  └─ 회의실 최소 수: 시작 순 정렬 + 힙

  순서 결정:
  ├─ 지연 최소화: 마감 순 (EDD)
  ├─ 완료 시간 합 최소: 처리 시간 순 (SJF)
  └─ 사전 순 최소: 스택/그리디 선택

  비용 최적화:
  ├─ 허프만: 빈도 낮은 것부터 합치기
  ├─ 분수 배낭: 가치/무게 비율 순
  └─ MST (ga-03): 가벼운 간선 순

  주의:
  그리디의 증명이 어려우면 코드부터 작성하고
  작은 예시에서 검증한 후 면접관과 논의
```

그리디는 ga-02의 Dijkstra, ga-03의 MST와 같은 패러다임이며, ad-02의 DP와 항상 비교되고, ad-07의 근사 알고리즘에서 "최적은 아니지만 좋은" 그리디 전략이 활용됩니다.

## 핵심 정리

- 그리디의 핵심 조건은 **그리디 선택 성질**이며, **교환 논증**으로 현재 선택이 최적해에 포함됨을 증명합니다
- **활동 선택**은 종료 시간 순 그리디로 $O(N \log N)$에 최적해를 구하며, 가중치가 붙으면 DP가 필요합니다
- **허프만 코딩**은 빈도가 가장 낮은 두 노드를 합치는 그리디로, 최적 접두어 코드를 $O(N \log N)$에 생성합니다
- **그리디 vs DP 판별**: 반례를 먼저 찾고, 없으면 교환 논증을 시도하며, 실패하면 DP를 사용합니다
- 스케줄링에서 **EDD(마감 순)**, **SJF(처리 시간 순)** 등 문제별 최적 정렬 기준이 다르며, 이를 구분하는 것이 핵심입니다
