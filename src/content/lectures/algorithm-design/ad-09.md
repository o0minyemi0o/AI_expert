# 상각 분석

## 왜 상각 분석이 중요한가

동적 배열(Python의 list)에 append를 할 때, 대부분은 O(1)이지만 가끔 O(N) 복사가 발생합니다. 최악 분석으로는 O(N)이지만, N번의 연산을 합산하면 총 O(N)—**연산당 평균 O(1)**입니다. 이런 "가끔 비싼 연산이 있지만 전체적으로는 싼" 패턴을 분석하는 것이 **상각 분석(Amortized Analysis)**입니다. 최악 분석의 과대평가를 교정하여 실제 성능을 정확히 파악합니다.

> **핵심 직관**: 상각 분석은 **"비싼 연산의 비용을 싼 연산들에게 분산시키는"** 기법입니다. 총 N번의 연산에 대해 전체 비용 T(N)을 구하고, 연산당 T(N)/N이 상각 비용입니다. 이는 확률적 평균이 아니라, **최악의 경우에도 보장되는 평균**입니다.

## 1. 세 가지 분석 방법

```
상각 분석의 3가지 기법:

  1. Aggregate (총합) 방법:
     N번 연산의 총 비용을 직접 계산
     상각 비용 = 총 비용 / N

  2. Accounting (회계) 방법:
     각 연산에 "상각 비용" 부여
     싼 연산은 초과 지불 → 크레딧 저축
     비싼 연산은 크레딧으로 지불
     크레딧이 항상 ≥ 0이면 유효

  3. Potential (퍼텐셜) 방법:
     자료구조의 상태를 퍼텐셜 함수 Φ로 정의
     상각 비용 = 실제 비용 + ΔΦ
     Φ가 단조 증가 → 비싼 연산에서 Φ 감소 = "저축 사용"
```

## 2. Aggregate 방법: 동적 배열

```
동적 배열 (Python list, Java ArrayList):

  크기 n인 배열이 가득 차면 → 2n으로 확장 + 복사

  연산 기록:
  연산   1  2  3  4  5  6  7  8  9 ...
  비용   1  1  1  4  1  1  1  8  1 ...
              (3복사+1) (7복사+1)

  N번 연산의 총 비용:
  일반 삽입: N × 1 = N
  복사 비용: 1 + 2 + 4 + 8 + ... + 2^⌊log N⌋
           = 2^{⌊log N⌋+1} - 1 < 2N

  총 비용 < N + 2N = 3N
  상각 비용 = 3N / N = O(1)!

  확장 비율의 영향:
  2배 확장: 상각 O(1), 공간 낭비 최대 50%
  1.5배 확장: 상각 O(1), 공간 낭비 적지만 복사 빈번
  1+ε 확장: 상각 O(1/ε), 공간 효율적
  → 실무: 대부분 2배 (Python, Java, Go)
```

## 3. Accounting 방법: 스택과 멀티팝

```
Multipop Stack:

  연산:
  - PUSH(x): 스택에 삽입 — O(1)
  - POP: 스택에서 제거 — O(1)
  - MULTIPOP(k): min(k, 스택 크기)개 제거 — O(min(k, n))

  최악: MULTIPOP(n) = O(n)
  하지만 N번 연산의 총 비용은?

  Accounting 방법:
  PUSH의 상각 비용 = 2 (실제 1 + 크레딧 1 저축)
  POP의 상각 비용 = 0 (크레딧 1 사용)
  MULTIPOP의 상각 비용 = 0 (크레딧 k 사용)

  불변량: 크레딧 = 스택의 현재 원소 수 ≥ 0 ✓

  이유: 각 원소는 PUSH 시 크레딧 1을 받고
  POP/MULTIPOP 시 그 크레딧을 소비
  → 모든 연산의 상각 비용 = O(1)
  → N번 연산의 총 비용 = O(N)
```

> **핵심 직관**: Accounting 방법의 핵심은 **"미래에 비싼 연산이 올 것에 대비하여 지금 저축"**하는 것입니다. PUSH가 "자기 자신의 POP 비용까지 선불"하므로, 나중에 MULTIPOP이 와도 이미 지불된 상태입니다.

## 4. Potential 방법: 이진 카운터

```
이진 카운터 증가 (INCREMENT):

  비용 = 뒤집히는 비트 수

  카운터:   비용:
  00000     —
  00001     1 (0→1)
  00010     2 (01→10)
  00011     1 (0→1)
  00100     3 (011→100)
  00101     1
  00110     2
  00111     1
  01000     4 (0111→1000)

  Potential 함수: Φ = 1인 비트 수

  INCREMENT:
  t개의 1이 0으로 바뀌고, 1개의 0이 1로 바뀜
  실제 비용 = t + 1
  ΔΦ = -t + 1 (t개 감소, 1개 증가)

  상각 비용 = (t + 1) + (-t + 1) = 2 = O(1)!

  증명: Φ ≥ 0 (1의 개수는 음수 불가)
  Σ 상각 비용 ≥ Σ 실제 비용
  → N번 INCREMENT의 총 비용 = O(N)
```

```python
# Potential 방법의 일반적 프레임워크
def amortized_analysis():
    """
    퍼텐셜 함수 Φ(S)를 정의:
    - Φ는 자료구조의 상태 S에 대한 함수
    - Φ(S₀) = 0 (초기 상태)
    - Φ(Sᵢ) ≥ 0 (모든 상태)

    연산 i의 상각 비용:
    â_i = c_i + Φ(Sᵢ) - Φ(Sᵢ₋₁)

    총 상각 비용:
    Σâ_i = Σc_i + Φ(Sₙ) - Φ(S₀) ≥ Σc_i
    (Φ(Sₙ) ≥ 0이므로)

    → 상각 비용의 합 ≥ 실제 비용의 합
    → 상각 비용은 실제 비용의 상한
    """
```

## 5. 실전 응용

```
응용 1: Splay Tree (ads-05)
  Φ = Σ log(size(subtree(v)))
  각 연산의 상각 비용 = O(log N)
  → 최악 O(N)이지만 상각 O(log N) 보장

응용 2: Fibonacci Heap (ads-08)
  Φ = 트리 수 + 2 × mark된 노드 수
  → INSERT: 상각 O(1)
  → DECREASE-KEY: 상각 O(1)
  → DELETE-MIN: 상각 O(log N)
  → Dijkstra에서 O(V log V + E) 달성의 핵심!

응용 3: Union-Find (ads-06)
  경로 압축 + 랭크 합치기
  Φ = Σ α(n) 관련 함수
  → 상각 O(α(N)) ≈ O(1) per 연산

응용 4: Hash Table 재해시
  동적 배열과 동일한 분석
  적재율 > 0.75 → 2배 확장 + 전체 재삽입
  → 상각 O(1) per 삽입

  | 자료구조 | 최악 | 상각 | Φ |
  |---------|------|------|---|
  | 동적 배열 | O(N) | O(1) | 크기-용량 차이 |
  | Splay Tree | O(N) | O(log N) | 랭크 합 |
  | Fibonacci Heap | O(N) | O(1)~O(log N) | 트리+마크 수 |
  | Union-Find | O(log N) | O(α(N)) | 역아커만 관련 |
```

> **핵심 직관**: Potential 방법에서 **Φ 함수 설계가 핵심**입니다. Φ가 "비싼 연산 전에 높아지고, 비싼 연산에서 크게 감소"하도록 설계하면, 높은 실제 비용이 Φ 감소로 상쇄됩니다. 좋은 Φ는 "자료구조의 '혼란도' 또는 '미래 비용 저축'"을 나타냅니다.

## 6. 상각 vs 평균 vs 최악

```
세 가지 분석의 차이:

  최악 (Worst-Case):
  단일 연산의 최대 비용
  → 가장 보수적, 과대평가 가능

  평균 (Average-Case):
  입력의 확률 분포를 가정
  → 분포 가정이 틀리면 무효

  상각 (Amortized):
  N번 연산의 총 비용 / N
  → 분포 가정 없음, 최악의 시퀀스에도 성립
  → 단일 연산은 비쌀 수 있지만 시퀀스 평균은 보장

  비유:
  최악: "가장 비싼 월세"
  평균: "모든 사람의 평균 월세"
  상각: "내가 1년간 낸 총 월세 / 12" (일부 달에 보증금 포함)

  주의:
  상각 O(1)이 각 연산 O(1)을 의미하지 않음!
  → 실시간(real-time) 시스템에서는 최악이 중요
  → 다만 대부분의 응용에서는 상각으로 충분
```

상각 분석은 ads-05의 Splay Tree, ads-06의 Union-Find, ads-08의 Fibonacci Heap의 복잡도를 정확히 설명하며, ad-02의 DP에서 동적 테이블 확장에도 적용됩니다.

## 핵심 정리

- **상각 분석**은 N번 연산의 총 비용을 분석하여 연산당 평균 비용을 구하며, 확률 가정 없이 최악 시퀀스에도 성립합니다
- **Aggregate 방법**은 총 비용을 직접 계산하며, 동적 배열의 상각 $O(1)$ append를 보입니다
- **Accounting 방법**은 싼 연산에 크레딧을 저축하고 비싼 연산에 소비하며, 크레딧 ≥ 0이 유효 조건입니다
- **Potential 방법**은 상태 함수 $\Phi$를 정의하여, 상각 비용 = 실제 비용 + $\Delta\Phi$로 계산합니다
- $\Phi$ 설계의 핵심은 **"비싼 연산 전에 높아지고, 비싼 연산에서 크게 감소"**하도록 만들어 비용을 상쇄하는 것입니다
