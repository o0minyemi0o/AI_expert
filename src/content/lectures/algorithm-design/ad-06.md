# 문자열 알고리즘

## 왜 문자열 알고리즘이 중요한가

텍스트 검색, DNA 서열 분석, 컴파일러 어휘 분석, 검색 엔진 인덱싱—모두 **문자열 패턴 매칭**이 핵심입니다. 나이브한 O(NM) 탐색을 넘어, KMP, Rabin-Karp 등은 O(N+M)에 패턴을 찾고, Suffix Array는 O(N log N) 전처리로 O(M log N) 쿼리를 가능하게 합니다. ads-03의 트라이가 단어 단위 검색이라면, 이 강의는 **부분 문자열 수준**의 정밀한 매칭을 다룹니다.

> **핵심 직관**: 문자열 알고리즘의 핵심 아이디어는 **"이미 비교한 정보를 재활용"**하는 것입니다. 불일치가 발생했을 때 처음부터 다시 비교하는 대신, 패턴 내부의 구조(접두어=접미어)를 이용하여 건너뛰는 것이 KMP, Z-Algorithm의 본질입니다.

## 1. KMP (Knuth-Morris-Pratt)

```
KMP의 핵심: 실패 함수 (Failure Function / π 배열)

  π[i] = pattern[0..i]의 접두어이면서 접미어인 최장 길이
  (자기 자신 제외)

  예: pattern = "ABACABAB"
  i:     0  1  2  3  4  5  6  7
  char:  A  B  A  C  A  B  A  B
  π[i]:  0  0  1  0  1  2  3  2

  π[6] = 3: "ABACABA"의 접두어 "ABA" = 접미어 "ABA"
  → 불일치 시 3칸으로 점프 가능!

  동작:
  text:    ... A B A C A B A X ...
  pattern:     A B A C A B A B
                              ↑ 불일치 at i=7
  π[6] = 3 → pattern을 3 위치부터 다시 비교
  text:    ... A B A C A B A X ...
  pattern:             A B A C A B A B
                       ↑ 여기부터 비교 (3칸 건너뜀)
```

```python
def build_failure(pattern):
    n = len(pattern)
    pi = [0] * n
    k = 0
    for i in range(1, n):
        while k > 0 and pattern[k] != pattern[i]:
            k = pi[k - 1]
        if pattern[k] == pattern[i]:
            k += 1
        pi[i] = k
    return pi

def kmp_search(text, pattern):
    pi = build_failure(pattern)
    matches = []
    k = 0
    for i in range(len(text)):
        while k > 0 and pattern[k] != text[i]:
            k = pi[k - 1]
        if pattern[k] == text[i]:
            k += 1
        if k == len(pattern):
            matches.append(i - len(pattern) + 1)
            k = pi[k - 1]
    return matches

# 시간: O(N + M) — 전처리 O(M) + 탐색 O(N)
```

> **핵심 직관**: KMP의 실패 함수 π[i]는 **"패턴이 자기 자신과 얼마나 겹치는가"**를 나타냅니다. 불일치 시 이 정보로 패턴을 최대한 많이 건너뛰어, 이미 일치한 부분을 다시 비교하지 않습니다. 텍스트의 각 문자는 정확히 한 번만 비교됩니다.

## 2. Rabin-Karp

```
Rabin-Karp: 롤링 해시 기반 문자열 매칭

  아이디어: 패턴과 텍스트 윈도우의 해시값 비교
  해시가 같으면 → 실제 비교 (충돌 가능)
  해시가 다르면 → 확실히 불일치 (건너뜀)

  롤링 해시:
  hash("ABC") = A×p² + B×p + C  (mod M)
  hash("BCD") = (hash("ABC") - A×p²) × p + D  (mod M)
  → O(1)에 다음 윈도우 해시 계산!
```

```python
def rabin_karp(text, pattern):
    n, m = len(text), len(pattern)
    BASE, MOD = 31, 10**9 + 7

    # 패턴 해시
    p_hash = 0
    for c in pattern:
        p_hash = (p_hash * BASE + ord(c)) % MOD

    # 첫 윈도우 해시
    t_hash = 0
    for c in text[:m]:
        t_hash = (t_hash * BASE + ord(c)) % MOD

    power = pow(BASE, m - 1, MOD)  # BASE^(m-1) mod MOD
    matches = []

    for i in range(n - m + 1):
        if t_hash == p_hash:
            if text[i:i+m] == pattern:  # 실제 비교
                matches.append(i)
        if i + m < n:
            # 롤링: 앞 문자 제거, 뒤 문자 추가
            t_hash = ((t_hash - ord(text[i]) * power) * BASE
                     + ord(text[i + m])) % MOD
    return matches

# 평균 O(N + M), 최악 O(NM) — 해시 충돌 시
```

```
KMP vs Rabin-Karp:

  KMP: 최악 O(N+M), 단일 패턴, 결정적
  Rabin-Karp: 평균 O(N+M), 최악 O(NM), 확률적

  Rabin-Karp의 장점:
  ├─ 다중 패턴 검색: K개 패턴 해시를 집합에 저장
  │   → O(N×K) 대신 O(N) (해시 충돌 무시)
  ├─ 2D 패턴 매칭: 행별 해시 → 열 방향 롤링
  └─ 구현이 간단 (해시만 이해하면 됨)
```

## 3. Z-Algorithm

```
Z-Algorithm: Z 배열

  Z[i] = s[i:]와 s[0:]의 최장 공통 접두어 길이
  Z[0] = 0 (정의상) 또는 N

  예: s = "aabxaab"
  Z = [0, 1, 0, 0, 3, 1, 0]

  Z[4] = 3: s[4:] = "aab"와 s[0:] = "aab"가 3글자 일치

  패턴 매칭 활용:
  s = pattern + "$" + text 에서 Z 배열 계산
  Z[i] == len(pattern)이면 text에서 매칭 위치!
```

```python
def z_function(s):
    n = len(s)
    z = [0] * n
    l, r = 0, 0  # Z-box 범위 [l, r)
    for i in range(1, n):
        if i < r:
            z[i] = min(r - i, z[i - l])
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] > r:
            l, r = i, i + z[i]
    return z

def z_search(text, pattern):
    s = pattern + "$" + text
    z = z_function(s)
    m = len(pattern)
    return [i - m - 1 for i in range(m + 1, len(s)) if z[i] == m]
```

```
Z vs KMP:
  둘 다 O(N + M), 동일한 정보를 다른 형태로 표현
  KMP π: 접두어=접미어의 최장 길이 (점진적)
  Z: 각 위치에서 접두어와의 일치 길이 (직접적)

  Z가 더 직관적일 수 있음:
  "i번째 위치부터 시작과 얼마나 같은가?"
```

## 4. Suffix Array

```
Suffix Array: 모든 접미어를 사전순 정렬

  s = "banana"
  접미어:
  0: banana
  1: anana
  2: nana
  3: ana
  4: na
  5: a

  사전순 정렬:
  5: a
  3: ana
  1: anana
  0: banana
  4: na
  2: nana

  SA = [5, 3, 1, 0, 4, 2]

  패턴 검색: 이진 탐색 → O(M log N)
  "ana" 찾기: SA에서 이진 탐색 → [3, 1] (2개 매칭)

  구축: O(N log N) 또는 O(N) — SA-IS 알고리즘
  공간: O(N)
  → Suffix Tree보다 공간 효율적!
```

```
LCP 배열 (Longest Common Prefix):

  LCP[i] = SA[i]번째 접미어와 SA[i-1]번째 접미어의 공통 접두어 길이

  s = "banana", SA = [5,3,1,0,4,2]
  SA[0]: a
  SA[1]: ana     → LCP[1] = 1 (a)
  SA[2]: anana   → LCP[2] = 3 (ana)
  SA[3]: banana  → LCP[3] = 0
  SA[4]: na      → LCP[4] = 0
  SA[5]: nana    → LCP[5] = 2 (na)

  LCP 활용:
  ├─ 서로 다른 부분 문자열 수 = N(N+1)/2 - ΣLCP[i]
  ├─ 최장 반복 부분 문자열 = max(LCP)
  └─ 두 접미어의 LCP = LCP 배열의 구간 최솟값 (RMQ, ads-01)
```

## 5. Aho-Corasick

```
Aho-Corasick: 다중 패턴 동시 매칭

  KMP + 트라이 (ads-03) 결합
  K개 패턴을 동시에 O(N + M + Z) 탐색
  (N: 텍스트, M: 패턴 총 길이, Z: 매칭 수)

  구축:
  1. 패턴들로 트라이 구축
  2. BFS로 failure link 계산 (KMP의 실패 함수 확장)
  3. output link로 매칭된 패턴 추적

  예: 패턴 {"he", "she", "his", "hers"}

  트라이:
  root → h → e → r → s
         ↓
         i → s
  root → s → h → e

  failure link: 현재 노드에서 불일치 시
  가장 긴 접미어에 해당하는 트라이 노드로 이동

  응용:
  ├─ 바이러스 검사: 수천 개 시그니처 동시 매칭
  ├─ DNA 모티프 검색: 여러 서열 패턴 동시 탐색
  ├─ 텍스트 필터링: 금지어 목록 검사
  └─ 검색 엔진: 쿼리 내 키워드 매칭
```

> **핵심 직관**: Aho-Corasick은 **"트라이 위에서의 KMP"**입니다. 단일 패턴의 failure function을 트라이의 모든 노드로 확장하면, 텍스트를 한 번만 스캔하면서 모든 패턴을 동시에 매칭할 수 있습니다.

## 6. 알고리즘 선택 가이드

| 상황 | 알고리즘 | 시간 |
|------|---------|------|
| 단일 패턴 매칭 | KMP | $O(N+M)$ |
| 단일 패턴, 간단 구현 | Rabin-Karp | 평균 $O(N+M)$ |
| 다중 패턴 매칭 | Aho-Corasick | $O(N+M+Z)$ |
| 반복 쿼리 (전처리 가능) | Suffix Array | $O(N\log N)$ + $O(M\log N)$ |
| 접두어 관련 | Z-Algorithm | $O(N+M)$ |

```
실전 팁:

  면접에서 가장 빈출: KMP, Rabin-Karp
  경쟁 프로그래밍: Z-Algorithm (구현 간결), Suffix Array
  시스템 설계: Aho-Corasick (다중 패턴)

  Python 내장:
  s.find(pattern) — 내부적으로 Boyer-Moore 변형
  re.findall() — 정규식 NFA/DFA
  → 면접에서는 알고리즘 이해를 보여야 하므로 직접 구현
```

문자열 알고리즘은 ads-03의 트라이를 확장(Aho-Corasick)하고, ads-07의 해싱(Rabin-Karp)을 활용하며, ad-01의 분할 정복(Suffix Array 구축)과 연결됩니다.

## 핵심 정리

- **KMP**는 실패 함수 π로 "패턴 내부의 접두어=접미어 구조"를 활용하여, 불일치 시 최대한 건너뛰어 $O(N+M)$에 매칭합니다
- **Rabin-Karp**는 롤링 해시로 $O(1)$ 윈도우 이동을 달성하며, 다중 패턴 검색과 2D 매칭에 장점이 있습니다
- **Z-Algorithm**은 "각 위치에서 접두어와의 일치 길이"를 $O(N)$에 계산하며, KMP와 동일한 정보의 다른 표현입니다
- **Suffix Array**는 모든 접미어의 사전순 정렬로 $O(M \log N)$ 패턴 검색을 지원하고, LCP 배열과 결합하면 반복 부분 문자열 분석이 가능합니다
- **Aho-Corasick**은 트라이 + failure link로 K개 패턴을 $O(N+M+Z)$에 동시 매칭하며, 다중 패턴 검색의 표준입니다
