# 분할 정복 마스터리

## 왜 분할 정복이 중요한가

"큰 문제를 작은 문제로 나누고, 각각 풀고, 합친다"—이것이 **분할 정복(Divide and Conquer)**의 본질입니다. 병합 정렬, 퀵 정렬, 이진 탐색이 대표적이지만, Karatsuba 곱셈, 최근접 점 쌍, FFT 등 놀라운 알고리즘들도 분할 정복에서 탄생했습니다. 이 강의에서는 이미 알고 있는 기본을 넘어, **Master Theorem으로 복잡도를 분석**하고 **고급 분할 정복 기법**을 마스터합니다.

> **핵심 직관**: 분할 정복의 핵심 질문은 **"합치기(Merge/Combine) 단계가 얼마나 비싼가?"**입니다. 분할은 보통 O(1)이지만, 합치기 비용이 전체 복잡도를 결정합니다. 병합 정렬의 O(N)합치기 → O(N log N), 행렬 곱셈의 O(N²) 합치기 → O(N³)과 O(N^{2.81})의 차이가 여기서 나옵니다.

## 1. 분할 정복의 구조

```
분할 정복의 3단계:

  1. Divide: 문제를 a개의 부분 문제로 분할
     각 부분 문제의 크기: n/b

  2. Conquer: 각 부분 문제를 재귀적으로 해결
     기저 조건(base case)에서 직접 해결

  3. Combine: 부분 해를 합쳐 전체 해 구성
     이 단계의 비용 = f(n)

  점화식: T(n) = a·T(n/b) + f(n)

  예:
  병합 정렬: T(n) = 2·T(n/2) + O(n)    → a=2, b=2, f=O(n)
  이진 탐색: T(n) = 1·T(n/2) + O(1)    → a=1, b=2, f=O(1)
  Karatsuba: T(n) = 3·T(n/2) + O(n)    → a=3, b=2, f=O(n)
  Strassen:  T(n) = 7·T(n/2) + O(n²)   → a=7, b=2, f=O(n²)
```

## 2. Master Theorem

```
Master Theorem:

  T(n) = a·T(n/b) + f(n)에 대해,
  c_crit = log_b(a)를 정의하면:

  Case 1: f(n) = O(n^{c_crit - ε}) → T(n) = Θ(n^{c_crit})
  "재귀 비용이 지배" (분할이 비쌈)

  Case 2: f(n) = Θ(n^{c_crit} · log^k(n)) → T(n) = Θ(n^{c_crit} · log^{k+1}(n))
  "균형" (재귀와 합치기가 비슷)

  Case 3: f(n) = Ω(n^{c_crit + ε}) + 정칙 조건 → T(n) = Θ(f(n))
  "합치기 비용이 지배" (합치기가 비쌈)

  적용 예:
  ┌─────────────────────────────────────────────────────┐
  │ 알고리즘     │ a  b  f(n)    │ c_crit │ Case │ T(n)      │
  │─────────────│──────────────│────────│──────│───────────│
  │ 이진 탐색    │ 1  2  O(1)   │ 0      │ 2    │ O(log n)  │
  │ 병합 정렬    │ 2  2  O(n)   │ 1      │ 2    │ O(n log n)│
  │ Karatsuba   │ 3  2  O(n)   │ 1.58   │ 1    │ O(n^1.58) │
  │ Strassen    │ 7  2  O(n²)  │ 2.81   │ 1    │ O(n^2.81) │
  └─────────────────────────────────────────────────────┘
```

```
Master Theorem이 적용 안 되는 경우:

  1. 부분 문제 크기가 불균등: T(n) = T(n/3) + T(2n/3) + O(n)
     → Akra-Bazzi 정리 사용

  2. f(n)이 다항식이 아닌 경우: f(n) = n/log(n)
     → 점화식 직접 풀기 (재귀 트리)

  재귀 트리 방법:
  각 레벨의 총 비용을 합산

  병합 정렬 재귀 트리:
  Level 0:         [n]            비용: n
  Level 1:    [n/2]   [n/2]       비용: n
  Level 2:  [n/4][n/4][n/4][n/4]  비용: n
  ...
  Level log n: [1][1]...[1]       비용: n
  총: n × log n = O(n log n)
```

> **핵심 직관**: Master Theorem의 핵심은 **"재귀 호출 수(a) vs 문제 축소율(b) vs 합치기 비용(f)"의 경쟁**입니다. $n^{\log_b a}$가 재귀의 "자연스러운 비용"이고, f(n)이 이보다 작으면 재귀가 지배, 크면 합치기가 지배, 같으면 log이 하나 곱해집니다.

## 3. Karatsuba 곱셈

```
문제: n자리 수 두 개의 곱셈

  초등학교 방법: O(n²) — 각 자릿수 쌍 곱셈

  Karatsuba의 관찰:
  x = a·10^{n/2} + b
  y = c·10^{n/2} + d

  x·y = ac·10^n + (ad + bc)·10^{n/2} + bd

  일반: 4번 곱셈 (ac, ad, bc, bd) → T(n) = 4T(n/2) + O(n) = O(n²)

  Karatsuba 트릭:
  z₀ = bd
  z₂ = ac
  z₁ = (a+b)(c+d) - z₀ - z₂ = ad + bc

  3번 곱셈! → T(n) = 3T(n/2) + O(n) = O(n^{log₂3}) ≈ O(n^{1.585})
```

```python
def karatsuba(x, y):
    if x < 10 or y < 10:
        return x * y

    n = max(len(str(x)), len(str(y)))
    m = n // 2

    high_x, low_x = divmod(x, 10**m)
    high_y, low_y = divmod(y, 10**m)

    z0 = karatsuba(low_x, low_y)
    z2 = karatsuba(high_x, high_y)
    z1 = karatsuba(high_x + low_x, high_y + low_y) - z0 - z2

    return z2 * 10**(2*m) + z1 * 10**m + z0
```

```
Karatsuba의 영향:

  n = 1000자리: 초등학교 10⁶ vs Karatsuba ~40,000 연산
  → 대수(big number) 연산의 기본

  더 빠른 곱셈:
  Toom-Cook: T(n) = 5T(n/3) → O(n^{log₃5}) ≈ O(n^{1.465})
  Schönhage-Strassen: O(n log n log log n) — FFT 기반
  Harvey-Hoeven (2019): O(n log n) — 이론적 최적!
```

## 4. 최근접 점 쌍

```
문제: 평면의 N개 점에서 가장 가까운 두 점 찾기

  브루트포스: O(n²) — 모든 쌍 비교

  분할 정복: O(n log n)

  과정:
  1. x좌표로 정렬
  2. 중앙선으로 좌/우 분할
  3. 각각 재귀 → 좌측 최소 δ_L, 우측 최소 δ_R
  4. δ = min(δ_L, δ_R)
  5. 중앙선 ±δ 범위의 점들만 확인 (strip)

  핵심: strip 안에서 각 점이 비교할 상대가 O(1)개!

  strip 내 점을 y좌표로 정렬
  각 점은 δ×2δ 상자 안의 점만 확인
  → 이 상자에 최대 6~8개 점 (증명 가능)

  전체: T(n) = 2T(n/2) + O(n) = O(n log n)
```

```python
def closest_pair(points):
    points.sort()  # x좌표 정렬

    def solve(pts):
        if len(pts) <= 3:
            return brute_force(pts)

        mid = len(pts) // 2
        mid_x = pts[mid][0]

        d_left = solve(pts[:mid])
        d_right = solve(pts[mid:])
        d = min(d_left, d_right)

        # Strip: 중앙선 ±d 범위의 점들
        strip = [p for p in pts if abs(p[0] - mid_x) < d]
        strip.sort(key=lambda p: p[1])  # y좌표 정렬

        # Strip 내 비교 (각 점당 최대 7개)
        for i in range(len(strip)):
            j = i + 1
            while j < len(strip) and strip[j][1] - strip[i][1] < d:
                d = min(d, dist(strip[i], strip[j]))
                j += 1
        return d

    return solve(points)
```

> **핵심 직관**: 최근접 점 쌍의 핵심 관찰은 **"strip 안의 점 수가 아무리 많아도 각 점은 O(1)개만 비교"**한다는 것입니다. δ×2δ 상자 안에 점이 7개 이상이면 두 점 거리가 δ 미만이 되어 모순이기 때문입니다. 이 기하학적 관찰이 O(N) 합치기를 보장합니다.

## 5. 행렬 곱셈과 Strassen

```
일반 행렬 곱셈: O(n³)

  C = A × B
  분할: 각 행렬을 4개 블록으로 나누기

  일반 분할 정복: 8번 곱셈
  T(n) = 8T(n/2) + O(n²) = O(n³) — 개선 없음

  Strassen: 7번 곱셈 + 더 많은 덧셈
  T(n) = 7T(n/2) + O(n²) = O(n^{log₂7}) ≈ O(n^{2.807})

  핵심 아이디어:
  A = [[A₁₁, A₁₂], [A₂₁, A₂₂]], B = [[B₁₁, B₁₂], [B₂₁, B₂₂]]

  M₁ = (A₁₁ + A₂₂)(B₁₁ + B₂₂)
  M₂ = (A₂₁ + A₂₂)B₁₁
  M₃ = A₁₁(B₁₂ - B₂₂)
  M₄ = A₂₂(B₂₁ - B₁₁)
  M₅ = (A₁₁ + A₁₂)B₂₂
  M₆ = (A₂₁ - A₁₁)(B₁₁ + B₁₂)
  M₇ = (A₁₂ - A₂₂)(B₂₁ + B₂₂)

  C₁₁ = M₁ + M₄ - M₅ + M₇
  C₁₂ = M₃ + M₅
  C₂₁ = M₂ + M₄
  C₂₂ = M₁ - M₂ + M₃ + M₆

  실무: n < ~64에서는 일반 곱셈이 더 빠름 (상수 큼)
  → 하이브리드: 큰 행렬은 Strassen, 작으면 일반
```

## 6. 분할 정복 설계 전략

```
분할 정복 설계 체크리스트:

  1. 어떻게 나눌 것인가?
     ├─ 크기 기반: 배열 반분 (병합 정렬)
     ├─ 값 기반: 피벗 (퀵 정렬)
     └─ 기하학적: 좌표 분할 (최근접 점 쌍)

  2. 기저 조건은 무엇인가?
     ├─ 크기 1~3: 직접 해결
     └─ 주의: 기저 크기를 키우면 상수 개선

  3. 합치기 비용은?
     이것이 전체 복잡도를 결정!
     ├─ O(1): 이진 탐색 → O(log n)
     ├─ O(n): 병합 정렬 → O(n log n)
     ├─ O(n²): Strassen → O(n^2.81)
     └─ O(n²): 일반 행렬 → O(n³)

  4. 부분 문제가 독립적인가?
     ├─ 독립: 병렬화 가능 (ad-13)
     └─ 중복: DP가 더 적합 (ad-02)

  분할 정복 vs DP:
  부분 문제 중복 없음 → 분할 정복
  부분 문제 중복 있음 → DP (메모이제이션)
```

분할 정복은 ad-02~03의 DP와 비교되며, ad-13의 병렬 알고리즘에서 자연스러운 병렬화 대상이 됩니다. Karatsuba는 la-01의 행렬 곱셈 효율화와 연결됩니다.

## 핵심 정리

- 분할 정복은 **나누기(Divide) → 정복(Conquer) → 합치기(Combine)**의 3단계이며, 합치기 비용이 전체 복잡도를 결정합니다
- **Master Theorem** $T(n) = aT(n/b) + f(n)$에서 $n^{\log_b a}$와 $f(n)$의 대소 비교로 복잡도를 즉시 판단합니다
- **Karatsuba**는 4번 곱셈을 3번으로 줄여 $O(n^{1.585})$를 달성하며, "하나의 곱셈을 덧셈으로 대체"하는 핵심 트릭을 보여줍니다
- **최근접 점 쌍**은 strip 내 점들의 기하학적 성질로 O(N) 합치기를 달성하여 전체 $O(N \log N)$을 만듭니다
- **Strassen**은 8번 행렬 곱셈을 7번으로 줄여 $O(n^{2.81})$를 달성하며, 분할 정복에서 곱셈 횟수 감소의 위력을 보여줍니다
