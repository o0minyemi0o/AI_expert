# 코딩 인터뷰 전략

## 왜 코딩 인터뷰 전략이 중요한가

코딩 인터뷰는 단순히 알고리즘을 아는 것만으로는 통과할 수 없습니다. 제한된 시간 안에 문제를 정확히 분류하고, 최적의 접근법을 선택하며, 명확하게 커뮤니케이션하는 **체계적인 전략**이 필요합니다. 이 강의에서는 코딩 인터뷰 전반에 걸친 프레임워크를 제시합니다.

> **핵심 직관**: 코딩 인터뷰는 "정답을 아느냐"가 아니라 "모르는 문제를 어떻게 풀어가느냐"를 평가하는 과정입니다.

## 1. 문제 유형 분류 체계

코딩 인터뷰 문제는 크게 다음과 같은 유형으로 분류할 수 있습니다.

| 유형 | 핵심 패턴 | 대표 예시 | 관련 강의 |
|------|-----------|-----------|-----------|
| 배열/해시맵 | 투 포인터, 슬라이딩 윈도우 | Two Sum, 최대 부분합 | coi-02 |
| 문자열 | 패턴 매칭, 변환 | 아나그램, 팰린드롬 | coi-03 |
| 스택/큐 | 모노톤 스택, BFS | 괄호 매칭, 히스토그램 | coi-04 |
| 트리/그래프 | DFS/BFS, 위상 정렬 | 경로 탐색, 사이클 탐지 | coi-05 |
| DP | 메모이제이션, 상태 전이 | 배낭, LIS | coi-06, coi-07 |
| 그리디/이분탐색 | 최적 선택, 파라메트릭 | 활동 선택, 결정 문제 | coi-08 |
| 백트래킹 | 가지치기, 조합 생성 | N-Queens, 순열 | coi-09 |

## 2. 시간 복잡도 분석 프레임워크

문제를 풀기 전, 입력 크기 `n`을 보고 허용 가능한 시간 복잡도를 역추산하는 습관이 중요합니다.

| 입력 크기 (n) | 허용 복잡도 | 전형적 알고리즘 |
|---------------|------------|----------------|
| n <= 10 | O(n!) | 완전 탐색, 백트래킹 |
| n <= 20 | O(2^n) | 비트마스크 DP, 부분집합 |
| n <= 500 | O(n^3) | 플로이드-워셜, 구간 DP |
| n <= 5,000 | O(n^2) | 단순 DP, 이중 루프 |
| n <= 100,000 | O(n log n) | 정렬 기반, 세그먼트 트리 |
| n <= 1,000,000 | O(n) | 해시맵, 투 포인터 |
| n <= 10^9 | O(log n) | 이분 탐색, 수학적 풀이 |

> **핵심 직관**: "입력 크기를 보고 복잡도를 역산하면, 사용 가능한 알고리즘이 자동으로 좁혀집니다."

## 3. 문제 풀이 5단계 프레임워크

코딩 인터뷰에서는 다음 5단계를 순서대로 따르는 것이 효과적입니다.

```
┌─────────────────────────────────────────────────┐
│           코딩 인터뷰 5단계 프레임워크              │
├─────────────────────────────────────────────────┤
│                                                 │
│  1. 이해(Understand)                             │
│     └─ 입력/출력 명확화, 엣지 케이스 질문           │
│          │                                      │
│          ▼                                      │
│  2. 분류(Classify)                               │
│     └─ 문제 유형 식별, 유사 패턴 매핑              │
│          │                                      │
│          ▼                                      │
│  3. 설계(Design)                                 │
│     └─ 브루트포스 → 최적화, 복잡도 분석            │
│          │                                      │
│          ▼                                      │
│  4. 구현(Implement)                              │
│     └─ 클린 코드, 변수명 명확화                    │
│          │                                      │
│          ▼                                      │
│  5. 검증(Verify)                                 │
│     └─ 테스트 케이스, 엣지 케이스 확인              │
│                                                 │
└─────────────────────────────────────────────────┘
```

## 4. 접근법 선택 결정 트리

문제를 읽고 어떤 알고리즘을 적용할지 결정하는 흐름입니다.

```
문제 읽기
  │
  ├─ "최소/최대를 구하라" ──────→ DP or 그리디 (coi-06, coi-08)
  │
  ├─ "모든 경우를 구하라" ──────→ 백트래킹 (coi-09)
  │
  ├─ "존재 여부를 판단하라" ────→ 해시맵 or 이분탐색 (coi-02, coi-08)
  │
  ├─ "연결 관계가 있다" ────────→ 그래프 탐색 (coi-05)
  │
  ├─ "순서가 있다" ─────────────→ 위상 정렬 or 스택 (coi-04, coi-05)
  │
  └─ "구간/연속 부분" ──────────→ 슬라이딩 윈도우 or 투 포인터 (coi-02)
```

## 5. 실전 시나리오: Two Sum 변형 문제

**문제**: 정렬된 배열에서 합이 target인 두 수의 인덱스를 찾으시오.

```python
# 접근 1: 해시맵 — O(n) 시간, O(n) 공간
def two_sum_hash(nums: list[int], target: int) -> list[int]:
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []

# 접근 2: 투 포인터 (정렬된 배열) — O(n) 시간, O(1) 공간
def two_sum_sorted(nums: list[int], target: int) -> list[int]:
    left, right = 0, len(nums) - 1
    while left < right:
        curr_sum = nums[left] + nums[right]
        if curr_sum == target:
            return [left, right]
        elif curr_sum < target:
            left += 1
        else:
            right -= 1
    return []
```

| 접근법 | 시간 복잡도 | 공간 복잡도 | 정렬 필요 |
|--------|-----------|-----------|----------|
| 브루트포스 | O(n^2) | O(1) | X |
| 해시맵 | O(n) | O(n) | X |
| 투 포인터 | O(n) | O(1) | O |

> **핵심 직관**: 동일 문제에 대해 여러 접근법을 제시하고 트레이드오프를 설명하는 것이 면접에서 높은 평가를 받는 핵심입니다.

## 6. 시간 관리 전략

45분 기준 코딩 인터뷰에서의 시간 배분입니다.

| 단계 | 시간 | 핵심 활동 |
|------|------|-----------|
| 이해 & 질문 | 5분 | 입력/출력 확인, 제약 조건 질문 |
| 접근법 설계 | 10분 | 브루트포스 → 최적화, 복잡도 분석 |
| 코드 작성 | 20분 | 핵심 로직 구현, 헬퍼 함수 분리 |
| 테스트 & 디버깅 | 10분 | 일반/엣지 케이스 검증 |

## 7. 흔한 실수와 대응 전략

```
실수 유형                    대응 전략
─────────────────────────────────────────────────
바로 코딩 시작              → 반드시 설계 먼저, 수도코드 작성
엣지 케이스 무시            → 빈 입력, 단일 원소, 음수 체크
변수명 불명확               → 의미 있는 이름 사용 (i,j 대신)
침묵하며 코딩               → 생각 과정을 말로 설명
최적화에 집착               → 브루트포스 먼저, 점진적 개선
```

algorithms 과정(advanced-data-structures, graph-algorithms, algorithm-design)에서 학습한 자료구조와 알고리즘 지식은 이 코딩 인터뷰 과정에서 실전 적용 능력으로 전환됩니다. Python 고급 문법(py- 시리즈)을 숙지하면 구현 속도가 크게 향상됩니다.

## 핵심 정리

- 문제를 읽자마자 코딩하지 말고, **유형 분류 → 접근법 선택 → 설계 → 구현** 순서를 따릅니다
- 입력 크기 `n`으로부터 **허용 가능한 시간 복잡도를 역산**하여 알고리즘을 좁힙니다
- 하나의 문제에 대해 **브루트포스 → 최적화** 단계를 밟으며 트레이드오프를 설명합니다
- 면접 중 **생각 과정을 소리 내어 말하는 습관**이 평가에 결정적 영향을 미칩니다
- 45분 인터뷰에서 **시간 배분**(이해 5분, 설계 10분, 구현 20분, 검증 10분)을 엄격히 지킵니다
