# 디자인 패턴 for ML

## 왜 디자인 패턴이 중요한가

ML 코드베이스는 다양한 모델, 전처리기, 데이터소스를 교체하며 실험하는 것이 일상입니다. 디자인 패턴은 이러한 교체와 확장을 체계적으로 관리하는 검증된 방법론입니다. 패턴을 알면 팀원 간 의사소통도 "Strategy 패턴으로 모델을 교체합시다"처럼 간결해집니다.

> **핵심 직관**: 디자인 패턴은 외워서 적용하는 것이 아니라, 반복되는 문제를 인식했을 때 자연스럽게 떠올려야 하는 해법입니다.

## 1. Strategy 패턴 — 알고리즘 교체

가장 빈번하게 사용되는 패턴입니다. 모델, 전처리 방식, 평가 메트릭 등을 런타임에 교체할 수 있게 합니다.

```python
from abc import ABC, abstractmethod
from typing import Protocol
import numpy as np

# Protocol을 활용한 Strategy 정의 (py-04 덕 타이핑 참조)
class Preprocessor(Protocol):
    def transform(self, X: np.ndarray) -> np.ndarray: ...

class StandardScaler:
    def transform(self, X: np.ndarray) -> np.ndarray:
        return (X - X.mean(axis=0)) / X.std(axis=0)

class MinMaxScaler:
    def transform(self, X: np.ndarray) -> np.ndarray:
        return (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0))

class Pipeline:
    def __init__(self, preprocessor: Preprocessor):
        self.preprocessor = preprocessor  # Strategy 주입

    def run(self, X: np.ndarray) -> np.ndarray:
        return self.preprocessor.transform(X)
```

## 2. Factory 패턴 — 객체 생성 캡슐화

설정 파일에서 문자열로 모델 이름을 받아 해당 객체를 생성하는 시나리오에 적합합니다.

```python
from typing import Any

class ModelFactory:
    """설정 기반 모델 생성 (se-04 Hydra 설정과 연동)"""
    _registry: dict[str, type] = {}

    @classmethod
    def register(cls, name: str):
        def decorator(model_cls: type):
            cls._registry[name] = model_cls
            return model_cls
        return decorator

    @classmethod
    def create(cls, name: str, **kwargs: Any):
        if name not in cls._registry:
            raise ValueError(f"Unknown model: {name}")
        return cls._registry[name](**kwargs)

@ModelFactory.register("xgboost")
class XGBoostModel:
    def __init__(self, n_estimators: int = 100): ...

@ModelFactory.register("lightgbm")
class LightGBMModel:
    def __init__(self, num_leaves: int = 31): ...

# 설정에서 문자열로 모델 생성
model = ModelFactory.create("xgboost", n_estimators=200)
```

> **핵심 직관**: Factory + Registry 패턴은 Hydra, PyTorch Lightning 등 주요 ML 프레임워크의 핵심 설계 방식입니다. 설정 파일 하나로 전체 실험을 제어할 수 있게 해줍니다.

## 3. Observer 패턴 — 이벤트 기반 콜백

학습 루프에서 로깅, 체크포인팅, 얼리스토핑 등을 깔끔하게 분리합니다. PyTorch Lightning의 Callback 시스템이 대표적인 예입니다.

```python
class TrainingCallback:
    def on_epoch_start(self, epoch: int) -> None: ...
    def on_epoch_end(self, epoch: int, metrics: dict) -> None: ...
    def on_train_end(self, metrics: dict) -> None: ...

class MetricsLogger(TrainingCallback):
    def on_epoch_end(self, epoch: int, metrics: dict) -> None:
        print(f"[Epoch {epoch}] loss={metrics['loss']:.4f}")

class EarlyStopping(TrainingCallback):
    def __init__(self, patience: int = 5):
        self.patience = patience
        self.best_loss = float("inf")
        self.counter = 0

    def on_epoch_end(self, epoch: int, metrics: dict) -> None:
        if metrics["loss"] < self.best_loss:
            self.best_loss = metrics["loss"]
            self.counter = 0
        else:
            self.counter += 1

class Trainer:
    def __init__(self, callbacks: list[TrainingCallback]):
        self.callbacks = callbacks

    def fit(self, data):
        for epoch in range(100):
            for cb in self.callbacks:
                cb.on_epoch_start(epoch)
            metrics = self._train_one_epoch(data)
            for cb in self.callbacks:
                cb.on_epoch_end(epoch, metrics)
```

## 4. Template Method 패턴 — 학습 루프 골격

학습 루프의 전체 흐름은 고정하되, 세부 단계를 서브클래스에서 오버라이드합니다.

| 패턴 | 교체 단위 | ML 사용 예 |
|------|----------|-----------|
| Strategy | 알고리즘 전체 | 전처리기, 모델, 옵티마이저 |
| Factory | 객체 생성 | 설정 기반 모델 인스턴스화 |
| Observer | 이벤트 핸들러 | 콜백, 로거, 체크포인터 |
| Template Method | 단계별 구현 | 학습 루프, 데이터 파이프라인 |
| Decorator | 기능 추가 | 캐싱, 로깅, 재시도 래퍼 |

```python
class BaseTrainer:
    """Template Method: 학습 루프의 골격 정의"""
    def train(self, epochs: int):
        self.setup()
        for epoch in range(epochs):
            train_loss = self.train_epoch()
            val_loss = self.validate()
            self.log_metrics(epoch, train_loss, val_loss)
        self.teardown()

    def setup(self) -> None: ...
    def teardown(self) -> None: ...
    def train_epoch(self) -> float: raise NotImplementedError
    def validate(self) -> float: raise NotImplementedError
    def log_metrics(self, epoch, train_loss, val_loss) -> None: ...
```

## 5. Decorator 패턴 — 횡단 관심사 처리

로깅, 캐싱, 재시도 등 여러 컴포넌트에 공통적으로 적용되는 기능을 분리합니다 (se-07 에러 처리 참조).

```python
import functools
import time

def log_execution(func):
    """함수 실행 시간과 결과를 로깅하는 데코레이터"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        result = func(*args, **kwargs)
        elapsed = time.perf_counter() - start
        print(f"{func.__name__} completed in {elapsed:.2f}s")
        return result
    return wrapper

def cache_result(path: str):
    """중간 결과를 캐싱하는 데코레이터"""
    @functools.wraps
    def decorator(func):
        def wrapper(*args, **kwargs):
            if Path(path).exists():
                return joblib.load(path)
            result = func(*args, **kwargs)
            joblib.dump(result, path)
            return result
        return wrapper
    return decorator
```

### 시나리오: 패턴 선택 의사결정

새로운 전처리 방식을 실험하고 싶습니다. 어떤 패턴을 쓸까요?

```
패턴 선택 흐름:
┌───────────────────────────┐
│ 무엇을 교체/확장하려는가? │
├───────┬───────┬───────────┤
│ 알고리즘 │ 생성방식 │ 이벤트반응 │
│       │       │           │
│ Strategy│Factory│ Observer  │
│       │       │           │
│ 런타임  │ 설정  │ 콜백      │
│ 교체    │ 기반  │ 시스템    │
└───────┴───────┴───────────┘
```

### 시나리오: 실제 ML 파이프라인에서의 패턴 조합

실제 프로젝트에서는 패턴을 단독으로 사용하기보다 조합합니다. Factory로 모델을 생성하고, Strategy로 전처리기를 교체하며, Observer로 학습 과정을 모니터링하는 것이 일반적인 구성입니다.

```python
# 패턴 조합 예시
config = load_config("experiment.yaml")  # se-04 참조

model = ModelFactory.create(config.model.name, **config.model.params)
preprocessor = PreprocessorFactory.create(config.preprocessing.name)
callbacks = [MetricsLogger(), EarlyStopping(patience=config.early_stopping)]

trainer = Trainer(model=model, preprocessor=preprocessor, callbacks=callbacks)
trainer.fit(data)
```

Python의 고급 기능(Protocol, 데코레이터, 메타클래스)을 디자인 패턴과 결합하는 방법은 py-04와 py-06을 참조하십시오. 이 패턴들의 테스트 전략은 se-03에서 다룹니다.

## 핵심 정리

- **Strategy 패턴**: 모델, 전처리기 등 교체 가능한 알고리즘을 Protocol 또는 ABC로 정의하여 런타임에 유연하게 교체합니다
- **Factory + Registry**: 설정 파일의 문자열에서 객체를 생성하는 패턴으로, 실험 관리 자동화의 기반입니다
- **Observer/Callback**: 학습 루프의 핵심 로직과 부가 기능(로깅, 얼리스토핑)을 분리하여 독립적으로 관리합니다
- **Template Method**: 학습 루프 같은 고정된 프로세스의 골격을 정의하고, 세부 구현만 서브클래스에 위임합니다
- **패턴 조합**: 실제 ML 프로젝트에서는 단일 패턴보다 Factory + Strategy + Observer 등을 조합하여 사용합니다
