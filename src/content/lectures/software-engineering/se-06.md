# 패키징과 의존성 관리

## 왜 패키징과 의존성 관리가 중요한가

"pip install 하니까 기존 패키지가 깨졌습니다." ML 프로젝트는 특히 의존성이 복잡합니다. PyTorch, TensorFlow, CUDA, numpy 등이 서로 특정 버전을 요구하며, 이들 사이의 충돌을 관리하지 않으면 환경 자체가 무너집니다. 올바른 패키징은 코드의 재사용성과 배포 가능성을 결정합니다.

> **핵심 직관**: 의존성 관리의 핵심은 "내 코드가 어떤 환경에서든 동일하게 동작한다"는 보장을 제공하는 것입니다.

## 1. pyproject.toml — 현대적 Python 프로젝트 설정

`setup.py`와 `setup.cfg`의 시대는 지나갔습니다. `pyproject.toml`은 PEP 621에 의해 표준화된 통합 설정 파일입니다.

```toml
# pyproject.toml
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "ml-pipeline"
version = "0.1.0"
description = "ML 학습 파이프라인"
requires-python = ">=3.10"
dependencies = [
    "numpy>=1.24,<2.0",
    "pandas>=2.0",
    "scikit-learn>=1.3",
    "torch>=2.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0",
    "ruff>=0.5.0",
    "mypy>=1.10",
    "pre-commit>=3.0",
]
gpu = [
    "torch[cuda]>=2.0",
]

[project.scripts]
train = "ml_pipeline.cli:train"
evaluate = "ml_pipeline.cli:evaluate"
```

## 2. 의존성 관리 도구 비교

| 도구 | 속도 | 의존성 해결 | lock 파일 | 가상환경 관리 | 적합한 상황 |
|------|------|-----------|----------|-------------|-----------|
| pip + venv | 보통 | 기본적 | requirements.txt | 수동 | 간단한 프로젝트 |
| Poetry | 보통 | 강력 | poetry.lock | 자동 | 라이브러리 개발 |
| uv | 매우 빠름 | 강력 | uv.lock | 자동 | 새 프로젝트 권장 |
| conda | 느림 | 시스템 포함 | environment.yml | 자동 | CUDA/시스템 의존성 |

### uv — 차세대 패키지 관리자

uv는 Rust로 작성된 초고속 패키지 관리자로, pip 대비 10~100배 빠릅니다.

```bash
# uv 기본 사용법
uv init ml-pipeline              # 프로젝트 초기화
uv add numpy pandas torch        # 의존성 추가
uv add --dev pytest ruff mypy    # 개발 의존성 추가
uv sync                          # lock 파일 기반 설치
uv run python train.py           # 가상환경 내에서 실행
uv run pytest tests/             # 테스트 실행
```

### Poetry 사용법

```bash
# Poetry 기본 사용법
poetry init                      # 프로젝트 초기화
poetry add numpy pandas torch    # 의존성 추가
poetry add --group dev pytest    # 개발 의존성 추가
poetry install                   # lock 파일 기반 설치
poetry run python train.py       # 가상환경 내에서 실행
```

> **핵심 직관**: lock 파일은 반드시 버전 관리에 포함하십시오. `pyproject.toml`은 "원하는 버전 범위"를, lock 파일은 "실제 설치된 정확한 버전"을 기록합니다.

## 3. 가상환경 전략

```
환경 격리 수준 비교:
┌────────────────────────────────────────┐
│           Docker 컨테이너              │  ← 가장 강력한 격리
│  ┌──────────────────────────────────┐  │
│  │         conda 환경               │  │  ← 시스템 라이브러리 포함
│  │  ┌────────────────────────────┐  │  │
│  │  │       venv / uv           │  │  │  ← Python 패키지 격리
│  │  │  ┌──────────────────────┐ │  │  │
│  │  │  │    프로젝트 코드      │ │  │  │
│  │  │  └──────────────────────┘ │  │  │
│  │  └────────────────────────────┘  │  │
│  └──────────────────────────────────┘  │
└────────────────────────────────────────┘
```

### 시나리오: CUDA 버전 충돌

프로젝트 A는 CUDA 11.8, 프로젝트 B는 CUDA 12.1을 요구합니다. 이 경우 conda 또는 Docker 수준의 격리가 필요합니다.

```bash
# conda로 CUDA 포함 환경 관리
conda create -n project-a python=3.11 pytorch pytorch-cuda=11.8 -c pytorch -c nvidia
conda create -n project-b python=3.11 pytorch pytorch-cuda=12.1 -c pytorch -c nvidia
```

## 4. Docker — 완전한 환경 재현

```dockerfile
# Dockerfile
FROM python:3.11-slim AS base

WORKDIR /app

# 시스템 의존성 (변경 빈도 낮음 → 캐시 활용)
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# 의존성 설치 (코드 변경 시 재설치 방지)
COPY pyproject.toml uv.lock ./
RUN pip install uv && uv sync --frozen --no-dev

# 소스 코드 복사
COPY src/ ./src/

# 멀티스테이지 빌드: 학습용
FROM base AS training
COPY configs/ ./configs/
CMD ["uv", "run", "python", "-m", "ml_pipeline.train"]

# 멀티스테이지 빌드: 서빙용
FROM base AS serving
RUN uv add fastapi uvicorn
COPY serve.py .
CMD ["uv", "run", "uvicorn", "serve:app", "--host", "0.0.0.0"]
```

```yaml
# docker-compose.yml
services:
  training:
    build:
      context: .
      target: training
    volumes:
      - ./data:/app/data
      - ./outputs:/app/outputs
    deploy:
      resources:
        reservations:
          devices:
            - capabilities: [gpu]
```

> **핵심 직관**: Dockerfile에서 변경 빈도가 낮은 레이어(의존성)를 위에, 변경 빈도가 높은 레이어(소스 코드)를 아래에 배치하면 빌드 캐시를 최대한 활용할 수 있습니다.

## 5. 의존성 충돌 해결

### 시나리오: numpy 2.0 호환성 문제

numpy 2.0이 출시되면서 기존 코드가 깨지는 상황이 빈번합니다.

```
의존성 충돌 해결 흐름:
┌──────────────────────┐
│ 충돌 발생             │
├──────────────────────┤
│ 1. 에러 메시지 분석   │
│    어떤 패키지가       │
│    어떤 버전을 요구?   │
│         ↓             │
│ 2. 호환 버전 범위 탐색 │
│    pip index versions │
│    패키지명            │
│         ↓             │
│ 3. 상한/하한 조정     │
│    numpy>=1.24,<2.0   │
│         ↓             │
│ 4. lock 파일 재생성   │
│    uv lock / poetry   │
│    lock               │
└──────────────────────┘
```

```bash
# 의존성 트리 확인
uv tree                        # uv 사용 시
pip install pipdeptree && pipdeptree  # pip 사용 시

# 특정 패키지의 의존성 확인
uv pip show torch
```

Docker와 CI/CD의 통합은 se-08을, 프로젝트 구조에서의 패키징 위치는 se-10을 참조하십시오. MLOps 환경에서의 컨테이너 관리는 mo-04를 참조하십시오.

## 핵심 정리

- **pyproject.toml**: 현대 Python 프로젝트의 표준 설정 파일로, 메타데이터, 의존성, 도구 설정을 한 곳에서 관리합니다
- **uv/Poetry**: lock 파일 기반의 결정적 의존성 관리로, 모든 환경에서 동일한 패키지 버전을 보장합니다
- **가상환경 계층**: venv(패키지 격리) → conda(시스템 포함) → Docker(완전 격리) 순으로 격리 수준을 높입니다
- **Docker 최적화**: 멀티스테이지 빌드와 레이어 캐싱을 활용하여 빌드 시간을 단축하고 이미지 크기를 줄입니다
- **충돌 해결**: 의존성 트리를 분석하고 버전 범위를 조정한 뒤 lock 파일을 재생성하는 체계적 접근이 필요합니다
