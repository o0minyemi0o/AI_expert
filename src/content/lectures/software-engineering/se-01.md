# ML 코드의 설계 원칙

## 왜 설계 원칙이 중요한가

ML 프로젝트는 실험 코드에서 시작하여 프로덕션 시스템으로 성장합니다. 이 과정에서 설계 원칙 없이 작성된 코드는 빠르게 유지보수 불가능한 상태에 도달합니다. 노트북에서 잘 돌아가던 코드가 팀 단위로 확장될 때 무너지는 이유는 대부분 설계 부재에 있습니다.

> **핵심 직관**: ML 코드의 70%는 데이터 전처리, 설정, 인프라 코드입니다. 모델 코드만 잘 짜서는 전체 품질을 보장할 수 없습니다.

## 1. SOLID 원칙의 ML 적용

SOLID 원칙은 객체지향 설계의 근간이지만, ML 코드에 그대로 적용하기엔 맥락이 다릅니다. 각 원칙이 ML 코드베이스에서 어떻게 해석되는지 살펴봅시다.

| 원칙 | 전통 소프트웨어 | ML 코드 적용 |
|------|----------------|-------------|
| SRP (단일 책임) | 클래스는 하나의 책임 | 데이터 로딩, 전처리, 모델, 평가를 분리 |
| OCP (개방-폐쇄) | 확장에 열림, 수정에 닫힘 | 새 모델/전처리를 플러그인처럼 추가 |
| LSP (리스코프 치환) | 하위 타입 교체 가능 | BaseModel 인터페이스 통일 |
| ISP (인터페이스 분리) | 필요한 인터페이스만 의존 | 학습/추론 인터페이스 분리 |
| DIP (의존성 역전) | 추상에 의존 | 구체 데이터소스가 아닌 추상 DataLoader에 의존 |

```python
# SRP 위반 예시: 하나의 클래스가 모든 것을 담당
class ModelPipeline:
    def load_data(self): ...
    def preprocess(self): ...
    def train(self): ...
    def evaluate(self): ...
    def deploy(self): ...

# SRP 준수: 각 책임을 분리
class DataLoader:
    def load(self, path: str) -> pd.DataFrame: ...

class Preprocessor:
    def transform(self, df: pd.DataFrame) -> np.ndarray: ...

class Trainer:
    def fit(self, X: np.ndarray, y: np.ndarray) -> Model: ...
```

## 2. 관심사 분리 (Separation of Concerns)

ML 프로젝트에서 관심사 분리는 특히 중요합니다. 실험 코드와 프로덕션 코드, 데이터 로직과 모델 로직이 뒤섞이면 재현성과 테스트 가능성이 급격히 떨어집니다.

```
┌─────────────────────────────────────────┐
│              ML 프로젝트 계층            │
├─────────────────────────────────────────┤
│  [설정 계층]  config, hyperparameters   │
│       ↓                                 │
│  [데이터 계층]  로딩, 전처리, 검증       │
│       ↓                                 │
│  [모델 계층]  아키텍처, 학습, 추론       │
│       ↓                                 │
│  [평가 계층]  메트릭, 시각화, 리포트     │
│       ↓                                 │
│  [서빙 계층]  API, 배치 추론, 모니터링   │
└─────────────────────────────────────────┘
```

> **핵심 직관**: 각 계층은 아래 계층의 구현 세부사항을 몰라야 합니다. 데이터가 S3에서 오든 로컬에서 오든, 모델 계층은 동일하게 동작해야 합니다.

## 3. 모듈화 전략

### 시나리오: 노트북에서 패키지로

연구원이 Jupyter 노트북 하나에 전체 파이프라인을 작성했습니다. 이를 팀에서 사용할 수 있는 패키지로 전환해야 합니다.

```python
# 모듈화된 프로젝트 구조
# src/
#   data/
#     __init__.py
#     loader.py        # 데이터 로딩 책임
#     transforms.py    # 변환 함수들
#   models/
#     __init__.py
#     base.py          # 추상 인터페이스
#     classifier.py    # 구체 구현
#   evaluation/
#     metrics.py       # 평가 메트릭
#     report.py        # 리포트 생성

from abc import ABC, abstractmethod

class BaseModel(ABC):
    """모든 모델이 구현해야 하는 인터페이스 (LSP, DIP 준수)"""
    @abstractmethod
    def fit(self, X, y) -> "BaseModel": ...

    @abstractmethod
    def predict(self, X) -> np.ndarray: ...

    @abstractmethod
    def save(self, path: str) -> None: ...

    @classmethod
    @abstractmethod
    def load(cls, path: str) -> "BaseModel": ...
```

## 4. 의존성 주입과 설정 분리

하드코딩된 의존성은 테스트와 확장을 어렵게 만듭니다. 의존성 주입을 통해 유연성을 확보합시다.

```python
# 의존성 주입 전: 강결합
class Trainer:
    def __init__(self):
        self.model = XGBoostModel()  # 구체 클래스에 직접 의존
        self.data = S3DataLoader()   # 변경 불가능

# 의존성 주입 후: 약결합
class Trainer:
    def __init__(self, model: BaseModel, data_loader: DataLoader):
        self.model = model
        self.data_loader = data_loader

# 사용 시점에 조립
trainer = Trainer(
    model=XGBoostModel(n_estimators=100),
    data_loader=LocalDataLoader("./data"),
)
```

이 패턴은 테스트 시 Mock 객체를 주입할 수 있게 하여 테스트 가능성을 크게 높입니다 (se-03 참조).

## 5. 실용적 설계 판단 기준

### 시나리오: 과도한 추상화 vs 실용적 설계

모든 곳에 인터페이스를 도입하면 오히려 복잡도가 증가합니다. 실용적 판단 기준이 필요합니다.

```
추상화 도입 판단 흐름:
┌──────────────────────────┐
│ 이 컴포넌트가 2개 이상의  │
│ 구현체를 가질 가능성?     │
├──────┬───────────────────┤
│ YES  │        NO         │
│      │                   │
│ 인터페이스   구체 클래스로 │
│ 도입         충분          │
│      │                   │
│ 향후 교체    YAGNI 원칙   │
│ 용이성 확보  (필요할 때    │
│             추상화)       │
└──────┴───────────────────┘
```

> **핵심 직관**: ML 프로젝트에서는 "실험 속도"와 "코드 품질" 사이의 균형이 핵심입니다. 탐색 단계에서는 빠른 실험을, 확정 후에는 견고한 설계를 적용하십시오.

패키징과 프로젝트 구조에 대한 구체적인 내용은 se-06과 se-10에서 더 깊이 다룹니다. 타입 힌트를 활용한 인터페이스 강화는 se-05를, 설정 관리를 통한 관심사 분리는 se-04를 참조하십시오.

## 핵심 정리

- **SRP**: 데이터 로딩, 전처리, 모델, 평가, 서빙은 반드시 분리하여 각각 독립적으로 테스트 가능하게 합니다
- **DIP**: 구체 구현이 아닌 추상 인터페이스에 의존하면, 모델과 데이터소스를 자유롭게 교체할 수 있습니다
- **관심사 분리**: 실험 코드와 프로덕션 코드를 계층으로 나누어 재현성과 유지보수성을 확보합니다
- **의존성 주입**: 생성자를 통해 의존성을 외부에서 주입하면 테스트 용이성과 유연성이 크게 향상됩니다
- **실용적 판단**: YAGNI 원칙을 기억하되, 확장 가능성이 높은 지점에는 선제적으로 추상화를 도입합니다
