# ML 프로젝트 구조와 협업

## 왜 프로젝트 구조와 협업이 중요한가

ML 프로젝트는 데이터 엔지니어, ML 엔지니어, 연구원, 백엔드 개발자 등 다양한 역할의 사람들이 함께 작업합니다. 일관된 프로젝트 구조와 명확한 협업 규칙이 없으면, 각자의 코드가 충돌하고 통합 비용이 기하급수적으로 증가합니다. 좋은 프로젝트 구조는 팀원이 "어디에 무엇이 있는지"를 직관적으로 알 수 있게 합니다.

> **핵심 직관**: 프로젝트 구조는 팀의 의사소통 방식을 반영합니다. 디렉토리 구조를 보면 팀이 어떻게 일하는지 알 수 있습니다 (Conway의 법칙).

## 1. ML 프로젝트 표준 구조

```
ml-project/
├── .github/
│   └── workflows/          # CI/CD 파이프라인 (se-08)
│       ├── ci.yml
│       └── deploy.yml
├── configs/                # 실험 설정 (se-04)
│   ├── experiment/
│   ├── model/
│   └── data/
├── data/
│   ├── raw/               # 원본 데이터 (Git 미추적)
│   └── processed/         # 전처리된 데이터 (Git 미추적)
├── notebooks/             # 탐색/분석 노트북
│   └── 01_eda.ipynb
├── src/
│   └── ml_pipeline/
│       ├── __init__.py
│       ├── data/          # 데이터 로딩/전처리
│       │   ├── __init__.py
│       │   ├── loader.py
│       │   └── transforms.py
│       ├── models/        # 모델 정의/학습
│       │   ├── __init__.py
│       │   ├── base.py
│       │   └── classifier.py
│       ├── evaluation/    # 평가/리포트
│       │   ├── __init__.py
│       │   └── metrics.py
│       └── serving/       # 추론/API (mo-05)
│           ├── __init__.py
│           └── api.py
├── tests/                 # 테스트 (se-03)
│   ├── conftest.py
│   ├── fixtures/
│   ├── test_data/
│   ├── test_models/
│   └── test_evaluation/
├── scripts/               # 유틸리티 스크립트
│   ├── train.py
│   └── evaluate.py
├── Dockerfile             # 컨테이너 설정 (se-06)
├── pyproject.toml         # 프로젝트 메타데이터 (se-06)
├── uv.lock
├── .pre-commit-config.yaml # 코드 품질 (se-05)
├── .gitignore
└── README.md
```

| 디렉토리 | 책임 | 변경 빈도 | Git 추적 |
|----------|------|----------|---------|
| configs/ | 실험 설정 | 높음 | 예 |
| data/ | 원본/처리 데이터 | 낮음 | 아니오 (DVC) |
| notebooks/ | 탐색/분석 | 높음 | 선택적 |
| src/ | 핵심 로직 | 보통 | 예 |
| tests/ | 테스트 코드 | 보통 | 예 |
| scripts/ | 실행 진입점 | 낮음 | 예 |

## 2. 모노레포 vs 멀티레포

| 기준 | 모노레포 | 멀티레포 |
|------|---------|---------|
| 코드 공유 | 쉬움 (동일 저장소) | 패키지로 공유 |
| CI 복잡도 | 높음 (경로 기반 필터) | 낮음 (독립 실행) |
| 의존성 관리 | 통합 관리 | 버전 명시 필요 |
| 팀 자율성 | 낮음 | 높음 |
| 적합한 팀 | 5-15명, 강한 결합 | 15명+, 독립 팀 |

```
모노레포 구조 예시:
monorepo/
├── packages/
│   ├── data-pipeline/     # 데이터 팀
│   │   ├── pyproject.toml
│   │   └── src/
│   ├── model-training/    # ML 팀
│   │   ├── pyproject.toml
│   │   └── src/
│   ├── model-serving/     # 백엔드 팀
│   │   ├── pyproject.toml
│   │   └── src/
│   └── shared/            # 공유 유틸리티
│       ├── pyproject.toml
│       └── src/
└── .github/workflows/
```

### 시나리오: 모노레포에서 경로 기반 CI 트리거

모노레포에서는 변경된 패키지의 CI만 실행해야 효율적입니다.

```yaml
# .github/workflows/model-training-ci.yml
name: Model Training CI
on:
  pull_request:
    paths:
      - 'packages/model-training/**'
      - 'packages/shared/**'  # 공유 코드 변경도 감지
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: cd packages/model-training && uv sync && uv run pytest
```

> **핵심 직관**: 5명 이하 팀이라면 모노레포로 시작하십시오. 팀과 코드가 성장하면서 경계가 명확해지면 그때 분리해도 늦지 않습니다.

## 3. Git 전략

### 브랜치 전략 비교

| 전략 | 복잡도 | 적합한 상황 |
|------|-------|-----------|
| GitHub Flow | 낮음 | 소규모 팀, 지속 배포 |
| Git Flow | 높음 | 릴리스 주기 명확한 프로젝트 |
| Trunk-Based | 보통 | 대규모 팀, 짧은 브랜치 |

```
GitHub Flow (ML 프로젝트 권장):
main ─────●──────●──────●──────●──────
           \    /        \    /
 feature    ●──●          ●──●
 branch   (실험 A)      (실험 B)
```

### 커밋 메시지 컨벤션

```bash
# Conventional Commits 형식
feat(model): LightGBM 모델 추가
fix(data): 결측값 처리 로직 수정
refactor(pipeline): 학습 루프 함수 분리
test(model): 단일 배치 과적합 테스트 추가
docs(readme): 설치 가이드 업데이트
ci(actions): 모델 성능 체크 워크플로 추가
```

### ML 프로젝트의 .gitignore

```gitignore
# 데이터 (DVC로 관리)
data/raw/
data/processed/
*.csv
*.parquet

# 모델 가중치
*.pt
*.ckpt
*.pkl
*.joblib

# 실험 출력
outputs/
mlruns/
wandb/

# 환경
.venv/
__pycache__/
*.egg-info/

# 노트북 체크포인트
.ipynb_checkpoints/

# 시크릿
.env
*.key
```

## 4. 팀 협업 패턴

### 코드 오너십

```yaml
# .github/CODEOWNERS
# 데이터 파이프라인 변경은 데이터 팀 리뷰 필요
/src/ml_pipeline/data/    @data-team

# 모델 코드는 ML 팀 리뷰 필요
/src/ml_pipeline/models/  @ml-team

# CI/CD 변경은 플랫폼 팀 리뷰 필요
/.github/                 @platform-team

# 설정 변경은 ML 팀 리뷰 필요
/configs/                 @ml-team
```

### 시나리오: 실험 브랜치와 코드 리뷰

연구원이 새 모델 아키텍처를 실험합니다. 실험 코드와 프로덕션 코드의 경계를 어떻게 관리할까요?

```
실험 → 프로덕션 전환 흐름:
┌──────────────────────────────────┐
│ 1. 실험 브랜치 생성              │
│    feat/experiment-new-model     │
│         ↓                        │
│ 2. 노트북에서 프로토타이핑       │
│    notebooks/new_model_exp.ipynb │
│         ↓                        │
│ 3. 성능 확인 후 코드화           │
│    src/ml_pipeline/models/new.py │
│         ↓                        │
│ 4. 테스트 작성                   │
│    tests/test_models/test_new.py │
│         ↓                        │
│ 5. PR + 코드 리뷰               │
│    팀 리뷰 후 merge              │
└──────────────────────────────────┘
```

> **핵심 직관**: 실험 노트북은 "탐색의 도구"이지 "프로덕션 코드의 대체"가 아닙니다. 실험이 성공하면 반드시 모듈화된 코드로 전환하십시오 (se-09 참조).

## 5. 문서화와 온보딩

### 프로젝트 README 구성

```markdown
# 프로젝트명

## Quick Start
1. `uv sync` — 의존성 설치
2. `uv run python scripts/train.py` — 학습 실행
3. `uv run pytest` — 테스트 실행

## 프로젝트 구조
(위의 디렉토리 구조 설명)

## 개발 가이드
- 브랜치 네이밍: `feat/`, `fix/`, `refactor/`
- 커밋: Conventional Commits
- PR 리뷰: CODEOWNERS 기반 자동 할당

## 실험 관리
- 설정: `configs/` 디렉토리
- 실행: `uv run python scripts/train.py experiment=my_exp`
- 결과: `outputs/` 디렉토리
```

```
팀원 온보딩 체크리스트:
┌─────────────────────────────────┐
│ Day 1                           │
│ □ 저장소 클론 및 환경 설정       │
│ □ README 숙지                   │
│ □ 테스트 전체 실행 확인          │
│                                 │
│ Day 2-3                         │
│ □ 기존 실험 하나 재현            │
│ □ 작은 버그 수정 PR 제출         │
│ □ 코드 리뷰 참여                │
│                                 │
│ Week 2                          │
│ □ 새 실험 독립 수행              │
│ □ 코드 리뷰어로 참여             │
└─────────────────────────────────┘
```

본 강의의 설계 원칙은 se-01을, 테스트 전략은 se-03을, 설정 관리는 se-04를, CI/CD는 se-08을 참조하십시오. MLOps와의 통합은 mo-01에서 전체적인 그림을 확인할 수 있습니다.

## 핵심 정리

- **표준 구조**: configs, src, tests, scripts, data를 분리하여 팀원 누구나 "어디에 무엇이 있는지" 직관적으로 파악할 수 있게 합니다
- **레포 전략**: 소규모 팀은 모노레포로 시작하고, 팀 규모와 독립성이 커지면 멀티레포로 분리합니다
- **Git 전략**: GitHub Flow를 기본으로, Conventional Commits와 CODEOWNERS를 통해 체계적 코드 관리를 합니다
- **실험과 프로덕션 분리**: 노트북은 탐색용, src/는 프로덕션용으로 명확히 구분하고, 성공한 실험만 코드로 전환합니다
- **온보딩 최적화**: 환경 설정 자동화, 명확한 README, 점진적 작업 할당을 통해 새 팀원이 빠르게 기여할 수 있게 합니다
