# 코드 품질과 린팅

## 왜 코드 품질이 중요한가

ML 프로젝트의 코드 품질은 실험 결과의 신뢰성과 직결됩니다. 타입 오류로 인한 잘못된 텐서 연산, 미사용 변수로 인한 혼란, 일관성 없는 코딩 스타일로 인한 코드 리뷰 지연 등은 모두 프로젝트 속도를 떨어뜨립니다. 자동화된 도구로 이 문제들을 해결합시다.

> **핵심 직관**: 코드 품질 도구는 "사람의 눈"을 보조하는 것이지 대체하는 것이 아닙니다. 자동화할 수 있는 것은 도구에 맡기고, 사람은 설계와 로직에 집중하십시오.

## 1. 타입 힌트 — ML 코드의 안전벨트

Python의 동적 타이핑은 유연하지만, ML 코드에서 텐서 차원이나 데이터 타입 불일치를 런타임에서야 발견하게 만듭니다.

```python
# 타입 힌트 없이: 무엇이 들어오고 나가는지 불명확
def preprocess(data, config):
    result = data.apply(config["transform"])
    return result

# 타입 힌트 적용: 의도가 명확
from typing import Any
import pandas as pd
import numpy as np

def preprocess(
    data: pd.DataFrame,
    config: dict[str, Any],
) -> np.ndarray:
    result = data.apply(config["transform"])
    return result.to_numpy()
```

### ML에서 자주 사용하는 타입 패턴

```python
from typing import TypeAlias, Literal
import numpy as np
import torch
from numpy.typing import NDArray

# 타입 별칭으로 가독성 향상
BatchSize: TypeAlias = int
LearningRate: TypeAlias = float
Features: TypeAlias = NDArray[np.float64]
Labels: TypeAlias = NDArray[np.int64]
Device: TypeAlias = Literal["cpu", "cuda", "mps"]

def train_step(
    model: torch.nn.Module,
    X: Features,
    y: Labels,
    lr: LearningRate = 0.001,
    device: Device = "cpu",
) -> dict[str, float]:
    ...
```

## 2. mypy — 정적 타입 검사

mypy는 타입 힌트를 기반으로 코드 실행 전에 타입 오류를 검출합니다.

```toml
# pyproject.toml — mypy 설정
[tool.mypy]
python_version = "3.11"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
check_untyped_defs = true

# 서드파티 라이브러리별 설정
[[tool.mypy.overrides]]
module = ["sklearn.*", "xgboost.*", "lightgbm.*"]
ignore_missing_imports = true
```

```python
# mypy가 잡아주는 오류 예시
def calculate_accuracy(predictions: np.ndarray, labels: np.ndarray) -> float:
    correct = (predictions == labels).sum()
    return correct / len(labels)  # OK: float 반환

def get_model_name(config: dict[str, str]) -> str:
    return config.get("model")  # mypy 에러: Optional[str]을 str로 반환
```

## 3. ruff — 올인원 린터/포매터

ruff는 기존의 flake8, isort, black 등을 하나로 통합한 초고속 린터입니다. Rust로 작성되어 기존 도구 대비 10~100배 빠릅니다.

| 도구 | 역할 | ruff 대체 여부 |
|------|------|---------------|
| flake8 | 스타일 린트 | 완전 대체 |
| isort | import 정렬 | 완전 대체 |
| black | 코드 포맷팅 | 완전 대체 (ruff format) |
| pyupgrade | Python 버전 업그레이드 | 완전 대체 |
| pydocstyle | docstring 린트 | 완전 대체 |

```toml
# pyproject.toml — ruff 설정
[tool.ruff]
target-version = "py311"
line-length = 100

[tool.ruff.lint]
select = [
    "E",    # pycodestyle errors
    "W",    # pycodestyle warnings
    "F",    # pyflakes
    "I",    # isort
    "N",    # pep8-naming
    "UP",   # pyupgrade
    "B",    # flake8-bugbear
    "SIM",  # flake8-simplify
    "TCH",  # flake8-type-checking
]
ignore = ["E501"]  # line-length는 formatter에게 위임

[tool.ruff.lint.per-file-ignores]
"tests/**/*.py" = ["S101"]  # assert 사용 허용
"notebooks/**/*.py" = ["E402"]  # import 순서 예외

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
```

```bash
# ruff 사용법
ruff check src/              # 린트 검사
ruff check src/ --fix        # 자동 수정
ruff format src/             # 코드 포맷팅
```

> **핵심 직관**: ruff 하나로 flake8 + isort + black을 모두 대체할 수 있습니다. 도구를 통일하면 설정 관리가 간결해지고 CI 시간이 단축됩니다.

## 4. pre-commit — 커밋 전 자동 검사

pre-commit은 git commit 전에 자동으로 린트와 포맷팅을 실행합니다.

```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.5.0
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.10.0
    hooks:
      - id: mypy
        additional_dependencies: [numpy, torch]

  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files
        args: ['--maxkb=1000']  # 1MB 이상 파일 차단
```

```bash
# 설치 및 실행
pip install pre-commit
pre-commit install              # git hook 등록
pre-commit run --all-files      # 전체 파일 검사
```

### 시나리오: 대용량 데이터 파일 실수 커밋 방지

팀원이 실수로 2GB CSV 파일을 커밋하려 합니다. pre-commit의 `check-added-large-files` 훅이 이를 차단합니다.

```
커밋 시 자동 실행 흐름:
┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐
│ git add  │──→│ ruff     │──→│ ruff     │──→│ mypy     │
│          │   │ check    │   │ format   │   │ 타입검사  │
└──────────┘   └────┬─────┘   └────┬─────┘   └────┬─────┘
                    │              │              │
               ┌────┴─────┐  ┌────┴─────┐  ┌────┴─────┐
               │ 통과/실패 │  │ 자동수정  │  │ 통과/실패 │
               └──────────┘  └──────────┘  └──────────┘
                                                │
                                          ┌─────┴──────┐
                                          │ git commit │
                                          │ (성공/차단) │
                                          └────────────┘
```

## 5. 코드 리뷰 체크리스트

### 시나리오: ML 코드 리뷰에서 놓치기 쉬운 포인트

자동화 도구가 잡지 못하는 ML 고유의 품질 문제가 있습니다.

| 카테고리 | 체크 항목 | 자동화 가능 |
|---------|----------|-----------|
| 데이터 누수 | 테스트 데이터가 학습에 포함되었는가 | 부분적 |
| 전처리 일관성 | 학습/추론 시 동일한 전처리를 사용하는가 | 아니오 |
| 메트릭 올바름 | 불균형 데이터에 accuracy만 사용하지 않는가 | 아니오 |
| 시드 고정 | 재현성을 위한 시드가 설정되어 있는가 | 예 (se-04) |
| 리소스 관리 | GPU 메모리 누수가 없는가 | 부분적 |
| 타입 안전성 | 텐서 차원과 타입이 일치하는가 | 예 (mypy) |

> **핵심 직관**: 코드 리뷰에서 스타일 지적에 시간을 낭비하지 마십시오. 스타일은 ruff에게, 타입은 mypy에게 맡기고, 사람은 로직과 설계를 검토하는 데 집중하십시오.

린팅 규칙을 CI/CD에 통합하는 방법은 se-08을 참조하십시오. Python 타입 시스템의 심화 내용은 py-04를 참조하십시오.

## 핵심 정리

- **타입 힌트**: ML 코드에 타입 힌트를 추가하면 텐서 차원 불일치 등의 오류를 실행 전에 발견할 수 있습니다
- **mypy**: 정적 타입 검사로 런타임 에러를 컴파일 타임에 잡으며, 서드파티 라이브러리는 `ignore_missing_imports`로 관리합니다
- **ruff**: flake8 + isort + black을 하나로 통합한 초고속 도구로, 단일 설정 파일로 모든 린팅을 관리합니다
- **pre-commit**: 커밋 전에 린트, 포맷팅, 타입 검사를 자동 실행하여 저품질 코드가 저장소에 들어오는 것을 방지합니다
- **코드 리뷰**: 자동화 도구가 스타일과 타입을 검사하고, 사람은 데이터 누수, 전처리 일관성 등 ML 고유 문제에 집중합니다
