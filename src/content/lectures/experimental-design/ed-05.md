# 다중 처치와 팩토리얼 설계

## 왜 여러 처치를 동시에 검증하는가

실무에서 한 번에 하나의 변형만 테스트하는 것은 비효율적입니다. 버튼 색상과 크기를 동시에 최적화하고 싶다면, 각각 별도의 A/B 테스트를 순차적으로 수행하는 것보다 팩토리얼 설계로 동시에 실험하는 것이 훨씬 효율적입니다. ed-01에서 소개한 팩토리얼 설계를 본격적으로 다루며, 상호작용 효과의 중요성과 다중 비교 보정 전략을 학습합니다.

---

## 1. 다중 처치 실험의 구조

다중 처치(multi-arm) 실험에서는 하나의 통제 집단과 여러 처치 집단을 동시에 비교합니다.

| 설계 유형 | 비교 구조 | 예시 |
|-----------|-----------|------|
| A/B 테스트 | 1 통제 vs 1 처치 | 기존 버튼 vs 빨간 버튼 |
| A/B/C 테스트 | 1 통제 vs 2 처치 | 기존 vs 빨간 vs 파란 |
| A/B/n 테스트 | 1 통제 vs $n-1$ 처치 | 기존 vs $n-1$개 변형 |

$K$개 집단의 전체 비교 수는 다음과 같습니다.

$$\binom{K}{2} = \frac{K(K-1)}{2}$$

| 집단 수($K$) | 쌍별 비교 수 | 비보정 위양성 확률 |
|-------------|-------------|-------------------|
| 3 | 3 | 14.3% |
| 5 | 10 | 40.1% |
| 10 | 45 | 90.1% |

> **핵심 직관**: 집단 수가 증가하면 비교 횟수가 이차적으로 증가하며, 다중 비교 보정 없이는 위양성이 폭증합니다.

---

## 2. 다중 비교 보정

ed-02에서 다룬 다중 비교 문제를 체계적으로 해결하는 방법입니다.

### 2.1 가족별 오류율 (FWER) 제어

| 방법 | 수식 | 특성 |
|------|------|------|
| Bonferroni | $\alpha_j = \alpha / m$ | 보수적, 간단 |
| Holm | 순서 기반 단계적 | 덜 보수적 |
| Hochberg | 역순서 단계적 | Holm보다 검정력 높음 |

### 2.2 위발견율 (FDR) 제어

$$\text{FDR} = E\left[\frac{V}{R \vee 1}\right]$$

여기서 $V$는 위양성 수, $R$은 기각된 가설 수입니다.

```python
import numpy as np
from scipy import stats

def benjamini_hochberg(p_values, alpha=0.05):
    """Benjamini-Hochberg FDR 보정"""
    m = len(p_values)
    sorted_idx = np.argsort(p_values)
    sorted_p = p_values[sorted_idx]

    thresholds = np.arange(1, m + 1) / m * alpha
    rejected = sorted_p <= thresholds

    # 가장 큰 기각 인덱스 찾기
    if rejected.any():
        max_reject = np.max(np.where(rejected)[0])
        rejected[:max_reject + 1] = True
    else:
        rejected[:] = False

    result = np.zeros(m, dtype=bool)
    result[sorted_idx] = rejected
    return result

# 10개 처치 비교: 3개만 실제 효과 있음
np.random.seed(42)
p_values = np.array([0.001, 0.008, 0.015, 0.12, 0.23,
                      0.34, 0.45, 0.56, 0.78, 0.91])

rejected_bonf = p_values < (0.05 / len(p_values))
rejected_bh = benjamini_hochberg(p_values)

print("Bonferroni 기각:", np.where(rejected_bonf)[0])
print("BH FDR 기각:", np.where(rejected_bh)[0])
```

| 방법 | FWER 제어 | FDR 제어 | 검정력 |
|------|-----------|----------|--------|
| Bonferroni | 엄격 | 엄격 | 낮음 |
| Holm | 엄격 | 엄격 | 중간 |
| BH | 약함 | 엄격 | 높음 |

> **핵심 직관**: FWER은 "하나라도 틀리면 안 된다"이고, FDR은 "틀린 비율을 관리한다"입니다. 탐색적 분석에서는 FDR이, 확증적 분석에서는 FWER이 적합합니다.

---

## 3. Dunnett 검정: 통제 집단 대비 비교

다중 처치 실험에서 가장 흔한 질문은 "각 처치가 통제보다 나은가?"입니다. Dunnett 검정은 이 특정 구조를 활용하여 Bonferroni보다 높은 검정력을 제공합니다.

$$t_j = \frac{\bar{Y}_j - \bar{Y}_0}{\hat{\sigma}\sqrt{\frac{1}{n_j} + \frac{1}{n_0}}}$$

여기서 $\bar{Y}_0$은 통제 집단 평균, $\bar{Y}_j$는 $j$번째 처치 집단 평균입니다.

```python
import numpy as np
from scipy import stats

np.random.seed(42)
n_per_group = 1000

# 통제 + 4개 처치 집단
control = np.random.normal(10, 3, n_per_group)
treatments = [
    np.random.normal(10.0, 3, n_per_group),  # 효과 없음
    np.random.normal(10.3, 3, n_per_group),  # 약한 효과
    np.random.normal(10.6, 3, n_per_group),  # 중간 효과
    np.random.normal(11.0, 3, n_per_group),  # 강한 효과
]

# 각 처치 vs 통제 비교
for j, treat in enumerate(treatments, 1):
    t_stat, p_val = stats.ttest_ind(treat, control)
    bonf_sig = "유의" if p_val < 0.05/4 else "비유의"
    print(f"처치 {j}: t={t_stat:.3f}, p={p_val:.4f}, Bonferroni: {bonf_sig}")
```

> **핵심 직관**: Dunnett 검정은 비교의 구조(모두 같은 통제 집단과 비교)를 활용하여 상관을 고려하므로, 일반적인 Bonferroni보다 효율적입니다.

---

## 4. 팩토리얼 설계

팩토리얼 설계는 여러 요인(factor)의 조합을 동시에 검증합니다.

### 4.1 $2^k$ 팩토리얼 설계

$k$개 요인이 각각 2수준을 가지면, $2^k$개 처치 조합이 생깁니다.

버튼 색상 A/B 테스트에서 색상(빨강/파랑)과 크기(대/소)를 동시에 검증하는 $2^2$ 설계의 예시입니다.

| 조합 | 색상 | 크기 | 클릭률 |
|------|------|------|--------|
| (1) | 파랑 | 소 | 5.0% |
| a | 빨강 | 소 | 5.8% |
| b | 파랑 | 대 | 6.2% |
| ab | 빨강 | 대 | 7.5% |

주 효과(main effect)는 각 요인의 평균적 영향입니다.

$$\text{색상 주효과} = \frac{(\bar{Y}_{ab} + \bar{Y}_a) - (\bar{Y}_b + \bar{Y}_{(1)})}{2}$$

$$\text{크기 주효과} = \frac{(\bar{Y}_{ab} + \bar{Y}_b) - (\bar{Y}_a + \bar{Y}_{(1)})}{2}$$

```python
import numpy as np
from itertools import product

np.random.seed(42)
n = 2000

# 2^2 팩토리얼: 색상 (0=파랑, 1=빨강), 크기 (0=소, 1=대)
color_effect = 0.008
size_effect = 0.012
interaction = 0.005

results = {}
for c, s in product([0, 1], [0, 1]):
    base = 0.05
    y = np.random.binomial(1, base + c*color_effect + s*size_effect + c*s*interaction, n)
    results[(c, s)] = y.mean()
    label = f"색상={'빨강' if c else '파랑'}, 크기={'대' if s else '소'}"
    print(f"{label}: CTR = {y.mean():.4f}")

# 주 효과 계산
color_main = (results[(1,0)] + results[(1,1)] - results[(0,0)] - results[(0,1)]) / 2
size_main = (results[(0,1)] + results[(1,1)] - results[(0,0)] - results[(1,0)]) / 2
interaction_est = (results[(1,1)] - results[(1,0)] - results[(0,1)] + results[(0,0)])

print(f"\n색상 주효과: {color_main:.4f}")
print(f"크기 주효과: {size_main:.4f}")
print(f"상호작용 효과: {interaction_est:.4f}")
```

> **핵심 직관**: 팩토리얼 설계의 핵심 장점은 동일한 데이터로 주효과와 상호작용 효과를 모두 추정할 수 있다는 것입니다. 별도 실험 대비 효율이 $k$배 향상됩니다.

---

## 5. 상호작용 효과의 해석

상호작용 효과(interaction effect)는 한 요인의 효과가 다른 요인의 수준에 따라 달라지는 현상입니다.

$$\text{상호작용} = \tau_{AB} - \tau_A - \tau_B$$

| 상호작용 유형 | 의미 | 패턴 |
|---------------|------|------|
| 없음 | 효과가 독립적으로 합산 | 평행한 선 |
| 시너지(양) | 함께 적용하면 더 큰 효과 | 교차 또는 벌어지는 선 |
| 길항(음) | 함께 적용하면 효과 감소 | 수렴하는 선 |

넷플릭스 추천 실험에서 추천 알고리즘(요인 A)과 UI 레이아웃(요인 B)의 상호작용이 있다면, 최적의 알고리즘은 UI에 따라 달라질 수 있습니다.

$$Y = \mu + \alpha_i + \beta_j + (\alpha\beta)_{ij} + \epsilon$$

```python
import numpy as np
import statsmodels.api as sm
from statsmodels.formula.api import ols
import pandas as pd

np.random.seed(42)
n = 500

# 상호작용이 있는 데이터 생성
data = []
for a in [0, 1]:
    for b in [0, 1]:
        effect = 2*a + 3*b + 2.5*a*b  # 양의 상호작용
        y = np.random.normal(10 + effect, 3, n)
        for yi in y:
            data.append({'A': a, 'B': b, 'Y': yi})

df = pd.DataFrame(data)
model = ols('Y ~ C(A) * C(B)', data=df).fit()
print(model.summary().tables[1])
```

> **핵심 직관**: 상호작용을 무시하고 주효과만 분석하면, 최적 조합을 놓칠 수 있습니다. 팩토리얼 설계의 진정한 가치는 상호작용 탐지에 있습니다.

---

## 6. 부분 팩토리얼과 적응적 설계

요인 수가 많아지면 $2^k$의 조합이 폭발적으로 증가합니다.

| 요인 수($k$) | 전체 조합 | 필요 표본(그룹당 500) |
|-------------|-----------|----------------------|
| 2 | 4 | 2,000 |
| 3 | 8 | 4,000 |
| 5 | 32 | 16,000 |
| 10 | 1,024 | 512,000 |

### 부분 팩토리얼 설계 ($2^{k-p}$)

고차 상호작용이 무시할 수 있다는 가정 하에 실험 횟수를 줄입니다.

$$2^{k-p} \text{ 설계}: \quad k \text{개 요인을 } 2^{k-p} \text{개 조합으로 검증}$$

| 설계 | 요인 | 조합 수 | 추정 가능 | 혼합된 효과 |
|------|------|---------|-----------|-------------|
| $2^{5-2}$ | 5 | 8 | 주효과 + 2차 상호작용 일부 | 고차 상호작용과 혼합 |
| $2^{5-1}$ | 5 | 16 | 주효과 + 2차 상호작용 | 3차 이상과 혼합 |

```python
import numpy as np
from itertools import product

# 2^(3-1) 부분 팩토리얼: 3요인을 4조합으로
# 생성 관계: C = A*B
def fractional_factorial_2k_minus_1(k=3):
    """2^(k-1) 부분 팩토리얼 설계 행렬"""
    base = list(product([-1, 1], repeat=k-1))
    design = []
    for row in base:
        # 마지막 요인 = 처음 두 요인의 곱
        last = np.prod(row)
        design.append(list(row) + [int(last)])
    return np.array(design)

design = fractional_factorial_2k_minus_1(3)
print("부분 팩토리얼 설계 행렬 (A, B, C=AB):")
print(design)
print(f"전체 설계: {2**3}조합 → 부분 설계: {len(design)}조합")
```

> **핵심 직관**: 부분 팩토리얼은 "높은 차수의 상호작용은 보통 무시할 수 있다"는 효과 계층 원리(effect hierarchy principle)에 기반한 효율적 타협입니다.

---

## 7. 실무 의사결정 프레임워크

다중 처치/팩토리얼 실험의 결과를 의사결정에 활용하는 프레임워크입니다.

| 결과 패턴 | 의사결정 | 근거 |
|-----------|----------|------|
| 하나의 처치만 유의 | 해당 처치 출시 | 명확한 승자 |
| 여러 처치 유의, 상호작용 없음 | 각각 독립 출시 | 효과 합산 |
| 상호작용 유의 | 최적 조합 출시 | 시너지/길항 고려 |
| 모든 처치 비유의 | 현 상태 유지 또는 재설계 | 효과 크기 재검토 |

```python
import numpy as np

# 의사결정 행렬 시뮬레이션
np.random.seed(42)

def decision_matrix(effects, interactions, mde=0.01):
    """다중 처치 실험 결과 기반 의사결정"""
    significant = [e for e in effects if abs(e) > mde]
    sig_interactions = [i for i in interactions if abs(i) > mde]

    if not significant:
        return "현 상태 유지"
    elif not sig_interactions:
        return f"{len(significant)}개 처치 독립 출시"
    else:
        return "최적 조합 분석 후 출시"

effects = [0.015, 0.008, 0.022]
interactions = [0.003, 0.012, -0.001]
decision = decision_matrix(effects, interactions)
print(f"의사결정: {decision}")
```

ed-08에서 다루는 이질적 처치 효과 분석을 결합하면, 각 서브그룹에 최적인 처치 조합을 찾는 개인화된 의사결정이 가능합니다.

> **핵심 직관**: 팩토리얼 설계의 최종 목표는 "어떤 조합이 최적인가?"를 찾는 것이며, 이를 위해 주효과와 상호작용 효과를 체계적으로 분해해야 합니다.

---

## 핵심 정리

- **다중 처치 실험에서 $K$개 집단의 쌍별 비교는 $K(K-1)/2$개로 증가하며, 다중 비교 보정이 필수입니다**
- **FWER(가족별 오류율)은 확증적 분석에, FDR(위발견율)은 탐색적 분석에 적합한 보정 기준입니다**
- **$2^k$ 팩토리얼 설계는 동일 데이터로 주효과와 상호작용을 동시에 추정하여 효율을 $k$배 높입니다**
- **상호작용 효과는 요인들의 결합이 단순 합산과 다른 효과를 만들며, 이를 무시하면 최적 조합을 놓칩니다**
- **부분 팩토리얼($2^{k-p}$)은 고차 상호작용의 무시 가능성을 가정하여, 조합 수 폭발을 관리하는 실용적 타협입니다**
