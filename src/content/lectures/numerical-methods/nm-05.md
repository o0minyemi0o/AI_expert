# 수치 선형대수

## 왜 수치 선형대수를 배워야 하는가

la-12에서 LU 분해, Cholesky 분해, SVD 등 행렬 분해의 수학적 성질을 배웠습니다. 그런데 이 분해들을 실제 컴퓨터에서 계산하면, nm-01과 nm-02에서 배운 부동소수점 오차가 결과를 왜곡할 수 있습니다.

"수학적으로 역행렬이 존재한다"와 "수치적으로 안정하게 역행렬을 구할 수 있다"는 완전히 다른 문제입니다. 이번 강의에서는 행렬 분해를 **수치적으로 안정하게** 수행하는 방법과, 부동소수점 세계에서의 랭크 개념을 다룹니다.

---

## 1. LU 분해와 피벗팅

la-12에서 배운 LU 분해는 $A = LU$로, 하삼각행렬 $L$과 상삼각행렬 $U$의 곱으로 분해합니다. 그런데 순수한 LU 분해는 **수치적으로 불안정**합니다.

### 피벗 없는 LU의 실패

$$
A = \begin{pmatrix} 10^{-20} & 1 \\ 1 & 1 \end{pmatrix}
$$

피벗 없이 분해하면, 첫 번째 피벗 $10^{-20}$으로 나누면서 중간 계산에서 $10^{20}$ 크기의 수가 등장하고, 결과가 심하게 왜곡됩니다.

```python
import numpy as np
from scipy import linalg

# 피벗 없는 LU (교육용 — 실전에서는 사용 금지)
def lu_no_pivot(A):
    n = A.shape[0]
    L = np.eye(n)
    U = A.astype(float).copy()
    for k in range(n-1):
        for i in range(k+1, n):
            L[i, k] = U[i, k] / U[k, k]  # 피벗이 작으면 위험!
            U[i, k:] -= L[i, k] * U[k, k:]
    return L, U

A = np.array([[1e-20, 1.0],
              [1.0,   1.0]])

L, U = lu_no_pivot(A)
print("피벗 없는 LU 복원 오차:", np.linalg.norm(L @ U - A))

# scipy의 부분 피벗 LU
P, L2, U2 = linalg.lu(A)
print("부분 피벗 LU 복원 오차:", np.linalg.norm(P @ L2 @ U2 - A))
```

### 부분 피벗팅 (Partial Pivoting)

**부분 피벗팅**은 각 열에서 절대값이 가장 큰 원소를 피벗으로 선택합니다.

$$
PA = LU
$$

여기서 $P$는 행 교환을 나타내는 순열 행렬입니다.

> **핵심 직관**: 피벗팅은 "나눗셈에서 분모가 너무 작아지는 것을 방지"합니다. 가장 큰 원소를 피벗으로 쓰면 $L$의 원소가 1 이하로 유지되어 오차 증폭이 억제됩니다.

---

## 2. Cholesky 분해의 수치적 장점

la-12에서 배운 Cholesky 분해는 **양의 정부호(positive definite)** 행렬 $A$에 대해 다음을 만족합니다.

$$
A = LL^T, \quad L \text{은 하삼각행렬}
$$

| 성질 | LU 분해 | Cholesky 분해 |
|------|---------|-------------|
| 적용 조건 | 일반 정방행렬 | 양의 정부호 대칭 행렬 |
| 피벗팅 필요 | 예 | **아니오** |
| 연산량 | $\frac{2}{3}n^3$ | $\frac{1}{3}n^3$ (절반) |
| 수치 안정성 | 피벗팅 필요 | 본질적으로 안정 |
| ML 응용 | 일반 연립방정식 | 커널 행렬, 공분산 행렬 |

```python
import numpy as np

# 양의 정부호 행렬 생성
np.random.seed(42)
B = np.random.randn(5, 5)
A = B.T @ B + 0.1 * np.eye(5)  # 항상 양의 정부호

# Cholesky 분해
L = np.linalg.cholesky(A)
print("복원 오차:", np.linalg.norm(L @ L.T - A))

# 연립방정식 풀기: Ax = b
b = np.random.randn(5)

# 방법 1: 역행렬 (절대 비추천)
x_inv = np.linalg.inv(A) @ b

# 방법 2: np.linalg.solve (추천)
x_solve = np.linalg.solve(A, b)

# 방법 3: Cholesky + 전방/후방 대입 (양의 정부호일 때 최선)
from scipy.linalg import cho_solve, cho_factor
c, low = cho_factor(A)
x_chol = cho_solve((c, low), b)

print(f"역행렬 오차:   {np.linalg.norm(A @ x_inv - b):.2e}")
print(f"solve 오차:    {np.linalg.norm(A @ x_solve - b):.2e}")
print(f"Cholesky 오차: {np.linalg.norm(A @ x_chol - b):.2e}")
```

> **핵심 직관**: Cholesky 분해는 양의 정부호 행렬에 대한 "최고의 알고리즘"입니다. 피벗팅 없이도 안정적이고, LU의 절반 비용입니다. 가우시안 프로세스(GP)의 커널 행렬이 양의 정부호이기 때문에, GP 구현에서 Cholesky는 핵심 도구입니다.

---

## 3. 수치적 랭크 (Numerical Rank)

수학적으로 랭크는 정수입니다. 그러나 부동소수점 세계에서는 "0인 특이값"과 "거의 0인 특이값"의 구분이 모호합니다.

$$
A = U \Sigma V^T, \quad \sigma_1 \geq \sigma_2 \geq \cdots \geq \sigma_n \geq 0
$$

**수치적 랭크**는 주어진 허용 오차 $\tau$에 대해 $\sigma_i > \tau$인 특이값의 수입니다.

```python
import numpy as np

# 랭크 2 행렬 + 작은 노이즈
np.random.seed(42)
u1, u2 = np.random.randn(100, 1), np.random.randn(100, 1)
v1, v2 = np.random.randn(50, 1), np.random.randn(50, 1)

A_clean = 10 * u1 @ v1.T + 5 * u2 @ v2.T  # 정확히 랭크 2
A_noisy = A_clean + 1e-10 * np.random.randn(100, 50)  # 수학적으로 랭크 50

sigmas_clean = np.linalg.svd(A_clean, compute_uv=False)
sigmas_noisy = np.linalg.svd(A_noisy, compute_uv=False)

print("깨끗한 행렬 상위 5 특이값:")
print(sigmas_clean[:5].round(4))
# [큰 값, 큰 값, 0, 0, 0]

print("\n노이즈 행렬 상위 5 특이값:")
print(sigmas_noisy[:5].round(12))
# [큰 값, 큰 값, ~1e-10, ~1e-10, ~1e-10]

print(f"\nnp.linalg.matrix_rank(A_clean): {np.linalg.matrix_rank(A_clean)}")
print(f"np.linalg.matrix_rank(A_noisy): {np.linalg.matrix_rank(A_noisy)}")
# 허용 오차에 따라 랭크가 달라짐!

print(f"tol=1e-8: {np.linalg.matrix_rank(A_noisy, tol=1e-8)}")
print(f"tol=1e-12: {np.linalg.matrix_rank(A_noisy, tol=1e-12)}")
```

> **핵심 직관**: 실전 데이터의 행렬은 수학적으로 "풀 랭크"이지만 수치적으로는 "저랭크"인 경우가 대부분입니다. PCA(la-11 참조)에서 상위 $k$개 특이값만 사용하는 것은, 이 수치적 랭크의 관점에서 정당화됩니다.

---

## 4. 역행렬은 절대 구하지 마라

행렬 방정식 $Ax = b$를 풀 때, $x = A^{-1}b$를 계산하는 것은 거의 항상 나쁜 선택입니다.

| 방법 | 연산량 | 수치 안정성 | 추천 |
|------|-------|-----------|------|
| `np.linalg.inv(A) @ b` | $O(n^3) + O(n^2)$ | 나쁨 | 금지 |
| `np.linalg.solve(A, b)` | $O(n^3)$ | 좋음 | 추천 |
| Cholesky + 대입 | $O(n^3/3)$ | 매우 좋음 | 양의 정부호일 때 최선 |

```python
import numpy as np

# 조건수가 큰 행렬
n = 100
A = np.random.randn(n, n)
U, s, Vt = np.linalg.svd(A)
s = np.logspace(0, -12, n)  # 조건수 ~10^12
A = U @ np.diag(s) @ Vt
b = np.random.randn(n)

# 두 방법 비교
x_inv = np.linalg.inv(A) @ b
x_solve = np.linalg.solve(A, b)

residual_inv = np.linalg.norm(A @ x_inv - b) / np.linalg.norm(b)
residual_solve = np.linalg.norm(A @ x_solve - b) / np.linalg.norm(b)

print(f"역행렬 방법 상대 잔차: {residual_inv:.2e}")
print(f"solve 방법 상대 잔차:  {residual_solve:.2e}")
print(f"조건수: {np.linalg.cond(A):.2e}")
```

---

## 5. QR 분해의 수치적 역할

la-12에서 다룬 QR 분해 $A = QR$은 최소자승 문제를 안정하게 푸는 핵심 도구입니다.

$$
\min_{\mathbf{x}} \|A\mathbf{x} - \mathbf{b}\|^2 \quad \Rightarrow \quad R\mathbf{x} = Q^T\mathbf{b}
$$

정규방정식 $A^TA\mathbf{x} = A^T\mathbf{b}$를 직접 풀면 조건수가 $\kappa(A)^2$로 제곱되지만, QR을 사용하면 $\kappa(A)$를 유지합니다.

```python
import numpy as np

# 최소자승 문제: 세 가지 방법 비교
np.random.seed(42)
m, n = 200, 50
A = np.random.randn(m, n)
b = np.random.randn(m)

# 방법 1: 정규방정식 (조건수 제곱 → 불안정)
x_normal = np.linalg.solve(A.T @ A, A.T @ b)

# 방법 2: QR 분해 (안정)
Q, R = np.linalg.qr(A)
x_qr = np.linalg.solve(R, Q.T @ b)

# 방법 3: SVD (가장 안정, 가장 비용)
x_svd = np.linalg.lstsq(A, b, rcond=None)[0]

print(f"정규방정식 잔차: {np.linalg.norm(A @ x_normal - b):.10f}")
print(f"QR 분해 잔차:    {np.linalg.norm(A @ x_qr - b):.10f}")
print(f"SVD 잔차:        {np.linalg.norm(A @ x_svd - b):.10f}")
print(f"\nA의 조건수:     {np.linalg.cond(A):.1f}")
print(f"A^T A의 조건수: {np.linalg.cond(A.T @ A):.1f}")
```

---

## 6. 실전 가이드: 어떤 분해를 쓸 것인가

```
                  행렬 A의 성질은?
                       │
              ┌────────┴────────┐
           대칭?              비대칭?
              │                  │
         양의 정부호?         정방?
         ┌────┴────┐       ┌────┴────┐
        예         아니오   예        아니오
         │          │       │          │
    Cholesky     LDL^T   LU+피벗   QR 또는 SVD
    (최소 비용)   분해    (일반 풀이)  (최소자승)
```

---

## 핵심 정리

1. **LU 분해**는 부분 피벗팅 없이는 수치적으로 불안정하며, 항상 $PA = LU$ 형태를 사용해야 한다.
2. **Cholesky 분해**는 양의 정부호 행렬에서 피벗팅 없이 안정적이며 LU의 절반 비용이다.
3. **수치적 랭크**는 허용 오차 $\tau$에 의존하며, 실전 데이터는 수학적 풀 랭크이지만 수치적 저랭크인 경우가 대부분이다.
4. $Ax = b$를 풀 때 **역행렬을 절대 구하지 말고** `np.linalg.solve`나 분해 기반 방법을 사용해야 한다.
5. **QR 분해**는 최소자승 문제에서 정규방정식보다 안정적이며, 조건수가 제곱되는 것을 방지한다.
