# 크로네커 곱과 벡터화

## 왜 크로네커 곱을 배워야 하는가

행렬 방정식 $AXB = C$를 만나면 어떻게 풀어야 할까요? $X$가 행렬이라 일반적인 선형 시스템으로 바로 풀 수 없습니다. **크로네커 곱(Kronecker product)**과 **vec 연산자**를 사용하면 이 행렬 방정식을 벡터에 대한 선형 시스템으로 변환할 수 있습니다. 또한 다변량 가우시안에서 공분산이 크로네커 구조를 가지면 계산 비용을 극적으로 줄일 수 있습니다.

---

## 1. vec 연산자

행렬 $X \in \mathbb{R}^{m \times n}$의 **vec(vectorization)**는 열을 위에서 아래로 쌓아 벡터로 만드는 연산입니다.

$$
X = \begin{pmatrix} x_{11} & x_{12} \\ x_{21} & x_{22} \\ x_{31} & x_{32} \end{pmatrix} \implies \text{vec}(X) = \begin{pmatrix} x_{11} \\ x_{21} \\ x_{31} \\ x_{12} \\ x_{22} \\ x_{32} \end{pmatrix}
$$

$\text{vec}: \mathbb{R}^{m \times n} \to \mathbb{R}^{mn}$

즉, **열 우선(column-major)**으로 펼칩니다. NumPy에서는 `X.flatten('F')` (Fortran order)에 해당합니다.

> **핵심 직관**: vec 연산은 행렬을 벡터로 "포장"하는 것입니다. 행렬 방정식을 벡터 방정식으로 바꿀 때 필수적입니다.

---

## 2. 크로네커 곱의 정의

$A \in \mathbb{R}^{m \times n}$, $B \in \mathbb{R}^{p \times q}$의 **크로네커 곱**은,

$$
A \otimes B = \begin{pmatrix} a_{11}B & a_{12}B & \cdots & a_{1n}B \\ a_{21}B & a_{22}B & \cdots & a_{2n}B \\ \vdots & \vdots & \ddots & \vdots \\ a_{m1}B & a_{m2}B & \cdots & a_{mn}B \end{pmatrix} \in \mathbb{R}^{mp \times nq}
$$

$A$의 각 원소를 $B$ 전체로 대체한 블록 행렬입니다.

### 예시

$$
\begin{pmatrix} 1 & 2 \\ 3 & 4 \end{pmatrix} \otimes \begin{pmatrix} 0 & 5 \\ 6 & 7 \end{pmatrix} = \begin{pmatrix} 0 & 5 & 0 & 10 \\ 6 & 7 & 12 & 14 \\ 0 & 15 & 0 & 20 \\ 18 & 21 & 24 & 28 \end{pmatrix}
$$

---

## 3. 크로네커 곱의 성질

| 성질 | 수식 |
|------|------|
| 결합법칙 | $(A \otimes B) \otimes C = A \otimes (B \otimes C)$ |
| 분배법칙 | $(A + B) \otimes C = A \otimes C + B \otimes C$ |
| 스칼라 곱 | $(cA) \otimes B = A \otimes (cB) = c(A \otimes B)$ |
| 전치 | $(A \otimes B)^T = A^T \otimes B^T$ |
| 역행렬 | $(A \otimes B)^{-1} = A^{-1} \otimes B^{-1}$ |
| 행렬식 | $\det(A \otimes B) = (\det A)^p (\det B)^m$ |
| 혼합 곱 성질 | $(A \otimes B)(C \otimes D) = (AC) \otimes (BD)$ |
| 고유값 | $\lambda_i(A)\lambda_j(B)$ 모두 |

**혼합 곱 성질(mixed product property)**이 가장 중요합니다. 크로네커 곱의 곱을 각 인자의 곱의 크로네커 곱으로 분해할 수 있습니다.

---

## 4. 핵심 정리: vec와 크로네커의 관계

$$
\text{vec}(AXB) = (B^T \otimes A)\,\text{vec}(X)
$$

이 공식 하나가 크로네커 곱의 가장 핵심적인 응용입니다.

### 유도

$Y = AXB$에서 $Y$의 $j$번째 열은,

$$
\mathbf{y}_j = AX\mathbf{b}_j = A\sum_k b_{kj}\mathbf{x}_k
$$

이를 vec로 쌓으면, $B^T$의 원소가 $A$와 결합되는 구조가 되어 $(B^T \otimes A)$가 나옵니다.

### 특수한 경우들

| 행렬 방정식 | 벡터 형태 |
|------------|----------|
| $AX = C$ | $(I \otimes A)\,\text{vec}(X) = \text{vec}(C)$ |
| $XB = C$ | $(B^T \otimes I)\,\text{vec}(X) = \text{vec}(C)$ |
| $AXB = C$ | $(B^T \otimes A)\,\text{vec}(X) = \text{vec}(C)$ |
| $AX + XB = C$ | $(I \otimes A + B^T \otimes I)\,\text{vec}(X) = \text{vec}(C)$ |

마지막 행은 **Sylvester 방정식**입니다. 제어 이론과 안정성 분석에서 자주 등장합니다.

> **핵심 직관**: 행렬 방정식을 벡터 방정식으로 변환하면, 기존의 선형 시스템 풀이 도구를 그대로 사용할 수 있습니다.

---

## 5. NumPy로 확인하기

```python
import numpy as np

# 크로네커 곱
A = np.array([[1, 2], [3, 4]])
B = np.array([[0, 5], [6, 7]])
K = np.kron(A, B)
print(f"A ⊗ B:\n{K}")

# 혼합 곱 성질 검증: (A⊗B)(C⊗D) = (AC)⊗(BD)
C = np.random.randn(2, 2)
D = np.random.randn(2, 2)
lhs = np.kron(A, B) @ np.kron(C, D)
rhs = np.kron(A @ C, B @ D)
print(f"\n혼합 곱 성질: {np.allclose(lhs, rhs)}")  # True

# 고유값 성질
eigA = np.linalg.eigvals(A)
eigB = np.linalg.eigvals(B)
eigK = np.linalg.eigvals(K)
expected = np.sort([a * b for a in eigA for b in eigB])
print(f"\n크로네커 고유값: {np.sort(eigK.real).round(4)}")
print(f"개별 곱:        {np.sort(expected.real).round(4)}")

# vec(AXB) = (B^T ⊗ A) vec(X) 검증
m, n, p = 3, 4, 2
A_mat = np.random.randn(m, m)
X_mat = np.random.randn(m, n)
B_mat = np.random.randn(n, n)

lhs_vec = (A_mat @ X_mat @ B_mat).flatten('F')
rhs_vec = np.kron(B_mat.T, A_mat) @ X_mat.flatten('F')
print(f"\nvec(AXB) = (B^T⊗A)vec(X)? {np.allclose(lhs_vec, rhs_vec)}")

# 행렬 방정식 AXB = C 풀기
C_mat = np.random.randn(m, n)
# (B^T ⊗ A) vec(X) = vec(C)
kron_system = np.kron(B_mat.T, A_mat)
vec_x = np.linalg.solve(kron_system, C_mat.flatten('F'))
X_solved = vec_x.reshape(m, n, order='F')
print(f"AXB = C 검증: {np.allclose(A_mat @ X_solved @ B_mat, C_mat)}")
```

---

## 6. ML에서의 의미

### 크로네커 구조 공분산

다변량 가우시안에서 시공간 데이터를 다룰 때, 공분산이 다음과 같은 크로네커 구조를 가질 수 있습니다.

$$
\Sigma = \Sigma_{\text{time}} \otimes \Sigma_{\text{space}}
$$

전체 공분산 $\Sigma \in \mathbb{R}^{TN \times TN}$을 직접 다루면 $O(T^3N^3)$이지만, 크로네커 구조를 활용하면 $O(T^3 + N^3)$으로 줄어듭니다.

역행렬도 간단합니다.

$$
\Sigma^{-1} = \Sigma_{\text{time}}^{-1} \otimes \Sigma_{\text{space}}^{-1}
$$

행렬식도 마찬가지입니다.

$$
\det(\Sigma) = (\det\Sigma_{\text{time}})^N \cdot (\det\Sigma_{\text{space}})^T
$$

### K-FAC (Kronecker-Factored Approximate Curvature)

신경망의 Fisher 정보 행렬(자연 기울기법에 사용)은 파라미터 수의 제곱 크기입니다. K-FAC은 이를 크로네커 곱으로 근사합니다.

$$
F \approx A \otimes G
$$

$A$는 입력의 공분산, $G$는 그래디언트의 공분산입니다. 이 근사 덕분에 역행렬 계산이 크게 간소화됩니다.

### 텐서 분해와의 연결

크로네커 곱은 텐서 분해의 기본 연산입니다. la-07에서 다룬 텐서의 CP 분해는 크로네커(외적)의 합으로 표현되며, Tucker 분해의 각 모드 행렬 연산도 크로네커 구조를 활용합니다.

---

## 핵심 정리

1. **vec 연산자**는 행렬을 열 우선으로 벡터화하며, 행렬 방정식을 벡터 방정식으로 변환하는 핵심 도구이다.
2. **크로네커 곱** $A \otimes B$는 $A$의 각 원소를 $B$ 전체로 대체한 블록 행렬이다.
3. **핵심 공식** $\text{vec}(AXB) = (B^T \otimes A)\,\text{vec}(X)$로 행렬 방정식 $AXB = C$를 선형 시스템으로 변환할 수 있다.
4. **크로네커 구조 공분산**은 역행렬과 행렬식 계산을 개별 인자의 연산으로 분리하여, 계산 비용을 극적으로 줄인다.
5. **K-FAC**은 Fisher 행렬을 크로네커 곱으로 근사하여, 2차 최적화를 대규모 신경망에 적용 가능하게 한다.
