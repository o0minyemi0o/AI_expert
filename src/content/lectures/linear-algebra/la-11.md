# 희소 및 구조적 행렬

## 왜 희소 행렬을 배워야 하는가

현실의 대부분의 대규모 행렬은 **희소(sparse)**합니다. 소셜 네트워크에서 한 사용자는 수십억 명 중 수백 명만 연결됩니다. 자연어 처리의 문서-단어 행렬에서 대부분의 원소는 0입니다. 희소 행렬을 밀집 행렬처럼 저장하고 연산하면 메모리와 시간을 낭비합니다. 적절한 저장 형식과 반복법(iterative solver)을 사용하면 수십 배의 성능 향상을 얻을 수 있습니다.

---

## 1. 희소 행렬의 동기

$n \times n$ 행렬에서 0이 아닌 원소(non-zero, nnz)의 수가 $O(n)$이면 **희소**합니다.

| 행렬 | 크기 | nnz | 밀도 |
|------|------|-----|------|
| 소셜 그래프 (10M 유저) | $10^7 \times 10^7$ | $\sim 10^9$ | $10^{-5}$ |
| 문서-단어 (100K × 50K) | $10^5 \times 5\times10^4$ | $\sim 10^7$ | $0.002$ |
| FEM 강성 행렬 | $10^6 \times 10^6$ | $\sim 10^7$ | $10^{-5}$ |

밀집 저장: $n^2$ 원소 → 10M × 10M = $10^{14}$개 (불가능)
희소 저장: nnz 개만 → $10^9$개 (가능)

---

## 2. 희소 저장 형식

### COO (Coordinate)

가장 단순한 형식입니다. 각 0이 아닌 원소의 (행, 열, 값) 세 배열을 저장합니다.

$$
A = \begin{pmatrix} 1 & 0 & 2 \\ 0 & 3 & 0 \\ 4 & 0 & 5 \end{pmatrix}
$$

```
row = [0, 0, 1, 2, 2]
col = [0, 2, 1, 0, 2]
val = [1, 2, 3, 4, 5]
```

장점: 구성이 간단, 원소 추가 용이
단점: 행/열 슬라이싱 비효율

### CSR (Compressed Sparse Row)

행별로 압축합니다. 가장 널리 쓰이는 형식입니다.

```
indptr  = [0, 2, 3, 5]      # 각 행의 시작 인덱스
indices = [0, 2, 1, 0, 2]    # 열 인덱스
data    = [1, 2, 3, 4, 5]    # 값
```

$i$번째 행의 원소: `data[indptr[i]:indptr[i+1]]`, 열은 `indices[indptr[i]:indptr[i+1]]`

장점: 행 슬라이싱 $O(1)$, 행렬-벡터 곱 효율적
단점: 열 슬라이싱 비효율

### CSC (Compressed Sparse Column)

CSR의 열 버전입니다. 열 슬라이싱이 효율적입니다.

| 형식 | 행 접근 | 열 접근 | 행렬-벡터 곱 | 원소 추가 |
|------|---------|---------|-------------|----------|
| COO | $O(\text{nnz})$ | $O(\text{nnz})$ | 비효율 | $O(1)$ |
| CSR | $O(1)$ | $O(\text{nnz})$ | 효율적 | 비효율 |
| CSC | $O(\text{nnz})$ | $O(1)$ | 효율적 | 비효율 |

> **핵심 직관**: COO는 "행렬 조립"에, CSR/CSC는 "행렬 연산"에 적합합니다. 보통 COO로 만들고 CSR/CSC로 변환합니다.

---

## 3. scipy.sparse 사용법

```python
import numpy as np
from scipy import sparse

# COO로 생성
row = [0, 0, 1, 2, 2]
col = [0, 2, 1, 0, 2]
data = [1, 2, 3, 4, 5]
A_coo = sparse.coo_matrix((data, (row, col)), shape=(3, 3))

# CSR로 변환
A_csr = A_coo.tocsr()
print(f"밀집:\n{A_csr.toarray()}")
print(f"nnz: {A_csr.nnz}")
print(f"밀도: {A_csr.nnz / (3*3):.2%}")

# 행렬-벡터 곱
x = np.array([1, 2, 3])
y = A_csr @ x
print(f"A @ x = {y}")

# 대규모 희소 행렬 생성
n = 100000
A_large = sparse.random(n, n, density=0.0001, format='csr')
print(f"\n{n}×{n} 행렬, nnz={A_large.nnz}")
print(f"밀집 메모리: {n*n*8/1e9:.1f} GB")
print(f"희소 메모리: {(A_large.nnz*12)/1e6:.1f} MB")

# 희소 행렬-벡터 곱 시간
import time
x = np.random.randn(n)
start = time.time()
for _ in range(100):
    y = A_large @ x
print(f"희소 Ax 100회: {time.time()-start:.3f}s")
```

---

## 4. 반복법: 켤레 기울기법 (Conjugate Gradient)

대규모 희소 시스템 $A\mathbf{x} = \mathbf{b}$ ($A$가 대칭 PD)을 풀 때, 직접법(LU, Cholesky)은 **fill-in**(분해 과정에서 0이 아닌 원소가 늘어나는 현상) 때문에 비효율적일 수 있습니다.

**켤레 기울기법(CG)**은 행렬-벡터 곱 $A\mathbf{x}$만 반복적으로 계산하여 해를 근사합니다.

### 알고리즘

$$
\mathbf{r}_0 = \mathbf{b} - A\mathbf{x}_0, \quad \mathbf{p}_0 = \mathbf{r}_0
$$

각 반복 $k$:
$$
\alpha_k = \frac{\mathbf{r}_k^T\mathbf{r}_k}{\mathbf{p}_k^TA\mathbf{p}_k}
$$
$$
\mathbf{x}_{k+1} = \mathbf{x}_k + \alpha_k \mathbf{p}_k
$$
$$
\mathbf{r}_{k+1} = \mathbf{r}_k - \alpha_k A\mathbf{p}_k
$$
$$
\beta_k = \frac{\mathbf{r}_{k+1}^T\mathbf{r}_{k+1}}{\mathbf{r}_k^T\mathbf{r}_k}
$$
$$
\mathbf{p}_{k+1} = \mathbf{r}_{k+1} + \beta_k \mathbf{p}_k
$$

### 수렴 속도

$$
\|\mathbf{x}_k - \mathbf{x}^*\|_A \leq 2\left(\frac{\sqrt{\kappa} - 1}{\sqrt{\kappa} + 1}\right)^k \|\mathbf{x}_0 - \mathbf{x}^*\|_A
$$

조건수 $\kappa$가 작을수록 빠르게 수렴합니다.

> **핵심 직관**: CG는 $A$를 명시적으로 저장할 필요 없이, $A\mathbf{v}$를 계산하는 함수만 있으면 됩니다. 희소 행렬은 이 곱셈이 $O(\text{nnz})$이므로 매우 빠릅니다.

```python
from scipy.sparse.linalg import cg

# 대칭 PD 희소 행렬
n = 10000
A = sparse.random(n, n, density=0.001, format='csr')
A = A.T @ A + sparse.eye(n)  # 대칭 PD 보장
b = np.random.randn(n)

x, info = cg(A, b, tol=1e-10)
print(f"수렴 상태: {'성공' if info == 0 else '실패'}")
print(f"잔차: {np.linalg.norm(A @ x - b):.2e}")
```

---

## 5. 구조적 행렬

특별한 구조를 가진 행렬은 일반 행렬보다 빠르게 연산할 수 있습니다.

| 구조 | 저장 | 행렬-벡터 곱 | 예시 |
|------|------|-------------|------|
| 대각 행렬 | $O(n)$ | $O(n)$ | 스케일링 |
| 삼대각 행렬 | $O(n)$ | $O(n)$ | 1D FEM |
| Toeplitz | $O(n)$ | $O(n\log n)$ (FFT) | 시계열 자기상관 |
| 순환(Circulant) | $O(n)$ | $O(n\log n)$ (FFT) | 순환 합성곱 |

### 순환 행렬과 FFT

순환 행렬 $C$는 FFT로 대각화됩니다.

$$
C = F^{-1}\text{diag}(F\mathbf{c})F
$$

여기서 $F$는 이산 푸리에 변환(DFT) 행렬이고, $\mathbf{c}$는 $C$의 첫 번째 열입니다. 따라서 $C\mathbf{x}$는 $O(n\log n)$에 계산 가능합니다.

---

## 6. ML에서의 의미

### GNN과 희소 인접 행렬

그래프 신경망(GNN)에서 그래프의 인접 행렬은 대규모 희소 행렬입니다. 메시지 패싱은 희소 행렬-벡터 곱으로 구현됩니다.

### 희소 임베딩

추천 시스템의 사용자/아이템 특성은 대부분 원-핫 인코딩으로 표현되어 극도로 희소합니다. 희소 연산을 활용하면 메모리와 계산 비용을 크게 줄일 수 있습니다.

### CNN과 Toeplitz 구조

1D 합성곱(convolution)은 Toeplitz 행렬곱으로 표현됩니다. 이 구조를 이해하면 합성곱의 행렬 해석이 가능합니다.

---

## 핵심 정리

1. **희소 행렬**은 대부분의 원소가 0인 행렬이며, 현실의 대규모 데이터 대부분이 이에 해당한다.
2. **COO**는 조립용, **CSR/CSC**는 연산용 저장 형식이며, scipy.sparse로 쉽게 다룰 수 있다.
3. **켤레 기울기법(CG)**은 행렬-벡터 곱만으로 대규모 대칭 PD 시스템을 풀며, 수렴 속도는 조건수에 의존한다.
4. **구조적 행렬**(Toeplitz, 순환)은 FFT를 활용하여 $O(n\log n)$에 곱셈이 가능하다.
5. GNN, 추천 시스템, CNN 등 ML의 핵심 연산이 **희소 행렬 연산**에 의존한다.
