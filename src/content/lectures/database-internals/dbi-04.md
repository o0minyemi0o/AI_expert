# 쿼리 플래너와 옵티마이저

## 왜 쿼리 옵티마이저를 이해해야 하는가

SQL은 **"무엇을 원하는지"만 선언**하고, "어떻게 가져올지"는 옵티마이저가 결정합니다. sql-07에서 실행 계획을 읽는 법을 배웠다면, 여기서는 **옵티마이저가 왜 그런 결정을 하는지**의 내부 원리를 다룹니다. 이를 이해해야 예상과 다른 실행 계획이 나왔을 때 원인을 파악하고 대응할 수 있습니다.

> **핵심 직관**: 옵티마이저는 "모든 가능한 실행 계획 중 비용이 가장 낮은 것"을 선택합니다. 비용 추정이 정확하면 좋은 계획을, 부정확하면 나쁜 계획을 선택합니다.

## 1. 규칙 기반 vs 비용 기반

```
규칙 기반 옵티마이저 (RBO):
  └─ 고정된 규칙으로 계획 결정
     예: "인덱스가 있으면 무조건 사용"
     단점: 데이터 분포 무시
     사용: 구형 Oracle (현재는 거의 없음)

비용 기반 옵티마이저 (CBO):
  └─ 각 실행 계획의 비용을 추정하여 최저 비용 선택
     비용 = f(I/O 비용, CPU 비용, 메모리 비용)
     장점: 데이터 분포, 통계에 기반한 최적 선택
     사용: PostgreSQL, MySQL 8.0+, 모든 현대 DB
```

| 단계 | 설명 |
|------|------|
| 파싱 | SQL → 구문 트리 (AST) |
| 바인딩 | 테이블/컬럼 존재 확인, 타입 체크 |
| 리라이트 | 뷰 인라인, 서브쿼리 변환, 상수 폴딩 |
| 계획 생성 | 가능한 실행 계획 열거 |
| 비용 추정 | 각 계획의 비용 계산 |
| 계획 선택 | 최저 비용 계획 선택 |

## 2. 카디널리티 추정

옵티마이저의 **가장 중요한 입력**은 각 연산의 출력 행 수(카디널리티) 추정입니다.

```
카디널리티 추정 방법:

  등가 조건 (WHERE col = 'value'):
  └─ 선택도 = 1 / n_distinct
     예: 1000개 고유값 → 선택도 = 0.001

  범위 조건 (WHERE col > 50):
  └─ 히스토그램 기반 추정
     [0-20: 30%] [20-40: 25%] [40-60: 20%] [60-80: 15%] [80-100: 10%]
     col > 50 → 약 20% + 15% + 10% = 45%

  복합 조건 (WHERE a = 1 AND b = 2):
  └─ 독립 가정: P(a=1) × P(b=2)
     ⚠️ 상관관계 있으면 크게 틀림!
```

```sql
-- PostgreSQL: 확장 통계로 상관관계 반영
CREATE STATISTICS stat_city_country (dependencies)
ON city, country FROM addresses;
ANALYZE addresses;
-- 이제 "서울 AND 한국" 조합의 카디널리티를 정확히 추정
```

> **핵심 직관**: 카디널리티 추정이 10배 틀리면 실행 계획이 완전히 달라집니다. 예를 들어 실제 100만 행인데 1000행으로 추정하면 Nested Loop을 선택하고, 100만 행으로 올바르게 추정하면 Hash Join을 선택합니다.

## 3. 조인 순서 최적화

N개 테이블의 조인 순서는 **N!가지**가 가능합니다.

```
3개 테이블 조인 순서 (A, B, C):
  A ⋈ B ⋈ C
  A ⋈ C ⋈ B
  B ⋈ A ⋈ C
  B ⋈ C ⋈ A
  C ⋈ A ⋈ B
  C ⋈ B ⋈ A  → 6가지

  10개 테이블: 10! = 3,628,800가지
  → 전수 조사 불가능

  최적화 전략:
  ├─ 동적 프로그래밍 (PostgreSQL): 12개 이하
  │   부분 집합의 최적 계획을 재사용
  │   시간: O(2^N × N)
  │
  ├─ 유전 알고리즘 (PostgreSQL GEQO): 12개 초과
  │   휴리스틱으로 근사 최적 탐색
  │
  └─ 그리디 (MySQL): 항상
      매 단계 최소 비용 조인 쌍 선택
```

## 4. 조인 알고리즘 선택

```
옵티마이저의 조인 알고리즘 선택 기준:

  [조인 조건이 등가(=)인가?]
  ├─ Yes → [inner 테이블 크기]
  │        ├─ 작음 (<= work_mem) → Hash Join
  │        └─ 큼 → Merge Join (이미 정렬 시) or Hash Join
  │
  └─ No (부등호, 범위) → [inner 크기]
           ├─ 작음 or 인덱스 있음 → Nested Loop
           └─ 큼 → Merge Join or Nested Loop + Index

  PostgreSQL 비용 파라미터:
  ├─ seq_page_cost = 1.0     (순차 페이지 읽기 기준)
  ├─ random_page_cost = 4.0  (랜덤 읽기는 4배 비싸다)
  ├─ cpu_tuple_cost = 0.01   (행 처리 비용)
  └─ cpu_index_tuple_cost = 0.005
```

## 5. 플랜 캐싱과 적응형 최적화

```
플랜 캐싱:
  동일 쿼리 패턴 → 이전에 생성한 계획 재사용
  장점: 최적화 비용 절약
  단점: 파라미터에 따라 최적 계획이 다를 수 있음

  PostgreSQL Prepared Statement:
  ├─ 처음 5회: 파라미터별 커스텀 계획 생성
  └─ 이후: 제네릭 계획 vs 커스텀 계획 비용 비교하여 선택

적응형 쿼리 실행 (Adaptive):
  실행 중에 실제 카디널리티를 확인하고 계획 수정
  ├─ Oracle: Adaptive Plans (조인 방식 런타임 변경)
  └─ PostgreSQL: 아직 제한적 (향후 발전 예상)
```

> **핵심 직관**: Prepared Statement에서 `SELECT * FROM t WHERE status = $1`은 status='active'(90%)일 때와 status='rare'(0.1%)일 때 최적 계획이 전혀 다릅니다. 플랜 캐싱이 항상 좋은 것은 아닙니다.

## 6. 옵티마이저 힌트와 한계

```
옵티마이저를 믿을 수 없을 때:

  1. 통계 부정확 → ANALYZE 실행
  2. 상관관계 무시 → 확장 통계 생성
  3. 잘못된 비용 모델 → 비용 파라미터 조정
  4. 최후 수단 → 힌트 (DB마다 다름)

  PostgreSQL: 직접 힌트 미지원, SET으로 간접 제어
    SET enable_seqscan = off;  -- Seq Scan 비활성화

  MySQL: 힌트 문법 지원
    SELECT /*+ USE_INDEX(orders idx_date) */ ...
    SELECT /*+ NO_INDEX(orders) */ ...
```

쿼리 옵티마이저의 원리를 이해하면 sql-07~08의 실행 계획 분석과 최적화가 "왜 그런지"까지 설명할 수 있게 됩니다.

## 핵심 정리

- 비용 기반 옵티마이저는 **카디널리티 추정에 기반**하여 최저 비용 실행 계획을 선택합니다
- **카디널리티 추정 오류**가 잘못된 실행 계획의 가장 흔한 원인이며, ANALYZE와 확장 통계로 개선합니다
- 조인 순서 최적화는 **동적 프로그래밍**(소규모)과 **유전 알고리즘**(대규모)을 사용합니다
- **플랜 캐싱**은 최적화 비용을 절약하지만, 파라미터에 따라 최적 계획이 달라질 수 있습니다
- 옵티마이저 한계 시 통계 갱신 → 확장 통계 → 비용 파라미터 조정 → 힌트 순서로 대응합니다
