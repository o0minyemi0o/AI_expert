# 파티셔닝과 샤딩

## 왜 파티셔닝이 중요한가

데이터가 수십 TB를 넘으면 단일 노드로는 저장도, 처리도 불가능합니다. **파티셔닝**은 하나의 테이블을 여러 조각으로 나누어 분산하는 기술이며, 여러 노드에 걸치면 **샤딩**이라 부릅니다. dbi-07의 복제가 "같은 데이터를 여러 곳에"라면, 파티셔닝은 "다른 데이터를 여러 곳에"입니다.

> **핵심 직관**: 파티셔닝의 핵심 목표는 "쿼리가 전체 데이터가 아닌 관련 파티션만 스캔하게 하는 것"입니다. 잘 설계된 파티셔닝은 TB 테이블에서도 ms 단위 응답을 가능하게 합니다.

## 1. 파티셔닝 vs 샤딩

```
파티셔닝 (Partitioning):
  단일 노드 내에서 테이블을 논리적으로 분할
  PostgreSQL: 네이티브 파티셔닝 지원 (PG 10+)

  orders 테이블
  ├── orders_2024_q1  (2024-01 ~ 2024-03)
  ├── orders_2024_q2  (2024-04 ~ 2024-06)
  ├── orders_2024_q3  (2024-07 ~ 2024-09)
  └── orders_2024_q4  (2024-10 ~ 2024-12)


샤딩 (Sharding):
  여러 노드에 걸쳐 데이터 분산
  각 노드(샤드)가 전체 데이터의 일부를 담당

  [Node 1: users 1-1M]
  [Node 2: users 1M-2M]
  [Node 3: users 2M-3M]

  요청 → [Router] → 적절한 샤드로 라우팅
```

| 구분 | 파티셔닝 | 샤딩 |
|------|---------|------|
| 범위 | 단일 노드 | 다중 노드 |
| 목적 | 쿼리 성능 | 저장/처리 확장 |
| 복잡도 | 낮음 | 높음 |
| 트랜잭션 | 로컬 | 분산 (dbi-09) |
| 예시 | PG 파티셔닝 | Vitess, Citus |

## 2. 파티셔닝 전략

```
범위 파티셔닝 (Range):

  키의 범위로 분할
  예: 날짜별, ID 범위별

  CREATE TABLE orders (
      id BIGINT, created_at DATE, amount NUMERIC
  ) PARTITION BY RANGE (created_at);

  CREATE TABLE orders_2024_q1
      PARTITION OF orders
      FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');

  장점: 범위 쿼리에 최적 (날짜 필터)
  단점: 핫스팟 위험 (최근 파티션에 쓰기 집중)


해시 파티셔닝 (Hash):

  키의 해시값으로 분할
  예: hash(user_id) % 4

  CREATE TABLE users (id BIGINT, name TEXT)
      PARTITION BY HASH (id);

  CREATE TABLE users_p0 PARTITION OF users
      FOR VALUES WITH (MODULUS 4, REMAINDER 0);
  -- p1, p2, p3도 동일

  장점: 균등 분산, 핫스팟 방지
  단점: 범위 쿼리 비효율 (모든 파티션 스캔)


리스트 파티셔닝 (List):

  키의 값 목록으로 분할
  예: 지역별

  PARTITION BY LIST (region);
  FOR VALUES IN ('kr', 'jp');     -- 아시아
  FOR VALUES IN ('us', 'ca');     -- 북미
```

| 전략 | 범위 쿼리 | 균등 분산 | 핫스팟 | 적합 |
|------|----------|----------|--------|------|
| 범위 | 빠름 | 불균등 가능 | 높음 | 시계열, 로그 |
| 해시 | 느림 | 균등 | 낮음 | 사용자, 세션 |
| 리스트 | 해당 없음 | 수동 조정 | 중간 | 지역, 카테고리 |

> **핵심 직관**: 시계열 데이터는 **범위 파티셔닝**이 거의 항상 정답입니다. 최근 데이터만 조회하는 패턴에서 오래된 파티션을 통째로 건너뛰는 "파티션 프루닝"의 효과가 매우 큽니다.

## 3. 일관된 해싱

```
문제: hash(key) % N으로 샤딩하면
      N이 바뀔 때 거의 모든 키가 재배치됨

  N=3: key → hash % 3 = 1 (Node 1)
  N=4: key → hash % 4 = 3 (Node 3로 이동!)
  → 전체 데이터의 ~75%가 이동

일관된 해싱 (Consistent Hashing):

  해시 공간을 원(ring)으로 표현

       Node A
        │
  ──────●──────
  │            │
  ●            ●  Node C
  Node B       │
  │            │
  ──────●──────
       키 위치

  키: 시계 방향으로 가장 가까운 노드에 할당
  노드 추가/제거: 인접한 키만 이동 (~1/N)

  가상 노드 (Virtual Nodes):
  └─ 각 물리 노드가 여러 가상 노드를 가짐
     → 부하 불균형 해소
     → Cassandra: 기본 256개 가상 노드/물리 노드
```

## 4. 핫스팟 방지

```
핫스팟 원인과 해결:

  1. 시간 기반 키 (범위 파티셔닝):
     최근 시간 파티션에 쓰기 집중
     → 해결: 키 앞에 랜덤 prefix 추가
             original: 2024-01-15_event_123
             salted:   3_2024-01-15_event_123
             → 3개 파티션으로 분산
             ⚠️ 읽기 시 모든 prefix를 조회해야 함

  2. 인기 키 (셀러브리티 문제):
     특정 사용자(셀럽)의 데이터에 접근 집중
     → 해결: 인기 키를 여러 샤드에 복제
             또는 인기 키만 별도 캐시

  3. 불균등 해시 분포:
     해시 함수의 편향
     → 해결: 가상 노드 수 증가, 해시 함수 변경
```

## 5. 리밸런싱

```
리밸런싱이 필요한 상황:
  - 새 노드 추가 (스케일 아웃)
  - 노드 제거 (스케일 인)
  - 데이터 편향 심화

전략:

  고정 파티션 수 (Fixed):
  └─ 파티션 수를 미리 충분히 크게 설정 (예: 1000개)
     노드 추가 시 일부 파티션을 새 노드로 이동
     파티션 자체는 분할/병합하지 않음
     사용: Elasticsearch, Riak

  동적 파티셔닝 (Dynamic):
  └─ 파티션이 너무 커지면 분할, 작으면 병합
     사용: HBase, MongoDB

  노드 비례 파티셔닝:
  └─ 노드당 고정 파티션 수
     노드 추가 시 기존 파티션 분할
     사용: Cassandra
```

> **핵심 직관**: 리밸런싱 중에도 서비스는 계속되어야 합니다. 대량 데이터 이동은 네트워크와 디스크를 압박하므로, **점진적으로** 이동하고 이동 중인 파티션에 대한 읽기/쓰기를 적절히 라우팅해야 합니다.

## 6. 파티션 프루닝과 쿼리 라우팅

```
파티션 프루닝 (Partition Pruning):

  쿼리의 WHERE 절을 분석하여 불필요한 파티션을 건너뜀

  -- orders가 월별 파티션일 때:
  SELECT * FROM orders WHERE created_at >= '2024-06-01';
  → 2024-06 이후 파티션만 스캔 (나머지 skip)

  EXPLAIN으로 확인:
  Append
    → Seq Scan on orders_2024_q3  (실제 스캔)
    → Seq Scan on orders_2024_q4  (실제 스캔)
    -- q1, q2는 프루닝되어 표시 안 됨


샤딩 환경의 쿼리 라우팅:

  [Client]
      │
  [Router / Proxy]
      │
  ├─ 샤드 키 포함 쿼리 → 단일 샤드로 라우팅
  │   WHERE user_id = 42 → Shard 2
  │
  ├─ 샤드 키 없는 쿼리 → 모든 샤드에 Scatter-Gather
  │   WHERE email = 'a@b.com' → 전체 샤드 조회 후 병합
  │
  └─ 크로스 샤드 조인 → 매우 비효율적
      → 비정규화로 같은 샤드에 배치하는 것이 핵심
```

파티셔닝은 dbi-07의 복제와 결합하여 각 파티션을 복제하고, dbi-09에서 파티션 간 트랜잭션을 다룹니다.

## 핵심 정리

- **파티셔닝**은 단일 노드 내 분할, **샤딩**은 다중 노드 분산이며, 둘 다 대규모 데이터 처리의 핵심입니다
- **범위 파티셔닝**은 시계열 데이터에, **해시 파티셔닝**은 균등 분산이 필요할 때 적합합니다
- **일관된 해싱**은 노드 추가/제거 시 최소한의 데이터만 이동하게 하며, 가상 노드로 균등성을 보장합니다
- **핫스팟**은 salt prefix, 인기 키 복제, 가상 노드 증가로 완화합니다
- **파티션 프루닝**이 성능 핵심이며, 샤드 키 없는 쿼리는 Scatter-Gather로 모든 샤드를 조회합니다
