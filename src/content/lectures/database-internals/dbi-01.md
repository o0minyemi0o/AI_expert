# 저장 엔진 개요

## 왜 저장 엔진을 이해해야 하는가

SQL을 아무리 잘 써도, **데이터가 디스크에 어떻게 저장되고 읽히는지** 모르면 성능 문제의 근본 원인을 이해할 수 없습니다. 저장 엔진은 DB의 심장이며, B-트리(dbi-02)와 LSM 트리(dbi-03)라는 두 가지 패러다임이 존재합니다. sp-01에서 다룬 메모리 계층 구조가 여기서 직접적으로 연결됩니다.

> **핵심 직관**: 모든 DB 성능 문제는 결국 "디스크 I/O를 얼마나 줄이느냐"로 귀결됩니다. 저장 엔진의 모든 설계 결정은 이 목표를 위한 것입니다.

## 1. 디스크 기반 vs 인메모리

| 특성 | 디스크 기반 | 인메모리 |
|------|-----------|---------|
| 데이터 위치 | 디스크 (SSD/HDD) | RAM |
| 지속성 | 기본 보장 | WAL/스냅샷 필요 |
| 용량 | TB~PB | GB~TB |
| 지연시간 | ms 단위 | μs 단위 |
| 비용 | 낮음 | 높음 |
| 대표 DB | PostgreSQL, MySQL | Redis, VoltDB |

```
저장 매체별 접근 시간:

  L1 캐시        ~1 ns      ████
  L2 캐시        ~4 ns      ████████
  RAM           ~100 ns     ████████████████████
  SSD (랜덤)    ~100 μs     ████████████████████████████████████
  HDD (랜덤)    ~10 ms      ██████████████████████████████████████████████████

  → SSD 랜덤 읽기는 RAM보다 1000배 느림
  → 디스크 I/O 최소화가 DB 설계의 핵심
```

## 2. 페이지 구조

디스크 기반 DB는 데이터를 **고정 크기 페이지**(보통 4KB~16KB) 단위로 관리합니다.

```
페이지 내부 구조 (Slotted Page):

  ┌──────────────────────────────────┐
  │ Page Header                      │
  │ (페이지 ID, 체크섬, 여유 공간 등)   │
  ├──────────────────────────────────┤
  │ Slot Array (포인터 배열)           │
  │ [Slot1][Slot2][Slot3] →          │
  ├──────────────────────────────────┤
  │                                  │
  │ ← Free Space →                   │
  │                                  │
  ├──────────────────────────────────┤
  │ ← [Tuple3][Tuple2][Tuple1]      │
  │ (실제 데이터, 뒤에서부터 채움)      │
  └──────────────────────────────────┘

  Slot Array: 앞에서부터 증가
  Tuple Data: 뒤에서부터 증가
  → 가운데서 만나면 페이지 가득 참
```

| 구성 요소 | 역할 |
|----------|------|
| Page Header | 메타데이터 (ID, LSN, 체크섬) |
| Slot Array | 각 튜플의 오프셋 포인터 |
| Free Space | 새 튜플 삽입 공간 |
| Tuple Data | 실제 행 데이터 |

## 3. 버퍼 풀

디스크에서 읽은 페이지를 **메모리에 캐싱**하는 영역입니다.

```
버퍼 풀 동작:

  [쿼리 요청: 페이지 42 읽기]
       │
       ▼
  [버퍼 풀에 있는가?]
  ├─ Yes (Cache Hit) → 메모리에서 바로 반환 (~μs)
  └─ No  (Cache Miss) → 디스크에서 읽기 (~ms)
       │
       ├─ 빈 프레임 있으면 → 바로 적재
       └─ 빈 프레임 없으면 → 교체 정책으로 하나 퇴출
            │
            ├─ 퇴출 페이지가 Dirty? → 디스크에 기록 후 퇴출
            └─ Clean? → 바로 퇴출
```

```
교체 정책:

  LRU (Least Recently Used)
  └─ 가장 오래 안 쓴 페이지 퇴출
     단점: 풀스캔 시 유용한 페이지 퇴출 (LRU pollution)

  Clock (Second Chance)
  └─ 원형 버퍼에서 참조 비트 확인
     참조 비트 1 → 0으로 리셋, 넘어감
     참조 비트 0 → 퇴출
     장점: LRU보다 구현 효율적

  LRU-K
  └─ 최근 K번째 접근 시간 기준 퇴출
     K=2: 2번 이상 접근한 페이지 보호
```

> **핵심 직관**: 버퍼 풀의 캐시 히트율이 99%에서 95%로 떨어지면, 디스크 I/O가 5배 증가합니다. 버퍼 풀 크기와 교체 정책은 DB 성능의 가장 기본적인 튜닝 포인트입니다.

## 4. Write-Ahead Log (WAL)

데이터를 수정할 때 **먼저 로그에 기록**하고, 나중에 실제 페이지를 갱신하는 프로토콜입니다.

```
WAL 동작 순서:

  1. 트랜잭션 시작
  2. 변경 내용을 WAL에 기록 (순차 쓰기 → 빠름)
  3. WAL을 디스크에 fsync (내구성 보장)
  4. 커밋 응답 반환
  5. 실제 데이터 페이지는 나중에 갱신 (체크포인트)

  왜 WAL이 빠른가:
  ├─ 데이터 페이지 쓰기: 랜덤 I/O (느림)
  └─ WAL 쓰기: 순차 I/O (빠름)
     → "랜덤 쓰기를 순차 쓰기로 변환"
```

| WAL 장점 | 설명 |
|---------|------|
| 내구성 | 크래시 후 WAL로 복구 가능 |
| 성능 | 랜덤 → 순차 쓰기 변환 |
| 복제 | WAL을 복제본으로 전송 (dbi-07) |
| 시점 복구 | 특정 시점으로 롤백 가능 |

## 5. 저장 엔진 비교

```
두 가지 패러다임:

  B-tree 기반 (읽기 최적화)        LSM 기반 (쓰기 최적화)
  ─────────────────────          ─────────────────────
  PostgreSQL, MySQL(InnoDB)       RocksDB, Cassandra, LevelDB

  읽기: 빠름 (O(log n))           읽기: 느림 (여러 레벨 확인)
  쓰기: 중간 (제자리 갱신)         쓰기: 빠름 (순차 쓰기)
  공간: 효율적                    공간: 쓰기 증폭 (compaction)

  적합: OLTP 범용                 적합: 쓰기 집중 워크로드
```

> **핵심 직관**: B-tree는 "읽기가 많은 워크로드", LSM은 "쓰기가 많은 워크로드"에 최적화되어 있습니다. 이 두 패러다임의 트레이드오프를 이해하는 것이 DB 선택의 출발점입니다. dbi-02와 dbi-03에서 각각 상세히 다룹니다.

## 6. 저장 형식: 행 저장 vs 열 저장

```
행 저장 (Row Store)              열 저장 (Column Store)
─────────────────              ─────────────────
[id=1, name="김", age=30]      id:   [1, 2, 3, ...]
[id=2, name="이", age=25]      name: ["김", "이", ...]
[id=3, name="박", age=35]      age:  [30, 25, 35, ...]

적합: OLTP (전체 행 접근)         적합: OLAP (특정 컬럼 집계)
장점: INSERT/UPDATE 빠름         장점: 집계 쿼리 빠름, 압축률 높음
```

| 저장 형식 | OLTP | OLAP | 압축 | 대표 DB |
|----------|------|------|------|--------|
| 행 저장 | 최적 | 비효율 | 보통 | PostgreSQL, MySQL |
| 열 저장 | 비효율 | 최적 | 높음 | ClickHouse, Redshift |

이 강의는 dbi-02(B-트리)와 dbi-03(LSM 트리)의 기초이며, sql-07~08의 쿼리 최적화를 내부 동작 관점에서 이해하는 기반이 됩니다.

## 핵심 정리

- DB 성능은 결국 **디스크 I/O 최소화**로 귀결되며, SSD도 RAM보다 1000배 느립니다
- 데이터는 **고정 크기 페이지**(4-16KB) 단위로 관리되며, Slotted Page 구조로 튜플을 저장합니다
- **버퍼 풀**은 디스크 페이지를 메모리에 캐싱하며, 히트율이 성능을 결정합니다
- **WAL**은 랜덤 쓰기를 순차 쓰기로 변환하여 성능과 내구성을 동시에 보장합니다
- 저장 엔진은 **B-tree(읽기 최적)**와 **LSM(쓰기 최적)** 두 패러다임으로 나뉘며, 워크로드에 따라 선택합니다
