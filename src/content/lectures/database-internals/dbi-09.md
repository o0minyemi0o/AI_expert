# 분산 트랜잭션

## 왜 분산 트랜잭션이 중요한가

dbi-05의 트랜잭션은 단일 노드를 전제했습니다. 하지만 dbi-08에서 데이터를 여러 샤드에 분산하면, **하나의 트랜잭션이 여러 노드에 걸쳐** 실행되어야 합니다. 예를 들어 송금 트랜잭션에서 출금 계좌와 입금 계좌가 다른 샤드에 있다면? 분산 트랜잭션은 이 문제를 해결하는 프로토콜들입니다.

> **핵심 직관**: 분산 트랜잭션의 핵심 어려움은 "네트워크를 사이에 둔 노드들이 모두 커밋하거나 모두 롤백하기로 합의하는 것"입니다. 한 노드는 커밋하고 다른 노드는 롤백하는 상황이 절대 일어나면 안 됩니다.

## 1. 2PC (Two-Phase Commit)

```
2PC 프로토콜:

  코디네이터 (Coordinator)와 참가자 (Participant)

  Phase 1 - 준비 (Prepare):
  Coordinator → Participant A: "커밋 준비됐나?"
  Coordinator → Participant B: "커밋 준비됐나?"
  Participant A → Coordinator: "YES" (락 유지, WAL 기록)
  Participant B → Coordinator: "YES"

  Phase 2 - 커밋 (Commit):
  Coordinator: 모두 YES → COMMIT 결정
  Coordinator → Participant A: "COMMIT"
  Coordinator → Participant B: "COMMIT"
  A, B: 커밋 실행, 락 해제

  만약 하나라도 NO:
  Coordinator → 모든 참가자: "ROLLBACK"


  문제점 - 블로킹:
  Phase 1 후 Coordinator가 죽으면?
  → 참가자는 COMMIT인지 ROLLBACK인지 모름
  → 락을 잡은 채 영원히 대기 (블로킹!)

  타임라인:
  Coordinator:  [Prepare] ──── [Commit/Abort]
  Participant:  [투표]── 불확실 구간 ──[완료]
                         ↑ 여기서 Coordinator 장애 시 블로킹
```

| 특성 | 2PC |
|------|-----|
| 원자성 | 보장 |
| 가용성 | 낮음 (코디네이터 장애 시 블로킹) |
| 지연시간 | 2 RTT (왕복) |
| 실무 사용 | XA 트랜잭션, 동일 DC 내 |

## 2. 3PC와 그 한계

```
3PC (Three-Phase Commit):

  2PC의 블로킹 문제를 해결하기 위해 단계 추가

  Phase 1: CanCommit? → YES/NO
  Phase 2: PreCommit  → 준비 완료 확인
  Phase 3: DoCommit   → 실제 커밋

  타임아웃으로 블로킹 방지:
  Phase 2에서 Coordinator 장애 → 참가자가 자체 판단

  한계:
  └─ 네트워크 파티션 시 여전히 불일치 가능
     → 실무에서 거의 사용하지 않음
     → Raft/Paxos 기반 합의가 더 실용적
```

## 3. Saga 패턴

```
Saga: 분산 트랜잭션을 보상 트랜잭션의 체인으로 분해

  기존 2PC:
  [T1 + T2 + T3] → 하나의 원자적 트랜잭션

  Saga:
  T1 → T2 → T3 (각각 독립 트랜잭션)
  실패 시: C3 → C2 → C1 (보상 트랜잭션을 역순 실행)

  예: 여행 예약 Saga
  1. T1: 항공편 예약        C1: 항공편 취소
  2. T2: 호텔 예약          C2: 호텔 취소
  3. T3: 결제 처리          C3: 환불 처리

  T2 실패 시:
  T1 ✅ → T2 ❌ → C1 실행 (항공편 취소)


오케스트레이션 vs 코레오그래피:

  오케스트레이션 (Orchestration):
  [Saga Orchestrator]
    → T1 실행 지시 → 완료 확인
    → T2 실행 지시 → 실패 확인
    → C1 실행 지시
  장점: 흐름이 명확, 디버깅 쉬움
  단점: 오케스트레이터가 단일 장애점

  코레오그래피 (Choreography):
  T1 완료 → 이벤트 발행 → T2가 이벤트 수신 후 실행
  T2 실패 → 보상 이벤트 발행 → C1이 수신 후 실행
  장점: 느슨한 결합
  단점: 흐름 추적 어려움
```

> **핵심 직관**: Saga는 ACID의 I(격리성)를 포기합니다. T1은 커밋됐지만 T2가 실패하여 C1으로 보상하는 사이에, 다른 트랜잭션이 T1의 결과를 읽을 수 있습니다. 이를 **"더티 리드"**라 하며, 비즈니스 로직으로 처리해야 합니다.

## 4. Google Spanner와 TrueTime

```
Spanner의 핵심 혁신: TrueTime API

  분산 시스템에서 "이벤트 A가 B보다 먼저 일어났다"를
  판단하려면 정확한 시간이 필요

  일반 서버 시계: ±100ms 오차 → 순서 판단 불가

  TrueTime:
  └─ GPS + 원자시계로 시간 오차를 수 ms 이내로 보장
     API: TT.now() → [earliest, latest] (불확실성 구간)

  동작:
  1. 트랜잭션 커밋 시 타임스탬프 할당
  2. 불확실성 구간만큼 대기 (commit-wait)
     → "내 커밋 시간이 확실히 지났을 때" 응답
  3. 타임스탬프 순서가 곧 직렬화 순서

  결과:
  └─ 외부 일관성 (External Consistency) 달성
     "커밋 순서가 실제 벽시계 순서와 일치"
     → 전 세계 어디서든 최신 읽기 보장
```

## 5. Calvin과 결정론적 실행

```
Calvin 접근법:

  Spanner: "정확한 시계로 순서 결정"
  Calvin:  "실행 전에 순서를 먼저 결정"

  1. Sequencer: 모든 트랜잭션의 전역 순서를 결정
  2. 각 노드: 같은 순서로 트랜잭션 실행
  3. 결정론적 실행 → 같은 입력 → 같은 결과

  장점:
  - 2PC 불필요 (순서가 이미 합의됨)
  - 복제본이 독립적으로 같은 결과 도달
  - 락 대기 시간 예측 가능

  단점:
  - 트랜잭션 내용을 미리 알아야 함
  - 인터랙티브 트랜잭션 불가
  - Sequencer가 병목

  사용: FaunaDB, DQLITE
```

## 6. 실무 선택 가이드

```
분산 트랜잭션이 정말 필요한가?

  Step 1: 같은 샤드에 배치할 수 없는가?
  └─ 관련 데이터를 같은 샤드에 → 로컬 트랜잭션으로 충분
     예: user_id로 샤딩 → 사용자의 모든 데이터가 같은 샤드

  Step 2: 결과적 일관성으로 충분한가?
  └─ 이벤트 기반 비동기 처리로 충분하면 분산 트랜잭션 불필요
     예: 주문 생성 → 이벤트 → 재고 차감 (비동기)

  Step 3: Saga로 해결 가능한가?
  └─ 보상 트랜잭션으로 롤백 가능하면 Saga
     예: 결제 실패 → 예약 취소 (보상)

  Step 4: 강한 일관성이 반드시 필요하다면
  └─ 2PC (같은 DC) 또는 Spanner 스타일 (글로벌)
```

| 방식 | 일관성 | 성능 | 복잡도 | 적합 |
|------|--------|------|--------|------|
| 같은 샤드 배치 | 강함 | 최고 | 낮음 | 관련 데이터 |
| 결과적 일관성 | 약함 | 높음 | 중간 | 비핵심 흐름 |
| Saga | 중간 | 중간 | 중간 | 보상 가능 |
| 2PC | 강함 | 낮음 | 높음 | 단일 DC |
| Spanner 스타일 | 강함 | 중간 | 매우 높음 | 글로벌 |

> **핵심 직관**: 분산 트랜잭션을 피하는 것이 최선입니다. **데이터 모델링 단계에서 관련 데이터를 같은 샤드에 배치**하면 대부분의 분산 트랜잭션이 불필요해집니다. "분산 트랜잭션이 필요하다"는 것은 종종 "샤딩 키 설계가 잘못됐다"는 신호입니다.

## 핵심 정리

- **2PC**는 원자성을 보장하지만 코디네이터 장애 시 블로킹되며, 같은 데이터센터 내에서 주로 사용합니다
- **Saga 패턴**은 보상 트랜잭션 체인으로 분산 롤백을 구현하며, 격리성을 포기하는 대신 가용성을 확보합니다
- **Spanner의 TrueTime**은 GPS/원자시계로 전역 시간 순서를 보장하여 외부 일관성을 달성합니다
- **Calvin**은 실행 전에 순서를 합의하는 결정론적 접근으로 2PC 없이 분산 트랜잭션을 처리합니다
- 최선의 전략은 **데이터 모델링으로 분산 트랜잭션을 회피**하는 것이며, 필요하다면 Saga → 2PC 순서로 검토합니다
