# B-트리와 B+트리

## 왜 B-트리가 중요한가

B-트리는 **관계형 데이터베이스 인덱스의 표준 자료구조**입니다. PostgreSQL, MySQL, Oracle 모두 B+트리를 기본 인덱스로 사용합니다. sql-07에서 Index Scan이 어떻게 동작하는지, sql-08에서 인덱스를 왜 이렇게 설계하는지의 근본적인 이유가 B-트리 구조에 있습니다.

> **핵심 직관**: B-트리는 "디스크 I/O 횟수를 최소화하도록 설계된 균형 탐색 트리"입니다. 한 노드에 수백 개의 키를 담아 트리 높이를 3-4로 유지하므로, 수억 건의 데이터에서도 3-4번의 디스크 읽기로 원하는 행을 찾습니다.

## 1. B-트리 구조

```
B-트리 (차수 m=4):

  각 노드는 최대 3개 키, 4개 자식 포인터를 가짐

              [30 | 60]                    ← 루트 (레벨 0)
             /    |    \
    [10 | 20]  [40 | 50]  [70 | 80 | 90]  ← 내부 (레벨 1)
    / | \      / | \      / | | \
  잎들...    잎들...    잎들...             ← 리프 (레벨 2)

  불변식:
  1. 모든 리프는 같은 깊이 (균형)
  2. 각 노드: ceil(m/2) - 1 ≤ 키 수 ≤ m - 1
  3. 키는 정렬되어 있음
  4. 자식 수 = 키 수 + 1
```

```
실제 DB에서의 B-트리 크기 계산:

  페이지 크기: 8KB
  키 크기: 8 bytes (bigint)
  포인터 크기: 6 bytes
  → 한 페이지에 약 500개 키

  높이 3: 500³ = 1.25억 행 커버
  높이 4: 500⁴ = 625억 행 커버

  → 사실상 어떤 테이블이든 3-4번의 I/O로 검색 가능
```

## 2. B+트리 (실제 DB가 사용하는 형태)

```
B+트리 vs B-트리:

  B-트리:  내부 노드에도 데이터 저장
  B+트리: 데이터는 리프에만, 내부는 키만

  B+트리의 리프 노드는 연결 리스트로 연결:

  내부: [30 | 60]
       /    |    \
  리프: [10,20] ↔ [30,40,50] ↔ [60,70,80]
        (데이터)   (데이터)     (데이터)

  장점:
  1. 내부 노드에 키가 더 많이 들어감 → 트리 높이 감소
  2. 리프 연결 → 범위 검색이 빠름 (순차 스캔)
  3. 모든 검색이 리프까지 도달 → 일관된 성능
```

| 비교 | B-트리 | B+트리 |
|------|--------|--------|
| 데이터 위치 | 모든 노드 | 리프만 |
| 범위 검색 | 중위 순회 필요 | 리프 연결 리스트 |
| 트리 높이 | 상대적 높음 | 상대적 낮음 |
| 점 검색 | 조기 종료 가능 | 항상 리프까지 |
| DB 사용 | 거의 없음 | PostgreSQL, MySQL |

## 3. 삽입과 분할

```
B+트리 삽입 (차수 4, 키 25 삽입):

  Before:
  [30 | 60]
  /    |    \
  [10,20] [30,40,50] [60,70,80]

  Step 1: 25는 첫 번째 리프에 → [10,20,25] (OK, 여유 있음)

  만약 리프가 가득 차면 (키 35 삽입):
  [30,40,50]에 35 추가 → [30,35,40,50] 오버플로!

  Step 2: 리프 분할
  [30,35] | [40,50]
  중간 키(40)를 부모로 올림

  After:
  [30 | 40 | 60]
  /   |    |    \
  [10,20,25] [30,35] [40,50] [60,70,80]

  부모도 오버플로 → 부모도 분할 (cascade)
```

## 4. 인덱스 종류

```
Clustered vs Non-clustered:

  Clustered Index (클러스터드)
  └─ 테이블 데이터 자체가 인덱스 순서로 정렬됨
     → 테이블당 1개만 가능
     → 범위 검색 매우 빠름 (순차 I/O)
     → MySQL InnoDB: PRIMARY KEY가 클러스터드

  Non-clustered Index (넌클러스터드)
  └─ 별도의 인덱스 구조 + 데이터 위치 포인터
     → 테이블당 여러 개 가능
     → 포인트 검색에 적합, 범위는 랜덤 I/O
     → PostgreSQL: 모든 인덱스가 넌클러스터드
```

| 종류 | 정렬 기준 | 개수 | 범위 검색 | 쓰기 비용 |
|------|----------|------|----------|----------|
| Clustered | 데이터 자체 정렬 | 1개 | 매우 빠름 | 높음 |
| Non-clustered | 별도 구조 | 여러 개 | 랜덤 I/O | 중간 |
| Covering | 필요 컬럼 포함 | 여러 개 | Index Only | 중간 |

> **핵심 직관**: MySQL과 PostgreSQL의 인덱스 동작이 다른 이유가 여기 있습니다. MySQL(InnoDB)은 PK가 클러스터드이므로 PK 범위 검색이 매우 빠르지만, Secondary Index는 PK를 통해 데이터에 접근하므로 한 단계가 추가됩니다.

## 5. 인덱스 설계 원칙

```
복합 인덱스 설계 (sql-08 복습 + 내부 원리):

  INDEX(a, b, c)의 B+트리 구조:

  a로 먼저 정렬 → a 같으면 b로 → b 같으면 c로

  ┌─────────────────────┐
  │ (1,A,X) (1,A,Y)     │ ← a=1, b=A
  │ (1,B,X) (1,B,Z)     │ ← a=1, b=B
  │ (2,A,X) (2,A,Y)     │ ← a=2, b=A
  └─────────────────────┘

  사용 가능한 쿼리:
  WHERE a = 1                    ✅ (선두 컬럼)
  WHERE a = 1 AND b = 'A'       ✅ (선두 2개)
  WHERE a = 1 AND b = 'A' AND c ✅ (전체)
  WHERE b = 'A'                  ❌ (선두 누락!)
  WHERE a = 1 AND c = 'X'       △ (b 건너뜀, a만 사용)
```

## 6. B-트리의 한계와 대안

```
B-트리가 비효율적인 경우:

  1. 쓰기 집중 워크로드
     → B-트리는 제자리 갱신 (랜덤 I/O)
     → 대안: LSM 트리 (dbi-03)

  2. 전문 검색 (Full-text Search)
     → B-트리는 접두사 매칭만 가능
     → 대안: GIN (역인덱스)

  3. 다차원 검색 (공간, 벡터)
     → B-트리는 1차원 정렬만
     → 대안: R-트리, HNSW (벡터 DB)

  4. 빈번한 갱신 + 범위 검색
     → 페이지 분할로 단편화 발생
     → 정기적 REINDEX 필요
```

> **핵심 직관**: B+트리는 "읽기 최적화된 범용 자료구조"이지만 만능은 아닙니다. 워크로드 특성에 따라 LSM, GIN, R-트리 등 특화된 구조를 선택해야 합니다.

## 핵심 정리

- B+트리는 **리프에만 데이터를 저장**하고 리프를 연결 리스트로 연결하여 범위 검색을 최적화합니다
- 한 노드에 수백 개의 키를 담아 트리 높이를 **3-4로 유지**하므로, 수억 건에서도 3-4번의 I/O로 검색합니다
- 리프가 가득 차면 **분할(split)**이 발생하며, 이 비용이 B-트리의 쓰기 오버헤드입니다
- **Clustered Index**는 데이터 자체를 정렬하고, **Non-clustered**는 별도 구조로 데이터 위치를 가리킵니다
- 복합 인덱스는 **선두 컬럼부터 순서대로** 사용되며, 중간 컬럼을 건너뛸 수 없습니다
