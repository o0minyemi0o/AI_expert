# 고급 데코레이터

## 왜 고급 데코레이터를 배워야 하는가

데코레이터는 Python에서 **횡단 관심사(cross-cutting concerns)**를 깔끔하게 처리하는 도구입니다. 로깅, 캐싱, 인증, 재시도 로직 등을 함수 본문과 분리할 수 있습니다. 단순한 데코레이터는 많이 사용하지만, **파라미터가 있는 데코레이터**, **클래스 데코레이터**, **데코레이터 스택 순서**를 정확히 이해하는 것은 다른 수준의 능력입니다.

---

## 1. 데코레이터의 본질

데코레이터는 **함수를 받아 함수를 반환하는 고차 함수**입니다.

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}")
        result = func(*args, **kwargs)
        print(f"Done")
        return result
    return wrapper

@my_decorator
def greet(name):
    return f"Hello, {name}"

# @my_decorator는 다음과 동일:
# greet = my_decorator(greet)
```

> **핵심 직관**: `@decorator`는 문법적 설탕입니다. `func = decorator(func)`와 정확히 같습니다.

---

## 2. functools.wraps의 중요성

데코레이터가 원래 함수를 감싸면, `__name__`, `__doc__`, `__module__` 등의 메타데이터가 사라집니다.

```python
from functools import wraps

def good_decorator(func):
    @wraps(func)  # 원래 함수의 메타데이터 보존
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@good_decorator
def my_func():
    """이 함수의 독스트링"""
    pass

print(my_func.__name__)      # "my_func" (wraps 없으면 "wrapper")
print(my_func.__doc__)       # "이 함수의 독스트링"
print(my_func.__wrapped__)   # 원래 함수에 접근 가능
```

`@wraps`는 내부적으로 `functools.update_wrapper`를 호출하며, `__wrapped__` 속성을 추가하여 원래 함수에 접근할 수 있게 합니다.

---

## 3. 파라미터가 있는 데코레이터

인자를 받는 데코레이터는 **3중 중첩 함수**가 됩니다.

```python
from functools import wraps
import time

def retry(max_attempts=3, delay=1.0):
    """재시도 데코레이터"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            last_exception = None
            for attempt in range(1, max_attempts + 1):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    last_exception = e
                    print(f"Attempt {attempt}/{max_attempts} failed: {e}")
                    if attempt < max_attempts:
                        time.sleep(delay)
            raise last_exception
        return wrapper
    return decorator

@retry(max_attempts=5, delay=0.5)
def fetch_data(url):
    # 네트워크 호출
    pass

# 풀어쓰면: fetch_data = retry(max_attempts=5, delay=0.5)(fetch_data)
```

### 호출 체인

```
retry(max_attempts=5, delay=0.5)  → decorator 함수 반환
decorator(fetch_data)              → wrapper 함수 반환
wrapper(url)                       → 실제 실행
```

---

## 4. 괄호 유무 모두 지원하는 데코레이터

`@decorator`와 `@decorator(args)` 모두 사용 가능하게 만드는 패턴입니다.

```python
from functools import wraps

def cache(func=None, *, maxsize=128):
    def decorator(fn):
        memo = {}
        @wraps(fn)
        def wrapper(*args):
            if args not in memo:
                if len(memo) >= maxsize:
                    memo.pop(next(iter(memo)))
                memo[args] = fn(*args)
            return memo[args]
        wrapper.cache = memo
        return wrapper

    if func is not None:
        # @cache 형태 (괄호 없이 사용)
        return decorator(func)
    # @cache(maxsize=256) 형태
    return decorator

@cache
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

@cache(maxsize=256)
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n-1)
```

> **핵심 직관**: `func=None`을 키워드 전용 인자 앞에 두어, 괄호 없이 호출하면 `func`에 함수가 들어오고, 괄호와 함께 호출하면 `func`은 `None`이 됩니다.

---

## 5. 클래스 데코레이터

클래스를 데코레이터로 사용하거나, 클래스에 데코레이터를 적용할 수 있습니다.

### 클래스를 데코레이터로 사용

`__call__`을 구현하면 클래스가 함수처럼 동작합니다.

```python
class Timer:
    def __init__(self, func):
        wraps(func)(self)
        self.func = func
        self.total_time = 0
        self.call_count = 0

    def __call__(self, *args, **kwargs):
        start = time.time()
        result = self.func(*args, **kwargs)
        elapsed = time.time() - start
        self.total_time += elapsed
        self.call_count += 1
        return result

    def stats(self):
        avg = self.total_time / self.call_count if self.call_count else 0
        return f"{self.call_count} calls, avg {avg:.4f}s"

@Timer
def slow_function(n):
    time.sleep(0.01)
    return n ** 2

slow_function(10)
slow_function(20)
print(slow_function.stats())  # "2 calls, avg 0.01xxs"
```

### 클래스에 데코레이터 적용

```python
def add_repr(cls):
    """자동으로 __repr__을 추가하는 클래스 데코레이터"""
    def __repr__(self):
        attrs = ", ".join(f"{k}={v!r}" for k, v in self.__dict__.items())
        return f"{cls.__name__}({attrs})"
    cls.__repr__ = __repr__
    return cls

@add_repr
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

print(Point(1, 2))  # Point(x=1, y=2)
```

> **핵심 직관**: `dataclasses.dataclass`가 바로 클래스 데코레이터입니다. `__init__`, `__repr__`, `__eq__` 등을 자동 생성합니다.

---

## 6. 데코레이터 스택 순서

여러 데코레이터를 쌓으면 **아래에서 위로** 적용됩니다.

```python
@decorator_a
@decorator_b
@decorator_c
def func():
    pass

# 동등한 코드:
# func = decorator_a(decorator_b(decorator_c(func)))
```

**실행 순서**는 반대입니다: `decorator_a`의 wrapper가 가장 먼저 실행되고, `decorator_c`의 wrapper가 가장 나중에 (실제 함수 바로 전에) 실행됩니다.

```python
def log(name):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            print(f"[{name}] Enter")
            result = func(*args, **kwargs)
            print(f"[{name}] Exit")
            return result
        return wrapper
    return decorator

@log("A")
@log("B")
def hello():
    print("Hello!")

hello()
# [A] Enter
# [B] Enter
# Hello!
# [B] Exit
# [A] Exit
```

> **핵심 직관**: 데코레이터 스택은 **양파 껍질**과 같습니다. 바깥 데코레이터가 먼저 진입하고, 가장 안쪽에서 실제 함수가 실행되고, 다시 바깥으로 나옵니다.

---

## 7. 메서드 데코레이터와 디스크립터

클래스 메서드에 데코레이터를 적용할 때 `self`가 문제될 수 있습니다.

```python
from functools import wraps

def validate_positive(func):
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        for arg in args:
            if isinstance(arg, (int, float)) and arg < 0:
                raise ValueError(f"Negative value: {arg}")
        return func(self, *args, **kwargs)
    return wrapper

class Calculator:
    @validate_positive
    def square_root(self, x):
        return x ** 0.5

calc = Calculator()
calc.square_root(4)   # 2.0
calc.square_root(-1)  # ValueError
```

---

## 8. ML에서의 의미

### torch.no_grad() 데코레이터

PyTorch의 `@torch.no_grad()`는 추론 시 그래디언트 계산을 비활성화합니다. 이는 컨텍스트 매니저와 데코레이터 양쪽으로 쓸 수 있는 패턴입니다.

### API 엔드포인트 데코레이터

Flask의 `@app.route()`, FastAPI의 `@app.get()` 등 ML 모델 서빙에서 핵심적으로 사용됩니다.

### 실험 추적

MLflow의 `@mlflow.start_run` 등 실험 추적 데코레이터는 함수 실행 전후에 자동으로 메트릭을 기록합니다.

---

## 핵심 정리

1. 데코레이터는 **함수를 받아 함수를 반환**하는 고차 함수이며, `@`는 문법적 설탕이다.
2. **`functools.wraps`**는 반드시 사용하여 원래 함수의 메타데이터를 보존해야 한다.
3. **파라미터 데코레이터**는 3중 중첩 함수 구조: `args → decorator → wrapper`.
4. **스택 순서**: 아래에서 위로 적용(wrapping), 위에서 아래로 실행(양파 구조).
5. **클래스 데코레이터**(`dataclass` 등)는 클래스 자체를 변형하는 강력한 도구이다.
