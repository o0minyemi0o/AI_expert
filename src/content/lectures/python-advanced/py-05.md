# 디스크립터 프로토콜

## 왜 디스크립터를 배워야 하는가

`@property`, `@classmethod`, `@staticmethod`는 모두 **디스크립터(descriptor)**입니다. Django ORM의 필드, SQLAlchemy의 컬럼, PyTorch의 `nn.Parameter` 등 프레임워크의 "마법 같은" 속성 접근은 디스크립터로 구현됩니다. 디스크립터는 Python의 **속성 접근 메커니즘의 핵심**이며, 이를 이해하면 `obj.attr`이 실제로 어떤 과정을 거치는지 정확히 알 수 있습니다.

---

## 1. 디스크립터란 무엇인가

디스크립터는 `__get__`, `__set__`, `__delete__` 중 하나 이상을 구현한 객체입니다. **다른 클래스의 속성으로** 사용될 때 속성 접근을 가로챕니다.

```python
class Verbose:
    """간단한 디스크립터"""
    def __get__(self, obj, objtype=None):
        print(f"__get__ called: obj={obj}, type={objtype}")
        return 42

    def __set__(self, obj, value):
        print(f"__set__ called: obj={obj}, value={value}")

    def __delete__(self, obj):
        print(f"__delete__ called: obj={obj}")

class MyClass:
    attr = Verbose()  # 디스크립터를 클래스 속성으로 배치

obj = MyClass()
obj.attr           # __get__ called: obj=<MyClass>, type=<class 'MyClass'>
obj.attr = 10      # __set__ called: obj=<MyClass>, value=10
del obj.attr       # __delete__ called: obj=<MyClass>
MyClass.attr       # __get__ called: obj=None, type=<class 'MyClass'>
```

> **핵심 직관**: 디스크립터는 "속성 접근을 가로채는 객체"입니다. `obj.attr`이 단순한 값 조회가 아니라 **코드 실행**이 될 수 있게 합니다.

---

## 2. 데이터 디스크립터 vs 비데이터 디스크립터

| 종류 | 구현 메서드 | 우선순위 | 예시 |
|------|-----------|---------|------|
| **데이터 디스크립터** | `__get__` + `__set__` (또는 `__delete__`) | 인스턴스 `__dict__`보다 **높음** | `property` |
| **비데이터 디스크립터** | `__get__`만 | 인스턴스 `__dict__`보다 **낮음** | 일반 함수, `staticmethod` |

### 속성 조회 순서 (MRO)

`obj.attr`을 실행할 때 Python은 다음 순서로 찾습니다:

```
1. 데이터 디스크립터 (클래스/부모 클래스의 __get__ + __set__)
2. 인스턴스 __dict__
3. 비데이터 디스크립터 또는 일반 클래스 속성
```

```python
class DataDesc:
    """데이터 디스크립터: __get__과 __set__ 모두 구현"""
    def __get__(self, obj, objtype=None):
        return "from data descriptor"
    def __set__(self, obj, value):
        pass

class NonDataDesc:
    """비데이터 디스크립터: __get__만 구현"""
    def __get__(self, obj, objtype=None):
        return "from non-data descriptor"

class MyClass:
    data = DataDesc()
    non_data = NonDataDesc()

obj = MyClass()
obj.__dict__["data"] = "from instance"
obj.__dict__["non_data"] = "from instance"

print(obj.data)      # "from data descriptor" (데이터 디스크립터 우선)
print(obj.non_data)  # "from instance" (인스턴스 __dict__ 우선)
```

이 차이가 중요한 이유: `@property`는 데이터 디스크립터이므로 인스턴스 딕셔너리에 같은 이름의 값이 있어도 항상 property의 getter가 호출됩니다.

---

## 3. property의 내부 구현

`property`는 Python의 내장 데이터 디스크립터입니다. 순수 Python으로 재구현하면:

```python
class Property:
    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        self.__doc__ = doc or (fget.__doc__ if fget else None)

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self  # 클래스에서 접근하면 디스크립터 자체 반환
        if self.fget is None:
            raise AttributeError("unreadable attribute")
        return self.fget(obj)

    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError("can't set attribute")
        self.fset(obj, value)

    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError("can't delete attribute")
        self.fdel(obj)

    def getter(self, fget):
        return type(self)(fget, self.fset, self.fdel, self.__doc__)

    def setter(self, fset):
        return type(self)(self.fget, fset, self.fdel, self.__doc__)

    def deleter(self, fdel):
        return type(self)(self.fget, self.fset, fdel, self.__doc__)
```

`@property`가 `getter → setter → deleter` 체이닝을 지원하는 이유가 이 구조에서 드러납니다. 각 데코레이터 호출이 새 `Property` 인스턴스를 반환합니다.

---

## 4. 함수도 디스크립터이다

Python에서 함수는 비데이터 디스크립터입니다. `__get__`을 구현하여 메서드 바인딩을 수행합니다.

```python
class Dog:
    def bark(self):
        return "Woof!"

dog = Dog()

# 클래스에서 접근: 일반 함수
print(Dog.bark)        # <function Dog.bark at 0x...>

# 인스턴스에서 접근: 바운드 메서드 (self가 자동 바인딩)
print(dog.bark)        # <bound method Dog.bark of <Dog object>>

# 내부적으로 일어나는 일:
# dog.bark → Dog.__dict__["bark"].__get__(dog, Dog)
# → bark 함수에 dog이 self로 바인딩된 메서드 반환
```

이것이 `self`가 자동으로 전달되는 메커니즘입니다. `__get__`이 `functools.partial(bark, dog)`과 같은 역할을 합니다.

---

## 5. 실전 패턴: 타입 검증 디스크립터

ORM 필드처럼 타입을 검증하는 디스크립터를 만들어봅니다.

```python
class Typed:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type

    def __set_name__(self, owner, name):
        # Python 3.6+: 디스크립터가 클래스에 할당될 때 자동 호출
        self.name = name

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        return obj.__dict__.get(self.name)

    def __set__(self, obj, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(
                f"{self.name} must be {self.expected_type.__name__}, "
                f"got {type(value).__name__}"
            )
        obj.__dict__[self.name] = value

class User:
    name = Typed("name", str)
    age = Typed("age", int)
    email = Typed("email", str)

    def __init__(self, name, age, email):
        self.name = name
        self.age = age
        self.email = email

user = User("Alice", 30, "alice@example.com")  # OK
user = User("Bob", "thirty", "bob@example.com")  # TypeError
```

### `__set_name__` (Python 3.6+)

`__set_name__(self, owner, name)`은 디스크립터가 클래스에 할당될 때 자동으로 호출됩니다. 이 덕분에 `Typed("name", str)` 대신 `Typed(str)`만 쓸 수 있습니다.

```python
class Typed:
    def __init__(self, expected_type):
        self.expected_type = expected_type

    def __set_name__(self, owner, name):
        self.name = name  # 자동으로 속성 이름을 알 수 있음

    # ... __get__, __set__은 동일

class User:
    name = Typed(str)    # __set_name__(User, "name") 자동 호출
    age = Typed(int)     # __set_name__(User, "age") 자동 호출
```

---

## 6. 실전 패턴: 지연 로딩 (Lazy Loading)

비용이 큰 연산의 결과를 처음 접근할 때만 계산하고 캐시합니다.

```python
class LazyProperty:
    def __init__(self, func):
        self.func = func
        self.name = func.__name__

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        # 계산 결과를 인스턴스 __dict__에 저장
        value = self.func(obj)
        obj.__dict__[self.name] = value  # 다음 접근부터 디스크립터 우회
        return value

class DataAnalyzer:
    def __init__(self, data):
        self.data = data

    @LazyProperty
    def statistics(self):
        print("Computing statistics (expensive)...")
        return {
            "mean": sum(self.data) / len(self.data),
            "max": max(self.data),
            "min": min(self.data),
        }

analyzer = DataAnalyzer([1, 2, 3, 4, 5])
print(analyzer.statistics)  # "Computing..." 출력 후 결과
print(analyzer.statistics)  # 캐시된 값 (출력 없음)
```

`LazyProperty`는 비데이터 디스크립터(`__get__`만 구현)이므로, 인스턴스 `__dict__`에 같은 이름의 값이 저장되면 이후부터는 인스턴스 딕셔너리가 우선됩니다. 이것이 "자기 소멸" 캐싱입니다.

> **핵심 직관**: `functools.cached_property`가 바로 이 패턴입니다. 비데이터 디스크립터의 "인스턴스 __dict__보다 우선순위가 낮다"는 성질을 활용합니다.

---

## 7. classmethod와 staticmethod의 디스크립터 구현

```python
class ClassMethod:
    def __init__(self, func):
        self.func = func

    def __get__(self, obj, objtype=None):
        if objtype is None:
            objtype = type(obj)
        # cls를 첫 번째 인자로 바인딩
        def method(*args, **kwargs):
            return self.func(objtype, *args, **kwargs)
        return method

class StaticMethod:
    def __init__(self, func):
        self.func = func

    def __get__(self, obj, objtype=None):
        # 바인딩 없이 원래 함수 그대로 반환
        return self.func
```

`staticmethod`는 디스크립터의 바인딩 메커니즘을 **비활성화**하는 디스크립터입니다. `self`도 `cls`도 바인딩하지 않습니다.

---

## 8. `__slots__`와 디스크립터

`__slots__`를 정의하면 Python이 각 슬롯에 대해 **데이터 디스크립터를 자동 생성**합니다.

```python
class Point:
    __slots__ = ("x", "y")

# Point.x는 디스크립터
print(type(Point.x))  # <class 'member_descriptor'>

p = Point()
p.x = 10  # Point.x.__set__(p, 10)
print(p.x)  # Point.x.__get__(p, Point) → 10
```

`__slots__`가 `__dict__`를 없애고 메모리를 절약하는 이유: 인스턴스별 딕셔너리 대신 클래스 레벨의 디스크립터가 고정 오프셋으로 직접 접근합니다.

---

## 9. ML에서의 의미

### PyTorch nn.Module의 속성 관리

`nn.Module`은 `__setattr__`을 오버라이드하여, `nn.Parameter`가 할당되면 자동으로 `parameters()`에 등록합니다. 이것은 디스크립터는 아니지만, 속성 접근 커스터마이징의 같은 철학입니다.

### ORM 필드

Django의 `models.CharField()`, SQLAlchemy의 `Column()` 등은 모두 디스크립터입니다. 모델 클래스의 속성으로 정의되어 데이터베이스 읽기/쓰기를 투명하게 처리합니다.

### 설정 관리

ML 실험의 하이퍼파라미터를 디스크립터로 관리하면, 타입 검증과 범위 체크를 속성 접근 시점에 자동으로 수행할 수 있습니다.

---

## 핵심 정리

1. **디스크립터**는 `__get__`/`__set__`/`__delete__`를 구현한 객체로, 다른 클래스의 속성으로 사용될 때 **속성 접근을 가로챈다**.
2. **데이터 디스크립터**(`__get__` + `__set__`)는 인스턴스 `__dict__`보다 우선하고, **비데이터 디스크립터**(`__get__`만)는 인스턴스 `__dict__`보다 후순위이다.
3. **`property`**, **`classmethod`**, **`staticmethod`**, **일반 함수의 메서드 바인딩**이 모두 디스크립터로 구현된다.
4. **`__set_name__`**(3.6+)으로 디스크립터가 할당된 속성 이름을 자동으로 알 수 있다.
5. 디스크립터의 우선순위 규칙을 이해하면, `cached_property`, `__slots__` 등 Python의 많은 메커니즘이 자연스럽게 이해된다.
