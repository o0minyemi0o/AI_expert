# Import 시스템 내부

## 왜 Import 시스템을 이해해야 하는가

`import numpy`는 간단해 보이지만, 그 뒤에서 Python은 **모듈 검색, 로딩, 컴파일, 캐싱**이라는 복잡한 과정을 수행합니다. 패키지 구조 설계, 순환 import 해결, 동적 로딩, 플러그인 시스템 구축에는 이 내부 메커니즘을 정확히 이해해야 합니다. 대규모 프로젝트의 "import 지옥"을 해결하는 열쇠입니다.

---

## 1. import의 전체 과정

`import foo`가 실행될 때:

```
1. sys.modules에서 'foo' 검색 (캐시 확인)
   → 있으면 즉시 반환 (이미 로드됨)
   → 없으면 다음 단계로

2. Finder로 모듈 위치 탐색
   → sys.meta_path의 각 finder에게 질의
   → ModuleSpec 반환 (로더 + 경로 정보)

3. Loader로 모듈 로딩
   → 모듈 객체 생성
   → sys.modules에 등록 (순환 import 방지)
   → 모듈 코드 실행

4. 이름 바인딩
   → import foo: foo 이름에 모듈 바인딩
   → from foo import bar: bar 이름에 속성 바인딩
```

```python
import sys

# 이미 로드된 모듈 확인
print("json" in sys.modules)  # False
import json
print("json" in sys.modules)  # True
print(sys.modules["json"])     # <module 'json' from '...'>
```

> **핵심 직관**: `sys.modules`는 **모듈 캐시**입니다. 같은 모듈을 여러 번 import해도 한 번만 로드됩니다. 모듈 코드는 **최초 import 시 한 번만** 실행됩니다.

---

## 2. sys.path: 모듈 검색 경로

Python이 모듈을 찾는 디렉터리 목록입니다.

```python
import sys

for p in sys.path:
    print(p)

# 일반적인 순서:
# 1. '' (현재 디렉터리)
# 2. PYTHONPATH 환경변수의 경로들
# 3. 표준 라이브러리 경로
# 4. site-packages (pip 설치 패키지)
```

### 검색 순서의 함정

```python
# 프로젝트에 random.py 파일이 있다면:
import random  # 표준 라이브러리가 아닌 프로젝트의 random.py가 로드됨!
```

현재 디렉터리(`''`)가 `sys.path`의 맨 앞에 있으므로, 표준 라이브러리와 같은 이름의 파일이 우선됩니다. 이것이 "내 random.py가 표준 random을 가렸다"는 흔한 실수의 원인입니다.

---

## 3. Finder와 Loader

### Finder: 모듈을 어디서 찾을지

```python
import sys

# 기본 meta_path finders
for finder in sys.meta_path:
    print(type(finder).__name__)

# BuiltinImporter    — 내장 모듈 (sys, builtins)
# FrozenImporter     — 동결 모듈 (importlib._bootstrap)
# PathFinder         — 파일 시스템 검색 (대부분의 모듈)
```

### 커스텀 Finder

```python
import importlib.abc
import sys

class DebugFinder(importlib.abc.MetaPathFinder):
    def find_module(self, fullname, path=None):
        print(f"Looking for: {fullname}")
        return None  # None → 다음 finder에게 위임

# sys.meta_path 맨 앞에 추가
sys.meta_path.insert(0, DebugFinder())

import json  # "Looking for: json" 출력 후 정상 로드
```

### ModuleSpec

Finder가 반환하는 객체로, 모듈의 메타데이터를 담습니다.

```python
import importlib.util

spec = importlib.util.find_spec("json")
print(spec.name)     # 'json'
print(spec.origin)   # '/path/to/json/__init__.py'
print(spec.loader)   # <_frozen_importlib_external.SourceFileLoader>
print(spec.submodule_search_locations)  # ['/path/to/json']
```

---

## 4. importlib: 프로그래밍적 import

### 동적 모듈 로딩

```python
import importlib

# 문자열로 모듈 import
module_name = "json"
mod = importlib.import_module(module_name)
print(mod.dumps({"key": "value"}))

# 서브모듈
os_path = importlib.import_module("os.path")
print(os_path.join("/a", "b"))
```

### 모듈 리로드

```python
import importlib
import my_module

# 개발 중 코드를 수정한 후
importlib.reload(my_module)  # 모듈 코드를 다시 실행
```

`reload()`는 `sys.modules`에서 모듈을 삭제하지 않고, 기존 모듈 객체에 새 코드를 실행합니다. 이전 참조들은 여전히 유효합니다.

### 경로에서 직접 로딩

```python
import importlib.util

spec = importlib.util.spec_from_file_location(
    "my_config",
    "/path/to/config.py"
)
config = importlib.util.module_from_spec(spec)
spec.loader.exec_module(config)

print(config.SETTING)  # config.py의 SETTING 변수
```

---

## 5. 패키지 구조

### `__init__.py`의 역할

```
mypackage/
    __init__.py      ← 패키지 초기화
    module_a.py
    module_b.py
    subpackage/
        __init__.py
        module_c.py
```

```python
# mypackage/__init__.py
from .module_a import ClassA
from .module_b import ClassB

__all__ = ["ClassA", "ClassB"]  # from mypackage import * 에 영향

# 사용자 코드
from mypackage import ClassA  # __init__.py 통해 접근
```

### 상대 import vs 절대 import

```python
# mypackage/module_a.py 안에서

# 절대 import
from mypackage.module_b import func_b

# 상대 import
from .module_b import func_b       # 같은 패키지
from ..other_package import something  # 상위 패키지
```

### Namespace 패키지 (PEP 420)

`__init__.py` 없이도 패키지를 만들 수 있습니다 (Python 3.3+). 여러 디렉터리에 분산된 패키지를 하나로 합칩니다.

```
site-packages/
    mylib/           ← __init__.py 없음
        part_a.py
another-dir/
    mylib/           ← __init__.py 없음
        part_b.py

# 두 디렉터리의 mylib이 하나의 네임스페이스 패키지로 합쳐짐
import mylib.part_a
import mylib.part_b
```

---

## 6. 순환 import

### 문제 상황

```python
# a.py
from b import func_b

def func_a():
    return "A"

# b.py
from a import func_a  # ImportError!

def func_b():
    return "B"
```

### 왜 실패하는가

```
1. import a 시작
2. a.py 실행 → from b import func_b → import b 시작
3. b.py 실행 → from a import func_a
4. sys.modules["a"]가 있지만, func_a가 아직 정의되지 않음!
   (a.py는 2번에서 멈춰있으므로)
5. ImportError: cannot import name 'func_a'
```

### 해결 방법

```python
# 방법 1: import를 함수 안으로 이동
# a.py
def func_a():
    from b import func_b  # 실제 호출 시점에 import
    return func_b()

# 방법 2: 모듈 레벨 import (속성 접근)
# a.py
import b

def func_a():
    return b.func_b()  # 모듈 객체를 통해 접근

# 방법 3: 구조 리팩터링 (가장 권장)
# 공통 의존성을 별도 모듈로 분리
```

> **핵심 직관**: 순환 import는 "A가 B를 필요로 하고, B가 A를 필요로 하는데, 둘 다 아직 완성되지 않았다"는 문제입니다. 가장 좋은 해결은 **의존 구조를 리팩터링**하는 것입니다.

---

## 7. `__all__`과 `import *`

```python
# mymodule.py
__all__ = ["public_func", "PublicClass"]

def public_func():
    pass

class PublicClass:
    pass

def _private_func():
    pass

# 다른 파일에서
from mymodule import *  # public_func, PublicClass만 import
# _private_func는 import되지 않음
```

`__all__`은 `from module import *`의 동작을 제어합니다. 정의되지 않으면 `_`로 시작하지 않는 모든 이름이 export됩니다.

---

## 8. 지연 로딩 (Lazy Import)

무거운 모듈의 import를 실제 사용 시점까지 미루는 패턴입니다.

```python
# 방법 1: 함수 내부 import
def process_image(path):
    import cv2  # 이 함수가 호출될 때만 import
    img = cv2.imread(path)
    return img

# 방법 2: __getattr__을 이용한 모듈 레벨 지연 로딩
# mypackage/__init__.py
def __getattr__(name):
    if name == "heavy_module":
        import mypackage.heavy_module as mod
        globals()["heavy_module"] = mod
        return mod
    raise AttributeError(f"module has no attribute {name}")

# Python 3.7+에서 모듈의 __getattr__이 지원됩니다
```

---

## 9. ML에서의 의미

### 플러그인 시스템

ML 프레임워크에서 모델, 데이터셋, 옵티마이저 등을 플러그인으로 동적 로딩합니다.

```python
import importlib
import os

def load_plugins(plugin_dir):
    plugins = {}
    for filename in os.listdir(plugin_dir):
        if filename.endswith(".py") and not filename.startswith("_"):
            name = filename[:-3]
            spec = importlib.util.spec_from_file_location(
                name, os.path.join(plugin_dir, filename)
            )
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            if hasattr(module, "register"):
                module.register(plugins)
    return plugins
```

### 선택적 의존성

```python
try:
    import torch
    HAS_TORCH = True
except ImportError:
    HAS_TORCH = False

def train(model, data):
    if not HAS_TORCH:
        raise ImportError("PyTorch is required for training")
    # ...
```

### 시작 시간 최적화

ML 서빙 서버에서 불필요한 모듈의 eager import를 피하면 콜드 스타트 시간을 줄일 수 있습니다.

---

## 핵심 정리

1. `import`는 `sys.modules` 캐시 확인 → Finder로 탐색 → Loader로 로딩 → 이름 바인딩의 과정을 거친다.
2. **`sys.modules`**는 모듈 캐시이며, 같은 모듈은 한 번만 로드된다. `sys.path`는 파일 시스템 검색 경로이다.
3. **순환 import**는 두 모듈이 서로를 상위 레벨에서 import할 때 발생하며, **구조 리팩터링**이 최선의 해결이다.
4. **`importlib`**로 동적 import, 파일 경로 직접 로딩, 모듈 리로드 등 프로그래밍적 제어가 가능하다.
5. **지연 로딩**(`__getattr__` 또는 함수 내 import)으로 무거운 모듈의 import를 미뤄 시작 시간을 최적화할 수 있다.
