# 메타클래스와 타입 시스템

## 왜 메타클래스를 배워야 하는가

Python에서 **클래스도 객체**입니다. 클래스를 만드는 것은 `type`이라는 "클래스의 클래스", 즉 **메타클래스(metaclass)**입니다. Django ORM의 `Model`, SQLAlchemy의 선언적 베이스, pytest의 테스트 수집 등 프레임워크의 "마법"은 대부분 메타클래스로 구현됩니다. 메타클래스를 이해하면 프레임워크를 읽고 설계할 수 있게 됩니다.

---

## 1. Python에서 클래스는 객체이다

Python에서는 모든 것이 객체입니다. 클래스 자체도 예외가 아닙니다.

```python
class Dog:
    pass

print(type(Dog))      # <class 'type'>
print(type(int))      # <class 'type'>
print(type(type))     # <class 'type'>  ← type 자기 자신!
```

`Dog`은 `type`의 인스턴스이고, `type`은 자기 자신의 인스턴스입니다. 이것이 Python 타입 시스템의 뿌리입니다.

### 객체 계층 구조

```
type ──(instance of)──→ type (자기 참조)
  │
  ├── int
  ├── str
  ├── Dog
  └── ...

object ──(subclass of)──→ (없음, 최상위)
  │
  ├── int
  ├── str
  ├── Dog
  └── type  ← type도 object의 서브클래스
```

> **핵심 직관**: `type`은 모든 클래스를 만드는 공장이고, `object`는 모든 클래스의 조상입니다. `type`은 `object`의 서브클래스이면서, `object`는 `type`의 인스턴스입니다 (순환 관계).

---

## 2. type()으로 동적 클래스 생성

`class` 키워드는 사실 `type()` 호출의 문법적 설탕(syntactic sugar)입니다.

```python
# 일반적인 클래스 정의
class Dog:
    species = "Canis familiaris"
    def bark(self):
        return "Woof!"

# type()으로 동일한 클래스 생성
Dog = type("Dog", (object,), {
    "species": "Canis familiaris",
    "bark": lambda self: "Woof!",
})
```

`type(name, bases, namespace)`:
- `name`: 클래스 이름 (문자열)
- `bases`: 부모 클래스 튜플
- `namespace`: 클래스 속성 딕셔너리

---

## 3. 메타클래스 작성하기

### 기본 구조

```python
class Meta(type):
    def __new__(mcs, name, bases, namespace):
        # 클래스 객체가 생성되기 전에 호출
        print(f"Creating class: {name}")
        cls = super().__new__(mcs, name, bases, namespace)
        return cls

    def __init__(cls, name, bases, namespace):
        # 클래스 객체가 생성된 후 호출
        super().__init__(name, bases, namespace)

class MyClass(metaclass=Meta):
    pass
# 출력: Creating class: MyClass
```

### `__new__` vs `__init__` in 메타클래스

| 메서드 | 호출 시점 | 첫 번째 인자 | 역할 |
|--------|----------|-------------|------|
| `__new__` | 클래스 객체 생성 **전** | `mcs` (메타클래스) | 클래스 객체를 만들어 반환 |
| `__init__` | 클래스 객체 생성 **후** | `cls` (새 클래스) | 생성된 클래스를 초기화 |

일반 클래스의 `__new__`/`__init__`과 동일한 패턴이지만, **대상이 인스턴스가 아니라 클래스**라는 점이 다릅니다.

> **핵심 직관**: 일반 클래스의 `__new__`가 인스턴스를 만들듯, 메타클래스의 `__new__`가 클래스를 만듭니다. 한 단계 위의 추상화입니다.

---

## 4. 실전 패턴: 속성 검증

클래스 정의 시 특정 속성이 반드시 있어야 하는 경우를 강제합니다.

```python
class InterfaceMeta(type):
    def __new__(mcs, name, bases, namespace):
        # 베이스 클래스 자체는 검증하지 않음
        if bases:
            required = {"execute", "validate"}
            methods = {k for k, v in namespace.items() if callable(v)}
            missing = required - methods
            if missing:
                raise TypeError(
                    f"Class '{name}' missing required methods: {missing}"
                )
        return super().__new__(mcs, name, bases, namespace)

class Plugin(metaclass=InterfaceMeta):
    pass

class MyPlugin(Plugin):
    def execute(self):
        pass
    def validate(self):
        pass
# OK

class BadPlugin(Plugin):
    def execute(self):
        pass
# TypeError: Class 'BadPlugin' missing required methods: {'validate'}
```

---

## 5. 실전 패턴: 자동 등록 (Registry)

플러그인 시스템에서 클래스를 정의하면 자동으로 등록되도록 합니다.

```python
class RegistryMeta(type):
    registry = {}

    def __new__(mcs, name, bases, namespace):
        cls = super().__new__(mcs, name, bases, namespace)
        if bases:  # 베이스 클래스 자체는 등록하지 않음
            mcs.registry[name] = cls
        return cls

class Handler(metaclass=RegistryMeta):
    pass

class JSONHandler(Handler):
    def handle(self, data):
        return "json"

class XMLHandler(Handler):
    def handle(self, data):
        return "xml"

print(RegistryMeta.registry)
# {'JSONHandler': <class 'JSONHandler'>, 'XMLHandler': <class 'XMLHandler'>}

# 문자열로 핸들러 조회
handler = RegistryMeta.registry["JSONHandler"]()
print(handler.handle("data"))  # "json"
```

---

## 6. `__init_subclass__`: 메타클래스의 경량 대안

Python 3.6+에서 도입된 `__init_subclass__`는 메타클래스 없이 서브클래스 생성을 후킹할 수 있습니다.

```python
class Plugin:
    _registry = {}

    def __init_subclass__(cls, **kwargs):
        super().__init_subclass__(**kwargs)
        Plugin._registry[cls.__name__] = cls

class JSONPlugin(Plugin):
    pass

class CSVPlugin(Plugin):
    pass

print(Plugin._registry)
# {'JSONPlugin': <class 'JSONPlugin'>, 'CSVPlugin': <class 'CSVPlugin'>}
```

> **핵심 직관**: 대부분의 경우 `__init_subclass__`로 충분합니다. 메타클래스는 네임스페이스 조작, `__new__`에서의 클래스 변형 등 더 깊은 제어가 필요할 때만 사용합니다.

---

## 7. 메타클래스의 `__call__`: 인스턴스 생성 제어

메타클래스의 `__call__`은 클래스를 **호출할 때** (인스턴스를 만들 때) 실행됩니다.

```python
class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Database(metaclass=SingletonMeta):
    def __init__(self):
        print("Connecting to database...")

db1 = Database()  # "Connecting to database..."
db2 = Database()  # (아무 출력 없음 — 같은 인스턴스)
print(db1 is db2)  # True
```

### 호출 체인 정리

`MyClass()`를 실행하면:
1. `Meta.__call__(MyClass)` → 메타클래스의 `__call__`
2. → `MyClass.__new__(MyClass)` → 인스턴스 생성
3. → `MyClass.__init__(instance)` → 인스턴스 초기화

---

## 8. 클래스 생성 전체 과정

```python
class Meta(type):
    def __prepare__(mcs, name, bases):
        print(f"1. __prepare__: 네임스페이스 준비")
        return {}  # 또는 OrderedDict 등

    def __new__(mcs, name, bases, namespace):
        print(f"2. __new__: 클래스 객체 생성")
        return super().__new__(mcs, name, bases, namespace)

    def __init__(cls, name, bases, namespace):
        print(f"3. __init__: 클래스 초기화")
        super().__init__(name, bases, namespace)

    def __call__(cls, *args, **kwargs):
        print(f"4. __call__: 인스턴스 생성")
        return super().__call__(*args, **kwargs)
```

| 단계 | 메서드 | 시점 |
|------|--------|------|
| 1 | `__prepare__` | 클래스 본문 실행 전, 네임스페이스 딕셔너리 결정 |
| 2 | `__new__` | 클래스 본문 실행 후, 클래스 객체 생성 |
| 3 | `__init__` | 클래스 객체 생성 후 초기화 |
| 4 | `__call__` | `MyClass()`로 인스턴스 생성 시 |

---

## 9. ML에서의 의미

### PyTorch nn.Module의 내부

PyTorch의 `nn.Module`은 메타클래스는 아니지만, `__init_subclass__`와 비슷한 패턴으로 파라미터를 자동 추적합니다. `__setattr__`을 오버라이드하여 `nn.Parameter`가 할당되면 자동으로 등록합니다.

### ORM 모델 정의

Django/SQLAlchemy에서 모델 클래스를 정의하면 메타클래스가 필드를 수집하고 테이블 매핑을 자동 생성합니다. 이것이 선언적 API의 핵심 메커니즘입니다.

---

## 핵심 정리

1. Python에서 **클래스는 `type`의 인스턴스**이며, `type(name, bases, namespace)`로 동적 생성할 수 있다.
2. **메타클래스**는 `type`을 상속하여 클래스 생성을 커스터마이징하는 "클래스의 클래스"이다.
3. `__new__`는 클래스 객체를 만들고, `__init__`은 초기화하고, `__call__`은 인스턴스 생성을 제어한다.
4. **실전 패턴**: 속성 검증, 자동 등록(Registry), 싱글톤이 대표적이다.
5. Python 3.6+의 `__init_subclass__`가 대부분의 사용 사례를 대체하며, **메타클래스는 깊은 제어가 필요할 때만** 사용한다.
