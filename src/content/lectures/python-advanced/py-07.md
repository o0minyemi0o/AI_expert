# 고급 타입 힌트

## 왜 타입 힌트를 깊이 배워야 하는가

타입 힌트는 Python 코드의 **문서이자 계약서**입니다. 기본적인 `int`, `str` 어노테이션을 넘어, **Protocol**, **TypeVar**, **ParamSpec**, **overload** 등을 활용하면 정적 분석 도구(mypy, pyright)가 버그를 **코드 실행 전에** 잡아줍니다. 대규모 ML 프로젝트에서 타입 안전한 API를 설계하는 것은 유지보수의 핵심입니다.

---

## 1. 제네릭: TypeVar

`TypeVar`는 함수나 클래스가 **여러 타입에 대해 동작**하면서도 타입 일관성을 보장합니다.

```python
from typing import TypeVar, List

T = TypeVar("T")

def first(items: List[T]) -> T:
    return items[0]

# 타입 체커가 추론:
x: int = first([1, 2, 3])        # T = int → 반환 int
y: str = first(["a", "b", "c"])  # T = str → 반환 str
z: int = first(["a", "b"])       # 타입 에러! T = str인데 int에 할당
```

### 바운드 TypeVar

```python
from typing import TypeVar
import numpy as np

# T는 np.ndarray의 서브클래스만 허용
ArrayT = TypeVar("ArrayT", bound=np.ndarray)

def normalize(arr: ArrayT) -> ArrayT:
    return arr / arr.max()

# np.ndarray 및 서브클래스만 허용
result = normalize(np.array([1, 2, 3]))  # OK
```

### 제약 TypeVar

```python
# T는 int 또는 float만 허용
Number = TypeVar("Number", int, float)

def add(a: Number, b: Number) -> Number:
    return a + b

add(1, 2)      # OK (int + int)
add(1.0, 2.0)  # OK (float + float)
add(1, 2.0)    # 타입 에러! int와 float 혼합 불가
```

---

## 2. Protocol: 구조적 서브타이핑

Python의 덕 타이핑을 타입 시스템으로 표현합니다. "이 메서드가 있으면 이 타입이다."

```python
from typing import Protocol, runtime_checkable

class Drawable(Protocol):
    def draw(self) -> None: ...

class Circle:
    def draw(self) -> None:
        print("Drawing circle")

class Square:
    def draw(self) -> None:
        print("Drawing square")

class NotDrawable:
    pass

def render(shape: Drawable) -> None:
    shape.draw()

render(Circle())       # OK — draw() 메서드가 있음
render(Square())       # OK
render(NotDrawable())  # 타입 에러! draw() 없음
```

### Protocol vs ABC

| 특성 | ABC (명목적) | Protocol (구조적) |
|------|------------|-----------------|
| 상속 필요 | 예 (`class C(ABC)`) | **아니오** |
| 기존 클래스 호환 | 불가 (수정 필요) | **가능** |
| isinstance 체크 | 기본 지원 | `@runtime_checkable` 필요 |
| 서드파티 코드 | 수정해야 함 | **수정 없이 사용** |

```python
@runtime_checkable
class Sized(Protocol):
    def __len__(self) -> int: ...

print(isinstance([1, 2], Sized))   # True
print(isinstance("abc", Sized))    # True
print(isinstance(42, Sized))       # False
```

> **핵심 직관**: Protocol은 "이 객체가 무엇을 할 수 있는가"를 정의합니다. 상속 관계 없이, 필요한 메서드만 있으면 됩니다. Go 언어의 인터페이스와 같은 철학입니다.

---

## 3. ParamSpec: 함수 시그니처 보존

데코레이터가 원래 함수의 **파라미터 타입을 보존**하도록 합니다.

```python
from typing import ParamSpec, TypeVar, Callable
from functools import wraps

P = ParamSpec("P")
R = TypeVar("R")

def logged(func: Callable[P, R]) -> Callable[P, R]:
    @wraps(func)
    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:
        print(f"Calling {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@logged
def greet(name: str, excited: bool = False) -> str:
    return f"Hello, {name}{'!' if excited else '.'}"

# 타입 체커가 원래 시그니처를 인식:
greet("Alice", excited=True)   # OK
greet(42)                       # 타입 에러! name은 str
```

`ParamSpec` 없이는 데코레이터가 `(*args, **kwargs) -> Any`로 타입이 소실됩니다. `ParamSpec`은 **파라미터의 이름, 타입, 기본값**을 모두 보존합니다.

---

## 4. overload: 입력에 따른 반환 타입

같은 함수가 입력 타입에 따라 다른 타입을 반환할 때 사용합니다.

```python
from typing import overload, Union, List

@overload
def process(data: str) -> List[str]: ...

@overload
def process(data: int) -> List[int]: ...

@overload
def process(data: list) -> list: ...

def process(data: Union[str, int, list]):
    if isinstance(data, str):
        return data.split()
    elif isinstance(data, int):
        return list(range(data))
    else:
        return data.copy()

# 타입 체커가 각 경우를 정확히 추론:
words: List[str] = process("hello world")  # OK
nums: List[int] = process(5)               # OK
wrong: List[str] = process(5)              # 타입 에러!
```

`@overload`는 **런타임에 아무 효과가 없습니다**. 순수하게 타입 체커를 위한 힌트입니다.

---

## 5. Literal과 Final

### Literal: 특정 값만 허용

```python
from typing import Literal

def set_mode(mode: Literal["train", "eval", "predict"]) -> None:
    print(f"Mode: {mode}")

set_mode("train")    # OK
set_mode("test")     # 타입 에러! "test"는 허용되지 않음
```

### Final: 재할당 불가

```python
from typing import Final

MAX_EPOCHS: Final = 100
LEARNING_RATE: Final[float] = 0.001

MAX_EPOCHS = 200  # 타입 에러! Final 변수 재할당
```

---

## 6. TypeGuard: 사용자 정의 타입 좁히기

```python
from typing import TypeGuard, Union, List

def is_string_list(val: List[Union[str, int]]) -> TypeGuard[List[str]]:
    return all(isinstance(x, str) for x in val)

def process(data: List[Union[str, int]]) -> None:
    if is_string_list(data):
        # 이 블록에서 data는 List[str]로 좁혀짐
        for s in data:
            print(s.upper())  # OK — str 메서드 사용 가능
    else:
        # 여기서는 여전히 List[Union[str, int]]
        pass
```

---

## 7. 제네릭 클래스

```python
from typing import TypeVar, Generic, Optional

T = TypeVar("T")

class Stack(Generic[T]):
    def __init__(self) -> None:
        self._items: List[T] = []

    def push(self, item: T) -> None:
        self._items.append(item)

    def pop(self) -> T:
        return self._items.pop()

    def peek(self) -> Optional[T]:
        return self._items[-1] if self._items else None

# 사용
int_stack: Stack[int] = Stack()
int_stack.push(1)       # OK
int_stack.push("hello") # 타입 에러! int만 가능

str_stack: Stack[str] = Stack()
str_stack.push("world") # OK
```

### Python 3.12+ 새 문법

```python
# 3.12 이전
T = TypeVar("T")
def first(items: List[T]) -> T: ...

# 3.12+: 타입 파라미터 문법
def first[T](items: List[T]) -> T: ...

class Stack[T]:
    def push(self, item: T) -> None: ...
```

---

## 8. Callable 타입의 정밀한 표현

```python
from typing import Callable, Awaitable

# 기본: 인자 타입 → 반환 타입
Transform = Callable[[int, int], float]

# 비동기 함수
AsyncTransform = Callable[[int], Awaitable[float]]

# 콜백 패턴
def apply(func: Callable[[str], str], data: str) -> str:
    return func(data)

apply(str.upper, "hello")  # OK
apply(len, "hello")        # 타입 에러! len은 str → int
```

### Concatenate: ParamSpec과 함께 파라미터 추가

```python
from typing import Concatenate, ParamSpec, TypeVar, Callable

P = ParamSpec("P")
R = TypeVar("R")

def with_logging(
    func: Callable[Concatenate[str, P], R]
) -> Callable[P, R]:
    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:
        return func("log_prefix", *args, **kwargs)
    return wrapper
```

---

## 9. 실전 팁

### mypy 설정

```ini
# mypy.ini 또는 pyproject.toml
[mypy]
strict = true
warn_return_any = true
warn_unused_ignores = true
disallow_untyped_defs = true
```

### 점진적 타이핑

```python
# 1단계: 공개 API부터 타입 추가
def train(model: nn.Module, epochs: int) -> float: ...

# 2단계: 내부 함수로 확장
# 3단계: strict 모드 활성화
```

### 타입 무시 (escape hatch)

```python
result = some_dynamic_call()  # type: ignore[no-any-return]
```

---

## 10. ML에서의 의미

### 텐서 타입

PyTorch/JAX에서 텐서의 dtype과 shape을 타입으로 표현하는 연구가 진행 중입니다.

```python
# 미래의 비전 (jaxtyping 등)
from jaxtyping import Float, Array

def attention(
    q: Float[Array, "batch seq d_k"],
    k: Float[Array, "batch seq d_k"],
    v: Float[Array, "batch seq d_v"],
) -> Float[Array, "batch seq d_v"]:
    ...
```

### 설정 타입 안전성

ML 실험의 하이퍼파라미터 설정을 `TypedDict`나 `dataclass`로 정의하면 오타를 방지합니다.

```python
from typing import TypedDict

class TrainConfig(TypedDict):
    learning_rate: float
    batch_size: int
    epochs: int
    optimizer: Literal["adam", "sgd", "adamw"]
```

---

## 핵심 정리

1. **TypeVar**는 제네릭 타입을 정의하며, `bound`와 제약으로 허용 타입을 제한할 수 있다.
2. **Protocol**은 구조적 서브타이핑으로, 상속 없이 "이 메서드가 있으면 이 타입"을 표현한다.
3. **ParamSpec**은 데코레이터에서 원래 함수의 파라미터 시그니처를 보존한다.
4. **overload**는 입력 타입에 따른 반환 타입을 정밀하게 표현하며, 런타임 효과는 없다.
5. 타입 힌트는 **점진적으로** 도입하며, 공개 API → 내부 함수 → strict 모드 순서로 확장하는 것이 현실적이다.
