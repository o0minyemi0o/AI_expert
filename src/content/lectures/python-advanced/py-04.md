# Async/Await 내부 동작

## 왜 비동기 프로그래밍의 내부를 이해해야 하는가

`async`/`await`는 단순한 문법이 아닙니다. 그 아래에는 **이벤트 루프**, **코루틴 스케줄링**, **비동기 이터레이터** 등 정교한 메커니즘이 있습니다. ML 모델 서빙, 데이터 수집 파이프라인, API 호출 병렬화 등 실전에서 비동기를 쓰려면 "왜 이렇게 동작하는가"를 알아야 디버깅할 수 있습니다.

---

## 1. 동기 vs 비동기: 핵심 차이

### 동기 (Synchronous)

```python
import time

def fetch(url):
    time.sleep(1)  # I/O 대기 시뮬레이션
    return f"Data from {url}"

# 3개를 순차 실행: 3초 소요
for url in ["a.com", "b.com", "c.com"]:
    print(fetch(url))
```

### 비동기 (Asynchronous)

```python
import asyncio

async def fetch(url):
    await asyncio.sleep(1)  # I/O 대기 중 다른 작업 가능
    return f"Data from {url}"

async def main():
    # 3개를 동시 실행: ~1초 소요
    results = await asyncio.gather(
        fetch("a.com"),
        fetch("b.com"),
        fetch("c.com"),
    )
    print(results)

asyncio.run(main())
```

| 모델 | I/O 대기 중 | 3개 요청 시간 | 스레드 수 |
|------|------------|-------------|----------|
| 동기 | CPU 유휴 | ~3초 | 1 |
| 비동기 | 다른 작업 실행 | ~1초 | 1 |

> **핵심 직관**: 비동기는 **멀티스레드가 아닙니다**. 단일 스레드에서 I/O 대기 시간을 활용하여 여러 작업을 인터리빙(interleaving)하는 것입니다. 식당에서 한 명의 웨이터가 여러 테이블을 돌아가며 서빙하는 것과 같습니다.

---

## 2. 이벤트 루프의 구조

이벤트 루프는 비동기 프로그래밍의 **심장**입니다.

```
while True:
    1. 준비된(ready) 코루틴을 실행
    2. 코루틴이 await에서 일시 정지
    3. OS에 I/O 완료 여부 확인 (select/epoll/kqueue)
    4. 완료된 I/O의 콜백을 ready 큐에 추가
    5. 반복
```

### 간소화된 이벤트 루프 구현

```python
import heapq
import time

class SimpleEventLoop:
    def __init__(self):
        self.ready = []       # 즉시 실행 가능한 코루틴
        self.sleeping = []    # 대기 중인 코루틴 (힙: 시간순)
        self.current = None

    def call_soon(self, coro):
        self.ready.append(coro)

    def call_later(self, delay, coro):
        deadline = time.time() + delay
        heapq.heappush(self.sleeping, (deadline, coro))

    def run(self):
        while self.ready or self.sleeping:
            # 슬리핑에서 깨울 것이 있으면 ready로 이동
            while self.sleeping and self.sleeping[0][0] <= time.time():
                _, coro = heapq.heappop(self.sleeping)
                self.ready.append(coro)

            if self.ready:
                self.current = self.ready.pop(0)
                try:
                    # 코루틴을 다음 yield까지 실행
                    self.current.send(None)
                except StopIteration:
                    pass  # 코루틴 완료
```

실제 `asyncio` 이벤트 루프는 이보다 훨씬 복잡하지만(OS 레벨 I/O 멀티플렉싱, 콜백 체인, 에러 처리 등), 핵심 구조는 동일합니다.

---

## 3. 코루틴의 상태 머신

`async def` 함수를 호출하면 **코루틴 객체**가 반환됩니다. 이 객체는 상태 머신입니다.

```python
async def example():
    print("Step 1")
    await asyncio.sleep(0.1)  # 정지점 1
    print("Step 2")
    await asyncio.sleep(0.1)  # 정지점 2
    print("Step 3")
    return "done"

coro = example()
print(type(coro))  # <class 'coroutine'>
```

### 상태 전이

```
CREATED → RUNNING → SUSPENDED → RUNNING → SUSPENDED → RUNNING → CLOSED
            ↑           |         ↑           |         ↑
            |     await에서 정지    |     await에서 정지    |
            +---  이벤트 루프 재개  +---  이벤트 루프 재개  +--- return/raise
```

코루틴은 `await`를 만날 때마다 정지하고, 이벤트 루프에 제어를 반환합니다. py-03에서 배운 제너레이터의 `yield`와 정확히 같은 메커니즘입니다.

---

## 4. await의 정체

`await`는 **awaitable 객체**에 대해서만 사용할 수 있습니다.

```python
class Awaitable:
    def __await__(self):
        yield  # 이벤트 루프에 제어 반환
        return "result"

async def use_awaitable():
    result = await Awaitable()
    print(result)  # "result"
```

Awaitable 프로토콜:
- **코루틴**: `async def`로 정의된 함수의 반환값
- **Task/Future**: `asyncio.Task`, `asyncio.Future`
- **`__await__` 구현 객체**: `__await__` 메서드가 제너레이터를 반환하는 객체

```python
# asyncio.sleep의 간소화된 내부 구조
class Sleep:
    def __init__(self, delay):
        self.delay = delay

    def __await__(self):
        # 이벤트 루프에 "delay 후에 깨워달라"고 요청
        yield ("sleep", self.delay)
        return None
```

> **핵심 직관**: `await`는 결국 `yield`입니다. 코루틴이 이벤트 루프에 "나는 이것을 기다리고 있으니 나중에 깨워달라"고 말하는 것입니다.

---

## 5. Task와 Future

### Future: 아직 없는 결과의 플레이스홀더

```python
import asyncio

async def set_future_result(future):
    await asyncio.sleep(1)
    future.set_result("Hello from the future!")

async def main():
    loop = asyncio.get_event_loop()
    future = loop.create_future()

    # 백그라운드에서 결과 설정
    asyncio.create_task(set_future_result(future))

    # 결과가 설정될 때까지 대기
    result = await future
    print(result)

asyncio.run(main())
```

### Task: 코루틴을 이벤트 루프에 등록

`Task`는 `Future`의 서브클래스로, 코루틴을 감싸서 이벤트 루프가 스케줄링하도록 합니다.

```python
async def worker(name, delay):
    print(f"{name} started")
    await asyncio.sleep(delay)
    print(f"{name} done")
    return f"{name} result"

async def main():
    # Task 생성 → 즉시 스케줄링됨
    task1 = asyncio.create_task(worker("A", 2))
    task2 = asyncio.create_task(worker("B", 1))

    # 두 Task가 동시에 실행됨
    result1 = await task1
    result2 = await task2
    print(result1, result2)

asyncio.run(main())
# B started, A started
# (1초 후) B done
# (2초 후) A done
```

---

## 6. 비동기 이터레이터

`async for`로 비동기적으로 값을 하나씩 받을 수 있습니다.

```python
class AsyncCounter:
    def __init__(self, stop):
        self.stop = stop
        self.current = 0

    def __aiter__(self):
        return self

    async def __anext__(self):
        if self.current >= self.stop:
            raise StopAsyncIteration
        await asyncio.sleep(0.1)  # 비동기 I/O 시뮬레이션
        self.current += 1
        return self.current

async def main():
    async for num in AsyncCounter(5):
        print(num)  # 0.1초 간격으로 1, 2, 3, 4, 5
```

### 비동기 제너레이터 (더 간단한 방법)

```python
async def async_range(stop):
    for i in range(stop):
        await asyncio.sleep(0.1)
        yield i

async def main():
    async for num in async_range(5):
        print(num)
```

| 프로토콜 | 동기 | 비동기 |
|---------|------|--------|
| 이터레이터 | `__iter__`, `__next__` | `__aiter__`, `__anext__` |
| 종료 신호 | `StopIteration` | `StopAsyncIteration` |
| 사용 | `for x in ...` | `async for x in ...` |

---

## 7. 비동기 컨텍스트 매니저

리소스의 비동기 획득/해제를 위한 패턴입니다.

```python
class AsyncDB:
    async def __aenter__(self):
        print("Connecting...")
        await asyncio.sleep(0.5)  # 연결 수립
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        print("Disconnecting...")
        await asyncio.sleep(0.1)  # 연결 해제
        return False

    async def query(self, sql):
        await asyncio.sleep(0.1)
        return f"Result of: {sql}"

async def main():
    async with AsyncDB() as db:
        result = await db.query("SELECT * FROM users")
        print(result)
```

---

## 8. 동시성 패턴

### gather: 여러 코루틴을 동시 실행

```python
async def main():
    results = await asyncio.gather(
        fetch("url1"),
        fetch("url2"),
        fetch("url3"),
        return_exceptions=True,  # 예외도 결과로 반환
    )
```

### as_completed: 완료 순서대로 처리

```python
async def main():
    tasks = [fetch(url) for url in urls]
    for coro in asyncio.as_completed(tasks):
        result = await coro
        print(f"Got: {result}")  # 빨리 끝나는 것부터
```

### Semaphore: 동시 실행 수 제한

```python
sem = asyncio.Semaphore(10)  # 최대 10개 동시 실행

async def limited_fetch(url):
    async with sem:
        return await fetch(url)

async def main():
    # 100개 요청이지만 동시에 10개씩만
    tasks = [limited_fetch(url) for url in urls_100]
    results = await asyncio.gather(*tasks)
```

---

## 9. 흔한 실수들

### 1. 코루틴을 await하지 않기

```python
async def main():
    fetch("url")           # 경고! 코루틴이 실행되지 않음
    await fetch("url")     # 올바른 사용
```

### 2. 동기 블로킹 호출

```python
async def bad():
    time.sleep(5)          # 이벤트 루프 전체를 블로킹!
    await asyncio.sleep(5) # 올바른 비동기 대기

# 동기 함수를 비동기로 래핑해야 하는 경우
async def good():
    loop = asyncio.get_event_loop()
    await loop.run_in_executor(None, time.sleep, 5)  # 스레드 풀에 위임
```

### 3. 이벤트 루프 중첩

```python
# 이미 이벤트 루프가 돌고 있는데 asyncio.run() 호출 → 에러
# Jupyter에서는 nest_asyncio 또는 await 직접 사용
```

---

## 10. ML에서의 의미

### 모델 서빙

FastAPI는 `async def` 엔드포인트를 사용하여 여러 추론 요청을 동시에 처리합니다.

```python
from fastapi import FastAPI
app = FastAPI()

@app.post("/predict")
async def predict(data: dict):
    result = await model.predict_async(data)
    return {"prediction": result}
```

### 비동기 데이터 수집

웹 크롤링, API 호출 등 대량의 I/O 작업을 비동기로 병렬화합니다.

### LLM API 호출

OpenAI, Anthropic 등의 API를 `asyncio.gather`로 병렬 호출하면 처리량이 크게 향상됩니다.

---

## 핵심 정리

1. **이벤트 루프**는 단일 스레드에서 코루틴을 번갈아 실행하며, I/O 대기 시간을 활용하는 스케줄러이다.
2. **`await`는 `yield`의 비동기 특화 버전**이며, 코루틴을 일시 정지하고 이벤트 루프에 제어를 반환한다.
3. **Task**는 코루틴을 이벤트 루프에 등록하여 동시 실행을 가능하게 하고, **Future**는 아직 없는 결과의 플레이스홀더이다.
4. **`async for`**, **`async with`**는 비동기 이터레이터와 컨텍스트 매니저 프로토콜로, I/O를 수반하는 반복/리소스 관리에 사용한다.
5. 비동기의 핵심 규칙: **동기 블로킹 호출을 절대 사용하지 않는다.** 불가피하면 `run_in_executor`로 스레드 풀에 위임한다.
