# 컨텍스트 매니저 심화

## 왜 컨텍스트 매니저를 깊이 이해해야 하는가

`with` 문은 리소스 관리의 핵심입니다. 파일, 네트워크 연결, 데이터베이스 트랜잭션, GPU 메모리, 임시 디렉터리 등 "사용 후 반드시 정리해야 하는 것"에 컨텍스트 매니저를 씁니다. `contextlib`의 고급 도구와 비동기 컨텍스트 매니저까지 익히면, 리소스 누수 없는 코드를 작성할 수 있습니다.

---

## 1. 컨텍스트 매니저의 본질

`with` 문이 실행하는 프로토콜은 두 가지 메서드입니다.

```python
class ManagedResource:
    def __enter__(self):
        print("Acquiring resource")
        return self  # as 절에 바인딩되는 값

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Releasing resource")
        return False  # True면 예외를 억제

with ManagedResource() as resource:
    print("Using resource")
    # 예외가 발생해도 __exit__은 반드시 호출됨
```

### 실행 흐름

```
1. ManagedResource()              → 컨텍스트 매니저 객체 생성
2. __enter__()                    → 리소스 획득, 반환값을 resource에 바인딩
3. with 블록 본문 실행            → "Using resource"
4. __exit__(None, None, None)     → 리소스 해제 (정상 종료)
```

예외 발생 시:

```
3. with 블록에서 예외 발생
4. __exit__(exc_type, exc_val, exc_tb) → 리소스 해제
   → False 반환: 예외를 다시 발생시킴
   → True 반환: 예외를 억제함
```

> **핵심 직관**: `with`는 `try`/`finally`의 구조화된 형태입니다. "무엇이 일어나든 정리는 반드시 한다"를 보장합니다.

---

## 2. contextlib.contextmanager

클래스를 만들지 않고 제너레이터로 컨텍스트 매니저를 정의합니다.

```python
from contextlib import contextmanager

@contextmanager
def timer(label):
    import time
    start = time.time()
    try:
        yield start  # as 절에 바인딩되는 값
    finally:
        elapsed = time.time() - start
        print(f"{label}: {elapsed:.4f}s")

with timer("Training") as t:
    # 시간이 걸리는 작업
    sum(range(10_000_000))
# 출력: Training: 0.2134s
```

### yield 기준으로 분할

```
@contextmanager
def managed():
    # ─── __enter__ 부분 ───
    resource = acquire()
    try:
        yield resource
    # ─── __exit__ 부분 ───
    finally:
        release(resource)
```

`yield` 앞이 `__enter__`, `yield` 뒤가 `__exit__`입니다. `try`/`finally`는 예외 시에도 정리를 보장합니다.

---

## 3. 예외 처리 패턴

### 예외 억제

```python
@contextmanager
def suppress(*exceptions):
    try:
        yield
    except exceptions:
        pass  # 예외를 무시

with suppress(FileNotFoundError):
    open("nonexistent.txt")
# FileNotFoundError가 발생하지만 억제됨

# 표준 라이브러리에 이미 존재:
from contextlib import suppress
```

### 예외 변환

```python
@contextmanager
def convert_exception(from_exc, to_exc):
    try:
        yield
    except from_exc as e:
        raise to_exc(str(e)) from e

with convert_exception(KeyError, ValueError):
    d = {}
    d["missing"]  # KeyError → ValueError로 변환
```

---

## 4. ExitStack: 동적 컨텍스트 매니저

열어야 할 파일의 수가 런타임에 결정될 때 사용합니다.

```python
from contextlib import ExitStack

filenames = ["a.txt", "b.txt", "c.txt"]

with ExitStack() as stack:
    files = [
        stack.enter_context(open(fname))
        for fname in filenames
    ]
    # 모든 파일이 with 블록 종료 시 자동으로 닫힘
    for f in files:
        print(f.read())
```

### ExitStack의 정리 순서

```python
from contextlib import ExitStack

with ExitStack() as stack:
    stack.callback(print, "First registered, last executed")
    stack.callback(print, "Second registered, second executed")
    stack.callback(print, "Third registered, first executed")
# Third registered, first executed
# Second registered, second executed
# First registered, last executed
```

정리 순서는 **LIFO (Last In, First Out)**입니다. 스택과 같습니다.

### 콜백 등록

```python
with ExitStack() as stack:
    # 컨텍스트 매니저 등록
    db = stack.enter_context(DatabaseConnection())

    # 일반 정리 함수 등록
    stack.callback(cleanup_temp_files)

    # 예외 시에만 실행되는 콜백
    stack.callback(rollback_transaction)

    # 성공 시 롤백 취소
    stack.pop_all()  # 모든 정리 작업을 새 스택으로 이동
```

---

## 5. 중첩 컨텍스트

### 여러 컨텍스트를 하나의 with로

```python
# Python 3.10+ 괄호 with
with (
    open("input.txt") as fin,
    open("output.txt", "w") as fout,
):
    fout.write(fin.read())

# 이전 버전
with open("input.txt") as fin, open("output.txt", "w") as fout:
    fout.write(fin.read())
```

### 컨텍스트 매니저 조합

```python
@contextmanager
def combined(*managers):
    """여러 컨텍스트 매니저를 하나로 조합"""
    with ExitStack() as stack:
        results = [stack.enter_context(m) for m in managers]
        yield results
```

---

## 6. 재진입 가능 vs 재사용 가능

| 특성 | 재사용 가능 | 재진입 가능 |
|------|-----------|-----------|
| 의미 | 여러 번 `with`에 사용 | 중첩 `with`에 사용 |
| 예시 | `threading.Lock` | `threading.RLock` |

```python
import threading

# Lock: 재사용 가능하지만 재진입 불가
lock = threading.Lock()
with lock:          # OK
    pass
with lock:          # OK (재사용)
    pass
with lock:
    with lock:      # 데드락! (재진입 불가)
        pass

# RLock: 재사용 + 재진입 가능
rlock = threading.RLock()
with rlock:
    with rlock:     # OK (재진입 가능)
        pass
```

---

## 7. 비동기 컨텍스트 매니저

`async with`를 위한 `__aenter__`/`__aexit__` 프로토콜입니다.

```python
import asyncio
from contextlib import asynccontextmanager

@asynccontextmanager
async def async_timer(label):
    import time
    start = time.time()
    try:
        yield
    finally:
        elapsed = time.time() - start
        print(f"{label}: {elapsed:.4f}s")

async def main():
    async with async_timer("Async operation"):
        await asyncio.sleep(1)
# Async operation: 1.00xxs
```

### AsyncExitStack

```python
from contextlib import AsyncExitStack

async def process_urls(urls):
    async with AsyncExitStack() as stack:
        sessions = [
            await stack.enter_async_context(aiohttp.ClientSession())
            for _ in range(3)
        ]
        # 모든 세션이 자동으로 닫힘
```

---

## 8. 실전 패턴 모음

### 임시 디렉터리

```python
import tempfile
import os

with tempfile.TemporaryDirectory() as tmpdir:
    filepath = os.path.join(tmpdir, "data.txt")
    with open(filepath, "w") as f:
        f.write("temporary data")
    # tmpdir 내의 모든 파일이 자동 삭제
```

### 디렉터리 변경 후 복원

```python
@contextmanager
def working_directory(path):
    old = os.getcwd()
    os.chdir(path)
    try:
        yield
    finally:
        os.chdir(old)

with working_directory("/tmp"):
    print(os.getcwd())  # /tmp
print(os.getcwd())      # 원래 디렉터리
```

### 환경 변수 임시 설정

```python
@contextmanager
def env_var(key, value):
    old = os.environ.get(key)
    os.environ[key] = value
    try:
        yield
    finally:
        if old is None:
            del os.environ[key]
        else:
            os.environ[key] = old

with env_var("CUDA_VISIBLE_DEVICES", "0"):
    # GPU 0만 사용
    pass
```

---

## 9. ML에서의 의미

### torch.no_grad()

PyTorch의 `torch.no_grad()`는 컨텍스트 매니저이자 데코레이터입니다. 추론 시 그래디언트 계산을 비활성화합니다.

```python
import torch

# 컨텍스트 매니저로
with torch.no_grad():
    output = model(input_data)

# 데코레이터로
@torch.no_grad()
def predict(model, data):
    return model(data)
```

### 모델 학습 컨텍스트

```python
@contextmanager
def train_context(model, optimizer):
    model.train()
    try:
        yield
    finally:
        optimizer.zero_grad()
```

### 데이터베이스 트랜잭션

ML 파이프라인에서 실험 결과를 DB에 저장할 때 트랜잭션 관리에 사용합니다.

---

## 핵심 정리

1. 컨텍스트 매니저는 `__enter__`/`__exit__` 프로토콜로, **예외 여부와 무관하게 리소스 정리를 보장**한다.
2. **`@contextmanager`**는 제너레이터로 간편하게 컨텍스트 매니저를 만들며, `yield` 앞이 진입, 뒤가 정리이다.
3. **`ExitStack`**은 런타임에 동적으로 결정되는 수의 컨텍스트 매니저를 관리하며, **LIFO** 순서로 정리한다.
4. `__exit__`에서 **`True`를 반환하면 예외를 억제**하고, `False`를 반환하면 예외를 다시 발생시킨다.
5. **`async with`**와 **`@asynccontextmanager`**는 비동기 리소스 관리를 위한 동일한 패턴의 비동기 버전이다.
