# 시계열의 실전 응용: 수요 예측, 금융, 센서, 예측 불확실성

## 왜 실전 응용을 별도로 다루는가

ts-01~ts-11까지 배운 이론과 모델은 그 자체로는 불완전합니다. 실전에서는 결측값 처리, 특징 공학, 계층적 예측, 불확실성 정량화 등 강의에서 다루지 못한 수많은 실무 과제가 존재합니다. 이 마지막 강의에서는 수요 예측, 금융 시계열, 센서 데이터, 그리고 예측 불확실성이라는 네 가지 핵심 응용 영역을 통해, 배운 모델을 **어떻게 실전에 적용하는지**를 다룹니다.

---

## 1. 수요 예측 (Demand Forecasting)

### 1.1 문제 특성

수요 예측은 소매·물류·제조에서 가장 흔한 시계열 문제입니다.

| 특성 | 설명 | 대응 전략 |
|------|------|---------|
| 간헐적 수요 | 0이 많은 시계열 | Croston 방법 |
| 프로모션 효과 | 외생 이벤트 | 회귀 변수 추가 (ts-09 참조) |
| 신제품 | 과거 데이터 없음 | 유사 제품 교차 학습 |
| 계층 구조 | 매장-지역-전국 | 계층적 예측 |
| 다수 시계열 | 수만 ~ 수백만 | 자동화, 교차 학습 (ts-10 참조) |

### 1.2 간헐적 수요 모델

일반적인 ARIMA나 ETS는 0이 많은 시계열에 적합하지 않습니다.

**Croston 방법**:

수요 크기 $z_t$와 수요 간 간격 $p_t$를 각각 지수 평활합니다(ts-04 참조).

$$\hat{z}_t = \alpha z_t + (1-\alpha) \hat{z}_{t-1}$$

$$\hat{p}_t = \alpha p_t + (1-\alpha) \hat{p}_{t-1}$$

$$\hat{y} = \frac{\hat{z}_t}{\hat{p}_t}$$

```python
# 간헐적 수요 예측
from statsforecast import StatsForecast
from statsforecast.models import CrostonOptimized

sf = StatsForecast(
    models=[CrostonOptimized()],
    freq='W'
)
forecast = sf.forecast(df=demand_data, h=12)
```

> **핵심 직관**: 수요 예측은 "언제 팔릴 것인가"와 "얼마나 팔릴 것인가"를 분리하여 다루는 것이 효과적입니다.

---

## 2. 계층적 예측 (Hierarchical Forecasting)

### 2.1 계층 구조

$$\text{전국} = \sum_{\text{지역}} = \sum_{\text{매장}} = \sum_{\text{제품}}$$

### 2.2 조정 방법

| 방법 | 설명 | 장점 |
|------|------|------|
| Bottom-Up | 최하위에서 합산 | 세밀한 정보 보존 |
| Top-Down | 최상위에서 분배 | 안정적 |
| Middle-Out | 중간 레벨 기준 | 타협 |
| 최적 조정 (MinT) | 회귀 기반 최적 조합 | 이론적 최적 |

**MinT (Minimum Trace) 조정**:

$$\tilde{\mathbf{y}} = \mathbf{S} (\mathbf{S}^\top \mathbf{W}^{-1} \mathbf{S})^{-1} \mathbf{S}^\top \mathbf{W}^{-1} \hat{\mathbf{y}}$$

여기서 $\mathbf{S}$는 합산 행렬, $\mathbf{W}$는 예측 오차 공분산입니다. la-04에서 다룬 사영 행렬의 원리가 적용됩니다.

```python
from hierarchicalforecast.core import HierarchicalReconciliation
from hierarchicalforecast.methods import MinTrace

reconciler = HierarchicalReconciliation(reconcilers=[MinTrace(method='ols')])
reconciled = reconciler.reconcile(forecasts, S_matrix, tags)
```

> **핵심 직관**: 계층적 예측에서 각 수준의 예측이 합산 관계를 만족하도록 **조정(reconciliation)**하면, 개별 예측보다 전체적으로 더 정확해집니다.

---

## 3. 금융 시계열

### 3.1 금융 시계열의 특성

| 특성 | 설명 | 관련 모델 |
|------|------|---------|
| 수익률 비정규성 | 두꺼운 꼬리 (fat tails) | t-분포 |
| 변동성 군집 | 큰 변동 후 큰 변동 | GARCH |
| 레버리지 효과 | 하락 시 변동성 증가 | EGARCH, GJR-GARCH |
| 장기 기억 | 느린 ACF 감소 | FIGARCH |
| 비선형성 | 상승·하락 비대칭 | Threshold 모델 |

### 3.2 GARCH 모델

ts-02의 ARMA가 조건부 평균을 모델링한다면, GARCH는 **조건부 분산**을 모델링합니다.

$$Y_t = \mu + \epsilon_t, \quad \epsilon_t = \sigma_t z_t, \quad z_t \sim N(0, 1)$$

$$\sigma_t^2 = \omega + \alpha \epsilon_{t-1}^2 + \beta \sigma_{t-1}^2$$

| 파라미터 | 의미 | 조건 |
|---------|------|------|
| $\omega$ | 기저 분산 | $\omega > 0$ |
| $\alpha$ | ARCH 효과 (충격 반응) | $\alpha \geq 0$ |
| $\beta$ | GARCH 효과 (분산 지속) | $\beta \geq 0$ |
| $\alpha + \beta$ | 분산 지속성 | $< 1$ (정상성) |

```python
from arch import arch_model

# GARCH(1,1) 모델
model = arch_model(returns, vol='Garch', p=1, q=1, dist='t')
result = model.fit(disp='off')
print(result.summary())

# 조건부 변동성 추출
conditional_vol = result.conditional_volatility
```

> **핵심 직관**: 금융에서는 수익률 자체보다 **변동성(위험)**이 더 예측 가능합니다. GARCH는 "오늘 크게 움직였으면 내일도 크게 움직일 가능성이 높다"를 모델링합니다.

---

## 4. 센서 데이터와 IoT 시계열

### 4.1 센서 데이터의 특성

| 특성 | 설명 | 처리 방법 |
|------|------|---------|
| 고빈도 | 밀리초~초 단위 | 다운샘플링 |
| 결측값 | 센서 오작동, 통신 장애 | 보간 |
| 다중 센서 | 수백~수천 변수 | 차원 축소 |
| 드리프트 | 센서 노화에 의한 점진적 변화 | 캘리브레이션 |
| 비정상 | 작동 모드 전환 | ts-11의 변화점 탐지 |

### 4.2 결측값 처리

| 방법 | 적합 상황 | 코드 |
|------|---------|------|
| 선형 보간 | 짧은 결측 | `ts.interpolate('linear')` |
| 시간 가중 보간 | 불규칙 간격 | `ts.interpolate('time')` |
| 전방 채움 | 계단 함수 | `ts.ffill()` |
| 칼만 스무더 | 상태 공간 기반 | ts-05 참조 |
| 다중 대체 | 불확실성 반영 | MICE |

```python
import pandas as pd

# 센서 데이터 전처리 파이프라인
def preprocess_sensor(df, freq='1min'):
    # 1. 시간 인덱스 정규화
    df = df.resample(freq).mean()
    # 2. 결측값 보간
    df = df.interpolate(method='time', limit=10)
    # 3. 이상치 클리핑
    for col in df.columns:
        q1, q3 = df[col].quantile([0.01, 0.99])
        df[col] = df[col].clip(q1, q3)
    return df
```

> **핵심 직관**: 센서 데이터의 80%는 전처리에 소요됩니다. 결측·이상치·드리프트를 적절히 처리하지 않으면, 아무리 좋은 모델도 무용지물입니다.

---

## 5. 예측 불확실성 (Prediction Uncertainty)

### 5.1 불확실성의 원천

| 원천 | 설명 | 감소 가능 여부 |
|------|------|-------------|
| 모델 불확실성 | 잘못된 모델 선택 | 앙상블로 감소 |
| 파라미터 불확실성 | 유한 샘플 추정 오차 | 데이터 증가로 감소 |
| 내재적 불확실성 | 본질적 무작위성 | 감소 불가 |
| 데이터 불확실성 | 측정 오차, 결측 | 센서 개선 |

### 5.2 예측 구간 생성 방법

| 방법 | 원리 | 장점 |
|------|------|------|
| 해석적 | 모델 수식에서 유도 | 정확 (가정 성립 시) |
| 부트스트랩 | 잔차 재표본 | 분포 가정 불필요 |
| 분위수 회귀 | 분위수별 모델 | 비대칭 구간 |
| 컨포멀 예측 | 교정된 구간 | 유한 표본 보장 |

### 5.3 컨포멀 예측 (Conformal Prediction)

분포 가정 없이 **유한 표본에서 유효한** 예측 구간을 제공합니다.

$$C_\alpha(X_{n+1}) = \{\hat{y} \pm q_{1-\alpha}(\{|r_i|\}_{i=1}^{n})\}$$

여기서 $r_i$는 캘리브레이션 셋의 잔차입니다.

```python
import numpy as np

def conformal_interval(cal_residuals, point_forecast, alpha=0.05):
    """컨포멀 예측 구간"""
    abs_residuals = np.abs(cal_residuals)
    q = np.quantile(abs_residuals, 1 - alpha)
    lower = point_forecast - q
    upper = point_forecast + q
    return lower, upper

# 캘리브레이션 잔차
cal_residuals = y_cal - y_cal_pred
lower, upper = conformal_interval(cal_residuals, forecast_point, alpha=0.05)
```

> **핵심 직관**: ts-03에서 배운 ARIMA 예측 구간은 정규성 가정에 의존하지만, 컨포멀 예측은 **분포 가정 없이** 유효한 구간을 보장합니다.

---

## 6. 특징 공학 (Feature Engineering)

### 6.1 시간 기반 특징

| 특징 | 설명 | 코드 예시 |
|------|------|---------|
| 요일 | 주기적 패턴 | `df['dayofweek']` |
| 월 | 계절성 | `df['month']` |
| 사인/코사인 변환 | 연속적 주기 | $\sin(2\pi t / P)$ |
| 시차 특징 | 과거 값 | `df['lag_7']` |
| 롤링 통계 | 이동 평균/분산 | `df['roll_mean_7']` |

### 6.2 ML 파이프라인

```python
import pandas as pd
import numpy as np

def create_features(df, target_col, lags=[1, 7, 14, 28]):
    features = pd.DataFrame(index=df.index)
    # 시차 특징
    for lag in lags:
        features[f'lag_{lag}'] = df[target_col].shift(lag)
    # 롤링 통계
    for window in [7, 14, 28]:
        features[f'roll_mean_{window}'] = df[target_col].shift(1).rolling(window).mean()
        features[f'roll_std_{window}'] = df[target_col].shift(1).rolling(window).std()
    # 시간 특징
    features['dayofweek'] = df.index.dayofweek
    features['month'] = df.index.month
    features['dayofweek_sin'] = np.sin(2 * np.pi * features['dayofweek'] / 7)
    features['dayofweek_cos'] = np.cos(2 * np.pi * features['dayofweek'] / 7)
    return features.dropna()
```

> **핵심 직관**: 시차 특징을 만들 때 반드시 `.shift(1)` 이상으로 미래 정보 누출을 방지해야 합니다. ts-09에서 강조한 시간 순서 유지가 특징 공학에서도 적용됩니다.

---

## 7. 종합 워크플로우와 모델 선택 가이드

### 7.1 실전 워크플로우

| 단계 | 작업 | 참조 |
|------|------|------|
| 1. 탐색 | 시각화, 분해, ACF/PACF | ts-01 |
| 2. 전처리 | 결측 처리, 이상치, 정상화 | ts-08 |
| 3. 기준선 | 나이브, 계절 나이브, ETS | ts-04 |
| 4. 모델링 | ARIMA / Prophet / DL | ts-03, 09, 10 |
| 5. 평가 | 시계열 CV, MASE | ts-09 |
| 6. 불확실성 | 예측 구간, 컨포멀 | 본 강의 |
| 7. 배포 | 모니터링, 재학습 | ts-11 |

### 7.2 모델 선택 의사결정 트리

| 질문 | 예 | 아니오 |
|------|---|-------|
| 시계열이 100개 이상? | 교차 학습 DL | 통계 모델 |
| 외생 변수 중요? | SARIMAX, TFT | ARIMA, ETS |
| 다중 계절성? | Prophet, TBATS | SARIMA |
| 변동성 모델링 필요? | GARCH | 조건부 평균 모델 |
| 해석 필요? | ETS, Prophet, TFT | N-BEATS, PatchTST |

> **핵심 직관**: 실전에서 가장 중요한 것은 **기준선(baseline)**입니다. 나이브 예측도 이기지 못하는 복잡한 모델은 가치가 없습니다.

---

## 핵심 정리

- **수요 예측에서 간헐적 수요는 Croston 방법으로, 계층 구조는 MinT 조정으로 처리하며, 합산 일관성을 보장해야 합니다.**
- **금융 시계열의 핵심은 GARCH를 통한 조건부 분산(변동성) 모델링이며, 수익률의 두꺼운 꼬리와 비대칭성을 고려합니다.**
- **센서 데이터에서는 결측값 보간·이상치 클리핑·드리프트 보정 등 전처리가 전체 작업의 80%를 차지합니다.**
- **컨포멀 예측은 분포 가정 없이 유한 표본에서 유효한 예측 구간을 제공하며, 전통적 정규성 가정보다 견고합니다.**
- **실전 워크플로우는 반드시 나이브 기준선에서 시작하고, 모델 복잡도는 성능 향상이 확인될 때만 증가시킵니다.**
