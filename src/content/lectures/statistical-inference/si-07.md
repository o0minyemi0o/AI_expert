# 신뢰 구간과 신뢰 영역

## 왜 구간 추정이 필요한가

si-02에서 다룬 MLE는 점 추정값 하나만 제공합니다. 하지만 "평균이 3.5입니다"보다 "평균이 3.2에서 3.8 사이입니다"라는 표현이 추정의 불확실성을 훨씬 잘 전달합니다. 신뢰 구간(confidence interval)은 모수의 불확실성을 정량화하는 핵심 도구이며, si-05의 가설 검정과 쌍대(duality) 관계에 있습니다.

---

## 1. 신뢰 구간의 정의

**$100(1-\alpha)\%$ 신뢰 구간** $[L(X), U(X)]$는 다음을 만족합니다.

$$P_\theta(L(X) \leq \theta \leq U(X)) \geq 1 - \alpha \quad \forall \theta \in \Theta$$

| 구분 | 올바른 해석 | 잘못된 해석 |
|------|-----------|------------|
| 빈도적 | 반복 실험에서 구간의 $95\%$가 참값을 포함 | 이 구간에 참값이 있을 확률이 $95\%$ |
| 확률 | $L, U$가 확률 변수 (데이터에 따라 변함) | $\theta$가 확률 변수 |

> **핵심 직관**: 신뢰 구간의 확률 진술은 "절차"에 대한 것이지, 특정 구간에 대한 것이 아닙니다. "이 방법으로 만든 구간의 95%가 참값을 포함한다"가 정확한 해석입니다.

```python
import numpy as np
from scipy.stats import t, norm

# 정규 분포 평균의 95% 신뢰 구간
np.random.seed(42)
data = np.random.normal(5, 2, 30)
n = len(data)
xbar = np.mean(data)
se = np.std(data, ddof=1) / np.sqrt(n)
t_crit = t.ppf(0.975, df=n-1)

ci_lower = xbar - t_crit * se
ci_upper = xbar + t_crit * se
print(f"표본 평균: {xbar:.4f}")
print(f"95% CI: ({ci_lower:.4f}, {ci_upper:.4f})")
```

---

## 2. 피벗 방법 (Pivotal Method)

**피벗(pivot)**은 데이터와 모수의 함수이지만, 분포가 모수에 의존하지 않는 양입니다.

$$Q(X, \theta) \sim F \quad (\theta\text{에 무관})$$

피벗으로부터 신뢰 구간을 구성합니다.

$$P(a \leq Q(X, \theta) \leq b) = 1 - \alpha \implies \text{CI for } \theta$$

| 모수 | 피벗 | 분포 |
|------|------|------|
| $\mu$ ($\sigma$ 알려짐) | $\frac{\bar{X}-\mu}{\sigma/\sqrt{n}}$ | $N(0,1)$ |
| $\mu$ ($\sigma$ 미지) | $\frac{\bar{X}-\mu}{S/\sqrt{n}}$ | $t_{n-1}$ |
| $\sigma^2$ | $\frac{(n-1)S^2}{\sigma^2}$ | $\chi^2_{n-1}$ |
| $\mu_1 - \mu_2$ | $\frac{(\bar{X}_1 - \bar{X}_2) - (\mu_1-\mu_2)}{S_p\sqrt{1/n_1 + 1/n_2}}$ | $t_{n_1+n_2-2}$ |

> **핵심 직관**: 피벗은 "모수를 모르더라도 분포를 아는 통계량"입니다. 이 분포의 분위수를 사용하여 모수에 대한 구간을 "역산"합니다.

```python
from scipy.stats import chi2

# 분산의 신뢰 구간 (피벗 방법)
n = 30
s2 = np.var(data, ddof=1)
chi2_lower = chi2.ppf(0.975, df=n-1)
chi2_upper = chi2.ppf(0.025, df=n-1)

ci_var = ((n-1)*s2/chi2_lower, (n-1)*s2/chi2_upper)
print(f"표본 분산: {s2:.4f}")
print(f"분산의 95% CI: ({ci_var[0]:.4f}, {ci_var[1]:.4f})")
```

---

## 3. 점근적 신뢰 구간

si-02에서 다룬 MLE의 점근 정규성을 활용합니다.

$$\hat{\theta}_{MLE} \stackrel{\text{approx}}{\sim} N\left(\theta, \frac{1}{n \cdot I(\theta)}\right)$$

**점근적 $100(1-\alpha)\%$ 신뢰 구간**:

$$\hat{\theta} \pm z_{\alpha/2} \cdot \hat{\text{se}}(\hat{\theta})$$

여기서 $\hat{\text{se}} = 1 / \sqrt{n \cdot \hat{I}(\hat{\theta})}$입니다.

| 방법 | 표준 오차 계산 | 장점 |
|------|-------------|------|
| 관측 정보 기반 | $\hat{\text{se}} = [- \ell''(\hat{\theta})]^{-1/2}$ | 데이터 적응적 |
| 기대 정보 기반 | $\hat{\text{se}} = [n \cdot I(\hat{\theta})]^{-1/2}$ | 이론적으로 깔끔 |
| 샌드위치 추정 | 모델 오특정에 강건 | 준모수적 |

> **핵심 직관**: 점근적 CI는 표본이 충분히 클 때만 정확합니다. 표본이 작거나 분포가 비대칭이면 부트스트랩 CI가 더 신뢰할 수 있습니다.

```python
import statsmodels.api as sm

# 로지스틱 회귀 계수의 점근적 CI
np.random.seed(42)
n = 200
X = sm.add_constant(np.random.randn(n))
beta = np.array([0.5, 1.0])
p = 1 / (1 + np.exp(-X @ beta))
y = np.random.binomial(1, p)

model = sm.Logit(y, X).fit(disp=0)
print(model.summary().tables[1])
# conf_int()는 점근적 왈드 CI
print(f"\n95% CI for beta_1: {model.conf_int()[1]}")
```

---

## 4. 부트스트랩 신뢰 구간

**부트스트랩(bootstrap)**은 데이터를 복원 추출하여 추정량의 분포를 근사합니다.

$$X^{*}_1, \dots, X^{*}_n \stackrel{\text{i.i.d.}}{\sim} \hat{F}_n \quad (\text{경험적 분포})$$

| 부트스트랩 CI 방법 | 구간 | 특징 |
|------------------|------|------|
| 백분위수 (Percentile) | $[\hat{\theta}^*_{\alpha/2}, \hat{\theta}^*_{1-\alpha/2}]$ | 가장 단순 |
| 기본 (Basic) | $[2\hat{\theta} - \hat{\theta}^*_{1-\alpha/2}, 2\hat{\theta} - \hat{\theta}^*_{\alpha/2}]$ | 편향 보정 |
| BCa | 편향-가속 보정 적용 | 이론적으로 우수 |
| 부트스트랩-t | 학생화 부트스트랩 | 2차 정확성 |

> **핵심 직관**: 부트스트랩은 "데이터로부터 데이터를 만들어 불확실성을 추정"합니다. 분포 가정이 필요 없으므로 비모수적이며, 복잡한 통계량에도 적용 가능합니다.

```python
from scipy.stats import pearsonr

# 상관 계수의 부트스트랩 CI
np.random.seed(42)
x = np.random.normal(0, 1, 50)
y = 0.6 * x + np.random.normal(0, 0.8, 50)

n_boot = 10000
boot_corrs = []
for _ in range(n_boot):
    idx = np.random.choice(len(x), len(x), replace=True)
    r, _ = pearsonr(x[idx], y[idx])
    boot_corrs.append(r)

boot_corrs = np.array(boot_corrs)
ci_percentile = (np.percentile(boot_corrs, 2.5), np.percentile(boot_corrs, 97.5))
print(f"표본 상관: {pearsonr(x, y)[0]:.4f}")
print(f"부트스트랩 95% CI (백분위수): ({ci_percentile[0]:.4f}, {ci_percentile[1]:.4f})")
```

---

## 5. 신뢰 영역 (Confidence Regions)

다변수 모수 $\boldsymbol{\theta} \in \mathbb{R}^d$에 대한 $100(1-\alpha)\%$ **신뢰 영역**:

$$C(X) = \{\boldsymbol{\theta} : (\hat{\boldsymbol{\theta}} - \boldsymbol{\theta})^T \hat{I}(\hat{\boldsymbol{\theta}}) (\hat{\boldsymbol{\theta}} - \boldsymbol{\theta}) \leq \chi^2_{d, \alpha}\}$$

이것은 $d$-차원 타원체입니다.

| $d$ | 형태 | 시각화 |
|-----|------|--------|
| 1 | 구간 | 선분 |
| 2 | 타원 | 2D 타원 |
| $d$ | 초타원체 | — |

**주변 CI vs 동시 CI**:

$$\text{주변: } \hat{\theta}_j \pm z_{\alpha/2} \hat{\text{se}}_j \quad \text{vs} \quad \text{동시 (Bonferroni): } \hat{\theta}_j \pm z_{\alpha/(2d)} \hat{\text{se}}_j$$

> **핵심 직관**: 개별 CI를 따로 만들면 동시 커버리지가 $1-\alpha$보다 낮아집니다. 여러 모수를 동시에 포함하려면 신뢰 영역이나 Bonferroni 보정이 필요합니다. si-11에서 다중 검정과 함께 더 다룹니다.

```python
# 이변량 정규 분포의 신뢰 타원
from scipy.stats import chi2
import matplotlib
matplotlib.use('Agg')

np.random.seed(42)
n = 100
mu_true = np.array([1, 2])
Sigma = np.array([[1, 0.5], [0.5, 1]])
data = np.random.multivariate_normal(mu_true, Sigma, n)

mu_hat = data.mean(axis=0)
cov_hat = np.cov(data.T) / n  # 평균의 공분산
chi2_val = chi2.ppf(0.95, df=2)

print(f"추정된 평균: {mu_hat}")
print(f"chi2(2, 0.95) = {chi2_val:.4f}")
print(f"타원의 반지름 스케일: sqrt(chi2_val) = {np.sqrt(chi2_val):.4f}")
```

---

## 6. 검정과 신뢰 구간의 쌍대성

**쌍대성(duality)**: $100(1-\alpha)\%$ 신뢰 구간과 유의 수준 $\alpha$ 검정 사이에는 일대일 대응이 있습니다.

$$\theta_0 \in \text{CI}(X) \iff H_0: \theta = \theta_0 \text{를 기각하지 않음}$$

| 검정 | 대응 CI |
|------|---------|
| z-검정 | $\bar{X} \pm z_{\alpha/2} \cdot \sigma/\sqrt{n}$ |
| t-검정 | $\bar{X} \pm t_{\alpha/2, n-1} \cdot S/\sqrt{n}$ |
| LRT | $\{\theta : -2\log\Lambda(\theta) \leq \chi^2_{1,\alpha}\}$ |

> **핵심 직관**: "기각할 수 없는 모든 $\theta_0$의 집합"이 곧 신뢰 구간입니다. si-05의 가설 검정과 구간 추정은 같은 동전의 양면입니다.

```python
# 쌍대성 확인: t-검정과 CI
from scipy.stats import ttest_1samp

data = np.random.normal(5, 2, 25)
n = len(data)
xbar = np.mean(data)
se = np.std(data, ddof=1) / np.sqrt(n)

# CI
t_crit = t.ppf(0.975, df=n-1)
ci = (xbar - t_crit*se, xbar + t_crit*se)

# theta_0 = 4.5: CI 안에 있는가? <-> 기각하지 않는가?
theta_0 = 4.5
stat, p = ttest_1samp(data, theta_0)
print(f"95% CI: ({ci[0]:.4f}, {ci[1]:.4f})")
print(f"H0: mu={theta_0}, p-value={p:.4f}")
print(f"theta_0 in CI: {ci[0] <= theta_0 <= ci[1]}")
print(f"기각하지 않음: {p > 0.05}")
```

---

## 7. 베이즈 신용 구간과의 비교

**베이즈 신용 구간(credible interval)**은 사후 분포로부터 직접 구합니다.

$$P(\theta \in C | x) = 1 - \alpha$$

| 구분 | 신뢰 구간 (빈도) | 신용 구간 (베이즈) |
|------|----------------|------------------|
| 해석 | 반복 실험에서 95% 커버 | $\theta$가 구간에 있을 확률 95% |
| 모수 | 고정된 상수 | 확률 변수 |
| 사전 정보 | 불요 | 사전 분포 필요 |
| 소표본 | 근사적 | 정확 (사전에 의존) |
| 대표본 | 수렴 | 수렴 (CI와 일치) |

si-03에서 다룬 베이즈 프레임워크에서는 **HPD(Highest Posterior Density)** 구간이 가장 짧은 신용 구간입니다.

> **핵심 직관**: 데이터가 많아지면 신뢰 구간과 신용 구간은 수렴합니다. 하지만 해석은 근본적으로 다르며, 소표본에서는 사전 분포의 선택이 큰 영향을 미칩니다.

---

## 핵심 정리

- **$100(1-\alpha)\%$ 신뢰 구간은 "이 절차로 만든 구간의 $100(1-\alpha)\%$가 참값을 포함한다"는 빈도적 보장입니다**
- **피벗 방법은 분포가 모수에 무관한 양을 이용하여 정확한 CI를 구성하며, t-분포와 $\chi^2$-분포가 대표적 피벗입니다**
- **점근적 CI는 MLE의 정규성에 기반하며, $\hat{\theta} \pm z_{\alpha/2} \cdot \hat{\text{se}}$ 형태로 대표본에서 널리 사용됩니다**
- **부트스트랩 CI는 분포 가정 없이 재표집으로 불확실성을 추정하며, 복잡한 통계량에도 적용 가능합니다**
- **가설 검정과 신뢰 구간은 쌍대 관계이며, "기각할 수 없는 $\theta_0$의 집합"이 곧 신뢰 구간입니다**
