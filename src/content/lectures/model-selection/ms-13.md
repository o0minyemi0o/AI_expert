# 추천 시스템 설계

## 왜 추천 시스템 모델 선택이 중요한가

추천 시스템은 넷플릭스, 아마존, 유튜브 등 현대 서비스의 핵심 엔진입니다. 넷플릭스 시청의 80%, 유튜브 시청의 70%가 추천에 의해 발생한다고 알려져 있습니다. 하지만 추천 문제는 데이터 특성(암시적/명시적 피드백), 시스템 규모, cold start 문제에 따라 최적 접근법이 크게 달라집니다.

이 강의에서는 협업 필터링부터 딥러닝 추천까지, 각 접근법의 적합한 상황과 선택 기준을 비교합니다.

---

## 1. 추천 시스템 접근법 분류

| 접근법 | 핵심 아이디어 | 필요 데이터 | Cold Start | 다양성 |
|--------|-------------|-----------|-----------|--------|
| 인기도 기반 | 전체 인기 순위 | 최소한 | 해결 | 매우 낮음 |
| 콘텐츠 기반 | 아이템 속성 유사도 | 아이템 메타데이터 | 아이템만 해결 | 중간 |
| 협업 필터링 | 사용자 행동 패턴 유사도 | 상호작용 로그 | 미해결 | 높음 |
| 행렬 분해 | 잠재 요인 분해 | 평점/상호작용 | 미해결 | 중간 |
| 딥러닝 | 복합 패턴 학습 | 대규모 다양한 데이터 | 부분 해결 | 높음 |
| 하이브리드 | 여러 접근법 결합 | 다양한 데이터 | 부분 해결 | 높음 |

```
추천 시스템 접근법 선택 플로우:

사용자 상호작용 데이터가 있는가?
├── 없음 → 인기도 기반 / 콘텐츠 기반
│            └── 아이템 메타데이터 있음? → 콘텐츠 기반
├── 적음 (< 10K 상호작용)
│   ├── 명시적 평점 → 행렬 분해 (ALS, SVD)
│   └── 암시적 피드백 → 아이템 기반 협업 필터링
├── 중간 (10K ~ 1M)
│   ├── 단순 구조 → 행렬 분해 + 콘텐츠 하이브리드
│   └── 복합 피처 → Two-Tower / NCF
└── 많음 (> 1M)
    └── 딥러닝 (Two-Tower, Transformer 기반)
        └── 실시간 필요? → 근사 최근접 이웃 검색 (ms-16)
```

---

## 2. 협업 필터링

### User-based vs Item-based

| 특성 | User-based | Item-based |
|------|-----------|-----------|
| 원리 | 유사한 사용자의 선호 활용 | 유사한 아이템의 평점 활용 |
| 확장성 | 사용자 수 증가 시 느림 | 아이템 수가 적으면 효율적 |
| 설명가능성 | "비슷한 사용자들이 좋아함" | "이 아이템과 비슷한 아이템" |
| 적합 상황 | 사용자 < 아이템 | 아이템 < 사용자 |
| Cold start | 새 아이템에 약함 | 새 사용자에 약함 |

> **핵심 직관**: 실무에서는 Item-based 협업 필터링이 User-based보다 훨씬 많이 사용됩니다. 아이템 간 유사도는 상대적으로 안정적이지만, 사용자 취향은 빠르게 변하기 때문입니다.

```python
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np

# Item-based 협업 필터링 간단 예시
# 행: 사용자, 열: 아이템, 값: 평점 (0=미평가)
ratings = np.array([
    [5, 3, 0, 1],
    [4, 0, 0, 1],
    [1, 1, 0, 5],
    [0, 0, 5, 4],
    [0, 1, 5, 4],
])

# 아이템 간 코사인 유사도
item_sim = cosine_similarity(ratings.T)
print("아이템 유사도 행렬:")
print(np.round(item_sim, 2))

# 사용자 0에게 아이템 2 추천 점수 예측
user = 0
target_item = 2
rated_items = np.where(ratings[user] > 0)[0]
scores = item_sim[target_item, rated_items]
rating_vals = ratings[user, rated_items]
pred = np.dot(scores, rating_vals) / (np.abs(scores).sum() + 1e-8)
print(f"\n사용자 {user}의 아이템 {target_item} 예측 평점: {pred:.2f}")
```

---

## 3. 행렬 분해

사용자-아이템 평점 행렬 $\mathbf{R}$을 저차원 행렬로 분해합니다: $\mathbf{R} \approx \mathbf{U} \mathbf{V}^\top$ (la-08 참조)

| 방법 | 알고리즘 | 특징 | 적합한 상황 |
|------|---------|------|------------|
| SVD | 특이값 분해 | 명시적 평점 | 작은 밀집 행렬 |
| ALS | 교대 최소제곱 | 암시적/명시적 | 대규모, 분산 처리 |
| SVD++ | SVD + 암시적 | 추가 정보 활용 | 정확도 향상 필요 시 |
| NMF | 비음수 분해 | 해석 가능한 요인 | 양수 평점 데이터 |

### 언제 쓰는가
- 사용자-아이템 상호작용 데이터가 주어졌을 때
- 잠재 요인(latent factor) 기반 추천이 적합할 때
- 중간 규모 데이터에서 좋은 정확도가 필요할 때

### 언제 쓰지 않는가
- 사이드 정보(아이템 설명, 사용자 프로필)를 활용해야 할 때
- 순서/시간 정보가 중요할 때

```python
from surprise import SVD, Dataset, Reader, accuracy
from surprise.model_selection import cross_validate
import pandas as pd

# Surprise 라이브러리로 SVD 추천
# 데이터 형식: (user_id, item_id, rating)
data_dict = {
    'user': [1,1,1,2,2,3,3,3,4,4],
    'item': ['A','B','C','A','C','B','C','D','A','D'],
    'rating': [5,3,1,4,2,1,5,4,2,5],
}
df = pd.DataFrame(data_dict)
reader = Reader(rating_scale=(1, 5))
data = Dataset.load_from_df(df[['user', 'item', 'rating']], reader)

model = SVD(n_factors=10, n_epochs=20, random_state=42)
results = cross_validate(model, data, measures=['RMSE', 'MAE'], cv=3, verbose=True)
```

> **핵심 직관**: 행렬 분해는 추천 시스템의 "골든 스탠다드"입니다. 딥러닝 모델이 항상 행렬 분해를 이기는 것은 아니며, 데이터가 충분하지 않으면 SVD/ALS가 더 안정적입니다.

### 시나리오: 음악 스트리밍 플레이리스트 추천

음악 스트리밍 서비스에서 개인화 플레이리스트를 생성하려 합니다. 데이터는 1억 건의 재생 로그, 100만 유저 × 50만 곡의 상호작용 행렬이며, 희소율은 99.9%입니다(대부분의 유저가 전체 곡의 극히 일부만 청취). 피드백은 암시적(재생 횟수, 스킵 여부, 완청 비율)입니다.

99.9% 희소 행렬에서는 ALS(Alternating Least Squares) 행렬 분해가 최적의 출발점입니다. ALS는 암시적 피드백 처리에 특화되어 있고, Spark MLlib으로 분산 학습이 가능하여 1억 건 규모를 처리할 수 있습니다. 잠재 요인 128차원으로 시작하면 Recall@50 기준 약 30%를 달성합니다. 이후 사용자 청취 시퀀스, 장르 메타데이터, 시간대 정보를 활용하려면 Two-Tower 모델로 확장합니다. Two-Tower는 유저/곡 임베딩을 FAISS로 서빙하여 100ms 이내 실시간 추천이 가능하며, Recall@50이 40% 이상으로 향상됩니다.

---

## 4. 딥러닝 추천

### Two-Tower Model

사용자와 아이템을 각각 독립적인 신경망으로 임베딩한 후, 내적으로 매칭합니다.

### NCF (Neural Collaborative Filtering)

사용자/아이템 임베딩을 MLP로 비선형 결합합니다.

| 모델 | 복잡도 | 서빙 효율 | 사이드 정보 | 적합 상황 |
|------|--------|----------|-----------|----------|
| Two-Tower | 중간 | 매우 높음 (ANN 검색) | 지원 | 대규모 실시간 |
| NCF | 중간 | 낮음 (전수 계산) | 제한적 | 연구/소규모 |
| Wide & Deep | 높음 | 중간 | 지원 | 광고, 앱 추천 |
| DIN/DIEN | 높음 | 중간 | 행동 시퀀스 | 이커머스 |

```
딥러닝 추천 모델 선택:

서빙 요구사항은?
├── 실시간 (< 100ms)
│   └── Two-Tower + FAISS/ANN 검색 (ms-16)
├── 준실시간 (< 1s)
│   └── NCF / Wide & Deep
└── 배치
    └── 행렬 분해도 충분
        └── 정확도 더 필요? → DIN/DIEN
```

---

## 5. Cold Start 문제 해결 전략

새로운 사용자나 아이템에 대한 데이터가 없을 때 발생하는 문제입니다.

| 전략 | 대상 | 방법 | 효과 |
|------|------|------|------|
| 인기도 추천 | 새 사용자 | 전체/세그먼트 인기 아이템 | 기본적 |
| 콘텐츠 기반 | 새 아이템 | 아이템 속성으로 유사 아이템 매칭 | 중간 |
| 온보딩 설문 | 새 사용자 | 선호 장르/카테고리 직접 수집 | 높음 |
| 사이드 정보 활용 | 양쪽 | 인구통계, 아이템 메타데이터 | 중간 |
| 탐색/활용 | 새 사용자 | 다양한 추천으로 피드백 수집 | 장기적 |

```
Cold Start 해결 플로우:

누가 새로운가?
├── 새 사용자
│   ├── 인구통계 있음 → 세그먼트별 인기 추천
│   ├── 온보딩 가능 → 선호 조사 후 콘텐츠 기반
│   └── 아무것도 없음 → 전체 인기도 + 탐색
├── 새 아이템
│   ├── 메타데이터 있음 → 콘텐츠 기반 유사 아이템
│   └── 메타데이터 없음 → 랜덤 노출로 데이터 수집
└── 양쪽 모두 새로움
    └── 인기도 기반 + 빠른 피드백 루프
```

> **핵심 직관**: Cold start는 완벽히 해결할 수 없지만, **하이브리드 접근**으로 완화할 수 있습니다. 협업 필터링의 약점을 콘텐츠 기반으로 보완하고, 초기에는 탐색(exploration)을 강화하는 것이 핵심입니다.

### 시나리오: 뉴스 앱 개인화 추천

뉴스 앱에서 사용자별 맞춤 뉴스 피드를 구성하려 합니다. 일일 신규 기사 5,000건, 월간 활성 유저 200만 명, 기사당 평균 수명 24시간입니다. 기사 메타데이터로는 카테고리, 키워드, 본문 텍스트가 있고, 유저 행동 데이터로는 클릭, 체류 시간, 공유가 있습니다.

기사의 수명이 24시간으로 매우 짧기 때문에 전통적인 협업 필터링은 효과가 제한적입니다. 새 기사가 매일 대량 유입되므로 아이템 cold start가 상시 발생합니다. 따라서 콘텐츠 기반 접근으로 시작합니다. 기사 본문을 BERT 임베딩으로 벡터화하고, 유저의 최근 24시간 클릭 기사와의 코사인 유사도로 추천합니다. 신규 유저(cold start)에게는 인기도 기반 + 카테고리 선호 설문으로 대응합니다. 유저의 행동 데이터가 2주 이상 축적되면, 유사 유저 그룹의 클릭 패턴을 반영하는 협업 필터링을 추가하여 하이브리드 방식으로 전환합니다.

---

## 핵심 정리

1. **항상 인기도 기반 베이스라인부터 시작**: "가장 인기 있는 아이템 추천"은 놀라울 정도로 강력하며, 이를 이기지 못하면 복잡한 모델은 가치가 없습니다.
2. **협업 필터링은 Item-based가 실무 표준**: 아이템 유사도는 안정적이고, 설명가능성("이 아이템을 좋아한 사용자들은...")이 높으며, 구현이 상대적으로 간단합니다.
3. **행렬 분해는 정확도와 확장성의 균형점**: SVD/ALS는 중간 규모에서 딥러닝과 경쟁할 만한 정확도를 제공하며, 학습과 서빙이 효율적입니다.
4. **딥러닝 추천은 대규모 + 복합 피처에서 유리**: Two-Tower 모델은 대규모 실시간 추천에 적합하며, FAISS와 결합하면 밀리초 단위 서빙이 가능합니다.
5. **Cold start는 하이브리드로 완화**: 협업 필터링의 cold start 문제를 콘텐츠 기반 추천, 인구통계 활용, 온보딩 설문으로 보완하는 하이브리드 전략이 필수적입니다.
