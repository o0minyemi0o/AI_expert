# 쌍대 이론

## 왜 쌍대 이론을 배워야 하는가

co-10과 co-11에서 라그랑주 함수와 KKT 조건을 배웠습니다. 쌍대 이론(duality theory)은 이 기반 위에서 최적화 문제를 **완전히 다른 관점**으로 바라보는 프레임워크입니다.

원래 문제(원시 문제)를 직접 풀기 어려울 때, 동일하거나 비슷한 최적값을 주는 **쌍대 문제(dual problem)**를 대신 풀 수 있습니다. SVM의 쌍대 문제, 정보 이론의 최대 엔트로피 원리, 그리고 현대 볼록 최적화 알고리즘의 상당 부분이 쌍대 이론에 기반합니다.

---

## 1. 라그랑주 쌍대 함수

co-11의 라그랑주 함수에서 출발합니다:

$$
\mathcal{L}(\mathbf{x}, \boldsymbol{\mu}, \boldsymbol{\lambda}) = f(\mathbf{x}) + \sum_{i} \mu_i g_i(\mathbf{x}) + \sum_j \lambda_j h_j(\mathbf{x})
$$

**쌍대 함수(dual function)**는 $\mathcal{L}$을 $\mathbf{x}$에 대해 최소화한 것입니다:

$$
d(\boldsymbol{\mu}, \boldsymbol{\lambda}) = \inf_{\mathbf{x}} \mathcal{L}(\mathbf{x}, \boldsymbol{\mu}, \boldsymbol{\lambda})
$$

> **핵심 직관**: 쌍대 함수는 원래 문제의 최적값 $p^*$에 대한 **하한(lower bound)** 을 제공합니다. 어떤 타당한 $(\boldsymbol{\mu} \geq 0, \boldsymbol{\lambda})$에 대해서도 $d(\boldsymbol{\mu}, \boldsymbol{\lambda}) \leq p^*$입니다.

---

## 2. 약 쌍대성

**정리 (Weak Duality)**: 쌍대 문제의 최적값 $d^*$는 원시 문제의 최적값 $p^*$의 하한입니다.

$$
d^* = \max_{\boldsymbol{\mu} \geq 0, \boldsymbol{\lambda}} d(\boldsymbol{\mu}, \boldsymbol{\lambda}) \leq p^* = \min_\mathbf{x} f(\mathbf{x})
$$

**증명**: 타당한 $\mathbf{x}$에 대해 $g_i(\mathbf{x}) \leq 0$, $h_j(\mathbf{x}) = 0$, $\mu_i \geq 0$이므로:

$$
\mathcal{L}(\mathbf{x}, \boldsymbol{\mu}, \boldsymbol{\lambda}) = f(\mathbf{x}) + \underbrace{\sum_i \mu_i g_i(\mathbf{x})}_{\leq 0} + \underbrace{\sum_j \lambda_j h_j(\mathbf{x})}_{= 0} \leq f(\mathbf{x})
$$

따라서 $d(\boldsymbol{\mu}, \boldsymbol{\lambda}) = \inf_\mathbf{x} \mathcal{L} \leq \mathcal{L}(\mathbf{x}, \boldsymbol{\mu}, \boldsymbol{\lambda}) \leq f(\mathbf{x})$.

**쌍대 갭(duality gap)**: $p^* - d^* \geq 0$

```
        p*  (원시 최적값)
    ──────────── 원시
         │
         │  쌍대 갭 (≥ 0)
         │
    ──────────── 쌍대
        d*  (쌍대 최적값)
```

---

## 3. 강 쌍대성과 Slater 조건

**강 쌍대성(strong duality)**: $p^* = d^*$, 즉 쌍대 갭이 0인 경우입니다.

**Slater 조건**: $f$, $g_i$가 볼록이고, 다음을 만족하는 **엄격 타당점(strictly feasible point)**이 존재하면 강 쌍대성이 성립합니다:

$$
\exists \hat{\mathbf{x}}: \quad g_i(\hat{\mathbf{x}}) < 0, \; \forall i, \quad h_j(\hat{\mathbf{x}}) = 0, \; \forall j
$$

| 조건 | 쌍대 갭 | 적용 범위 |
|------|---------|----------|
| 일반 문제 | $\geq 0$ (약 쌍대) | 항상 |
| 볼록 + Slater | $= 0$ (강 쌍대) | 대부분의 볼록 문제 |
| 선형 계획법 | $= 0$ (항상) | LP는 항상 강 쌍대 |

> **핵심 직관**: 강 쌍대성이 성립하면, 원시 문제를 푸는 대신 쌍대 문제를 풀어도 같은 답을 얻습니다. 쌍대 문제가 더 쉬운 구조를 가질 때 매우 유용합니다.

---

## 4. 원시-쌍대 관계 정리

```
원시 문제 (Primal)              쌍대 문제 (Dual)
───────────────────            ───────────────────
min f(x)                       max d(μ, λ)
s.t. g_i(x) ≤ 0              s.t. μ ≥ 0
     h_j(x) = 0

    x ∈ ℝⁿ                    (μ, λ) ∈ ℝᵐ⁺ᵖ

  p* ─ ─ ─ ≥ ─ ─ ─ d*  (약 쌍대)
  p* ─ ─ ─ = ─ ─ ─ d*  (강 쌍대, Slater 조건 시)
```

---

## 5. 구체적 예제: 이차 계획의 쌍대

원시 문제:
$$
\min_\mathbf{x} \frac{1}{2}\mathbf{x}^\top Q \mathbf{x} + \mathbf{c}^\top \mathbf{x} \quad \text{s.t.} \quad A\mathbf{x} \leq \mathbf{b}
$$

라그랑주 함수:
$$
\mathcal{L}(\mathbf{x}, \boldsymbol{\mu}) = \frac{1}{2}\mathbf{x}^\top Q \mathbf{x} + \mathbf{c}^\top \mathbf{x} + \boldsymbol{\mu}^\top(A\mathbf{x} - \mathbf{b})
$$

$\mathbf{x}$에 대해 최소화: $\nabla_\mathbf{x} \mathcal{L} = Q\mathbf{x} + \mathbf{c} + A^\top\boldsymbol{\mu} = \mathbf{0}$

$$
\mathbf{x}^* = -Q^{-1}(\mathbf{c} + A^\top \boldsymbol{\mu})
$$

대입하면 쌍대 함수:

$$
d(\boldsymbol{\mu}) = -\frac{1}{2}(\mathbf{c} + A^\top\boldsymbol{\mu})^\top Q^{-1}(\mathbf{c} + A^\top\boldsymbol{\mu}) - \mathbf{b}^\top\boldsymbol{\mu}
$$

쌍대 문제: $\max_{\boldsymbol{\mu} \geq 0} d(\boldsymbol{\mu})$

---

## 6. Python으로 쌍대 갭 확인

```python
import numpy as np
from scipy.optimize import minimize, linprog

# 간단한 LP: min c^T x s.t. Ax <= b, x >= 0
c = np.array([1, 2])
A_ub = np.array([[-1, -1], [-1, 0], [0, -1]])
b_ub = np.array([-3, 0, 0])  # x+y >= 3, x >= 0, y >= 0

# 원시 문제
primal = linprog(c, A_ub=A_ub, b_ub=b_ub)
p_star = primal.fun
print(f"원시 최적값 p* = {p_star:.4f}")
print(f"원시 최적점: x = ({primal.x[0]:.4f}, {primal.x[1]:.4f})")

# LP의 쌍대: max b^T μ s.t. A^T μ = c, μ >= 0
# (표준 LP 쌍대 규칙 적용)
# 쌍대 문제도 LP로 풀기
dual = linprog(-b_ub, A_ub=-A_ub.T, b_ub=-c,
               bounds=[(0, None)]*3)
d_star = -dual.fun
print(f"\n쌍대 최적값 d* = {d_star:.4f}")
print(f"쌍대 변수:    μ = {dual.x}")
print(f"\n쌍대 갭: p* - d* = {p_star - d_star:.6f}")
```

출력:
```
원시 최적값 p* = 3.0000
원시 최적점: x = (3.0000, 0.0000)

쌍대 최적값 d* = 3.0000
쌍대 변수:    μ = [1. 0. 2.]

쌍대 갭: p* - d* = 0.000000
```

> **핵심 직관**: LP(선형 계획법)에서는 항상 강 쌍대성이 성립합니다. 쌍대 갭이 정확히 0이며, 이것이 simplex 알고리즘과 내부점 방법의 이론적 기반입니다.

---

## 7. ML에서의 쌍대 이론 응용

| 문제 | 원시 형태 | 쌍대의 이점 |
|------|----------|-----------|
| SVM (co-15) | $\min \frac{1}{2}\|\mathbf{w}\|^2$ s.t. 마진 제약 | 쌍대에서 커널 트릭 적용 가능 |
| 최대 엔트로피 | 제약 하 엔트로피 최대화 | 지수 족(exponential family) 유도 |
| Wasserstein 거리 | 최적 수송 문제 | Kantorovich 쌍대 |
| 정보 이론 | 채널 용량 계산 | 볼록 쌍대 문제로 변환 |

---

## 8. 쌍대성과 KKT의 관계

강 쌍대성이 성립할 때:

$$
p^* = d^* \iff \text{KKT 조건을 만족하는 } (\mathbf{x}^*, \boldsymbol{\mu}^*, \boldsymbol{\lambda}^*) \text{가 존재}
$$

co-11의 KKT 조건은 원시-쌍대 최적점의 **필요충분조건**입니다.

> **핵심 직관**: KKT 조건, 강 쌍대성, 원시-쌍대 최적 — 이 세 개념은 볼록 문제에서 **동치**입니다. 어느 하나를 증명하면 나머지가 자동으로 따라옵니다.

---

## 핵심 정리

1. **쌍대 함수** $d(\boldsymbol{\mu}, \boldsymbol{\lambda}) = \inf_\mathbf{x} \mathcal{L}$은 원시 최적값의 하한이며, 이것이 **약 쌍대성**이다.
2. **강 쌍대성** $p^* = d^*$은 볼록 문제에서 Slater 조건 하에 성립하며, 쌍대 문제를 풀어도 같은 답을 얻는다.
3. **쌍대 갭** $p^* - d^*$은 최적성의 인증서 역할을 하며, 0이면 현재 해가 최적임을 보장한다.
4. SVM의 쌍대 문제는 **커널 트릭**을 가능하게 하며, 이것이 쌍대 이론의 가장 유명한 ML 응용이다.
5. 강 쌍대성, KKT 조건, 원시-쌍대 최적은 볼록 문제에서 **동치 관계**이다.
