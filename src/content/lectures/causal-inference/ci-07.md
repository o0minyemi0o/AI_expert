# 도구 변수

## 왜 도구 변수가 필요한가

ci-06에서 다룬 경향 점수 방법은 관측된 교란 변수만 통제할 수 있습니다. 그러나 현실에서는 관측되지 않은 교란(unmeasured confounding)이 거의 항상 존재합니다. 도구 변수(Instrumental Variable, IV)는 관측되지 않은 교란이 존재하더라도 인과 효과를 식별할 수 있는 강력한 전략입니다.

---

## 1. 도구 변수의 정의와 세 가지 조건

도구 변수 $Z$는 치료 $T$에 영향을 미치지만, 결과 $Y$에는 $T$를 통해서만 영향을 미치는 변수입니다.

$$
Z \to T \to Y \quad \text{(인과 경로)}
$$
$$
Z \not\to Y \quad \text{(직접 효과 없음)}
$$
$$
Z \perp\!\!\!\perp U \quad \text{(교란과 독립)}
$$

| 조건 | 이름 | 수학적 표현 | DAG 해석 |
|------|------|------------|---------|
| IV1 | 관련성 (Relevance) | $\text{Cov}(Z, T) \neq 0$ | $Z \to T$ 연결 존재 |
| IV2 | 배제 제한 (Exclusion) | $Z \perp\!\!\!\perp Y \mid T, U$ | $Z$에서 $Y$로의 직접 경로 없음 |
| IV3 | 독립성 (Independence) | $Z \perp\!\!\!\perp U$ | $Z$와 교란 변수 독립 |

> **핵심 직관**: 징병 추첨 번호($Z$)는 베트남전 참전($T$) 여부에 영향을 미치지만, 이후의 소득($Y$)에는 참전을 통해서만 영향을 미칩니다. 추첨은 무작위이므로 교란과 독립입니다.

```python
import numpy as np

# 도구 변수 시뮬레이션
np.random.seed(42)
n = 10000

U = np.random.normal(0, 1, n)    # 관측 불가 교란 (능력, 동기 등)
Z = np.random.binomial(1, 0.5, n)  # 도구 변수 (추첨)
T = (0.8 * Z + 0.5 * U + np.random.normal(0, 1, n) > 0.5).astype(int)
Y = 2.0 * T + 1.5 * U + np.random.normal(0, 1, n)

# Naive OLS (편향)
naive = Y[T==1].mean() - Y[T==0].mean()
print(f"Naive 추정 (편향): {naive:.3f}")  # 2.0보다 큼 (U에 의한 상향 편향)
```

---

## 2. 2단계 최소제곱법 (2SLS)

2SLS(Two-Stage Least Squares)는 도구 변수를 활용한 가장 표준적인 추정 방법입니다.

**1단계 (First Stage):**
$$
T = \alpha_0 + \alpha_1 Z + \eta \quad \Rightarrow \quad \hat{T} = \hat{\alpha}_0 + \hat{\alpha}_1 Z
$$

**2단계 (Second Stage):**
$$
Y = \beta_0 + \beta_1 \hat{T} + \epsilon
$$

Wald 추정량 (이진 도구 변수의 경우):

$$
\hat{\beta}_{IV} = \frac{E[Y \mid Z=1] - E[Y \mid Z=0]}{E[T \mid Z=1] - E[T \mid Z=0]} = \frac{\text{축약형 효과}}{\text{1단계 효과}}
$$

| 단계 | 추정 대상 | 역할 |
|------|----------|------|
| 1단계 | $T$ on $Z$ | $T$에서 $Z$에 의한 변동만 추출 |
| 2단계 | $Y$ on $\hat{T}$ | 교란 없는 변동으로 인과 효과 추정 |
| 축약형 | $Y$ on $Z$ | $Z$→$Y$ 총 효과 (검증용) |

> **핵심 직관**: 2SLS는 $T$의 전체 변동에서 $Z$에 의한 "깨끗한" 변동만 사용합니다. 교란 변수 $U$에 의한 변동은 $Z$와 무관하므로 자동으로 제거됩니다.

```python
import numpy as np
import statsmodels.api as sm

# 2SLS 추정
np.random.seed(42)
n = 10000

U = np.random.normal(0, 1, n)
Z = np.random.normal(0, 1, n)  # 연속형 도구 변수
T = 0.7 * Z + 0.5 * U + np.random.normal(0, 0.5, n)
Y = 2.0 * T + 1.5 * U + np.random.normal(0, 1, n)

# Naive OLS
ols = sm.OLS(Y, sm.add_constant(T)).fit()
print(f"OLS (편향): {ols.params[1]:.3f}")

# 2SLS
# 1단계: T ~ Z
stage1 = sm.OLS(T, sm.add_constant(Z)).fit()
T_hat = stage1.predict(sm.add_constant(Z))

# 2단계: Y ~ T_hat
stage2 = sm.OLS(Y, sm.add_constant(T_hat)).fit()
print(f"2SLS: {stage2.params[1]:.3f}")  # ≈ 2.0

# Wald 추정량 (이진 Z의 경우)
Z_bin = (Z > 0).astype(int)
wald = (Y[Z_bin==1].mean() - Y[Z_bin==0].mean()) / (T[Z_bin==1].mean() - T[Z_bin==0].mean())
print(f"Wald 추정량: {wald:.3f}")
```

---

## 3. LATE와 순응자 프레임워크

도구 변수가 식별하는 인과 효과는 전체 ATE가 아니라 **LATE(Local Average Treatment Effect)**, 즉 순응자(complier)의 평균 효과입니다.

$$
\text{LATE} = E[Y(1) - Y(0) \mid \text{Complier}]
$$

| 유형 | 정의 | $T$ 행동 |
|------|------|----------|
| 순응자 (Complier) | $Z=1 \Rightarrow T=1$, $Z=0 \Rightarrow T=0$ | $Z$에 따름 |
| 항상 치료자 (Always-taker) | $T=1$ always | $Z$ 무관 |
| 절대 비치료자 (Never-taker) | $T=0$ always | $Z$ 무관 |
| 저항자 (Defier) | $Z=1 \Rightarrow T=0$, $Z=0 \Rightarrow T=1$ | $Z$에 반대 |

**단조성 가정 (Monotonicity):**

$$
T_i(Z=1) \geq T_i(Z=0) \quad \forall i \quad \text{(저항자 없음)}
$$

> **핵심 직관**: LATE는 "도구 변수에 반응하는 사람들"의 효과만 식별합니다. 징병 추첨 예시에서, 추첨 결과에 관계없이 자원입대하거나 면제받는 사람은 LATE에 포함되지 않습니다.

```python
import numpy as np

# LATE 시뮬레이션: 순응자의 효과만 식별
np.random.seed(42)
n = 10000

# 4가지 유형 생성
complier = np.random.binomial(1, 0.5, n)      # 순응자 50%
always_taker = np.random.binomial(1, 0.2, n) * (1 - complier)  # 항상 치료 20%

Z = np.random.binomial(1, 0.5, n)
T = np.where(complier, Z, np.where(always_taker, 1, 0))

# 이질적 효과: 순응자 효과 = 3.0, 항상 치료자 효과 = 1.0
tau_complier = 3.0
tau_always = 1.0
Y0 = np.random.normal(5, 1, n)
Y1 = Y0 + np.where(complier, tau_complier, np.where(always_taker, tau_always, 0))
Y = T * Y1 + (1 - T) * Y0

# Wald = LATE (순응자 효과)
wald = (Y[Z==1].mean() - Y[Z==0].mean()) / (T[Z==1].mean() - T[Z==0].mean())
print(f"Wald/LATE 추정: {wald:.3f}")  # ≈ 3.0 (순응자 효과)
print(f"진정한 ATE: {(complier * tau_complier + always_taker * tau_always).mean():.3f}")
```

---

## 4. 약한 도구 변수 문제

도구 변수의 관련성이 약하면(1단계 $F$-통계량이 낮으면) 추정량이 심각하게 편향되고 분산이 폭발합니다.

$$
\text{2SLS 편향} \approx \frac{\text{OLS 편향}}{F - \text{통계량}}
$$

| $F$-통계량 | 해석 | 조치 |
|-----------|------|------|
| $F > 10$ | 충분히 강함 | 표준 2SLS 사용 |
| $F \in [5, 10]$ | 약함 | 약한 IV 강건 추정 필요 |
| $F < 5$ | 매우 약함 | IV 전략 재고 |
| Stock-Yogo 기준 | 편향 비율 기준 | $F > 16.38$ (5% 편향) |

> **핵심 직관**: 약한 도구 변수 하에서 2SLS는 OLS보다 더 나쁠 수 있습니다. 1단계의 $F$-통계량 보고는 IV 분석의 필수 요소입니다.

```python
import numpy as np
import statsmodels.api as sm

# 약한 도구 변수 vs 강한 도구 변수
np.random.seed(42)
n = 5000
U = np.random.normal(0, 1, n)

# 강한 IV
Z_strong = np.random.normal(0, 1, n)
T_strong = 0.8 * Z_strong + 0.5 * U + np.random.normal(0, 0.5, n)
Y = 2.0 * T_strong + 1.5 * U + np.random.normal(0, 1, n)

stage1_strong = sm.OLS(T_strong, sm.add_constant(Z_strong)).fit()
print(f"강한 IV: 1단계 F = {stage1_strong.fvalue:.1f}")

# 약한 IV
Z_weak = np.random.normal(0, 1, n)
T_weak = 0.05 * Z_weak + 0.5 * U + np.random.normal(0, 0.5, n)
Y_weak = 2.0 * T_weak + 1.5 * U + np.random.normal(0, 1, n)

stage1_weak = sm.OLS(T_weak, sm.add_constant(Z_weak)).fit()
print(f"약한 IV: 1단계 F = {stage1_weak.fvalue:.1f}")
```

---

## 5. 도구 변수의 실제 사례

실무에서 좋은 도구 변수를 찾는 것은 가장 어려운 부분이며, 도메인 지식이 핵심적입니다.

| 분야 | 처치 ($T$) | 도구 변수 ($Z$) | 결과 ($Y$) |
|------|-----------|----------------|-----------|
| 노동경제학 | 교육 연수 | 출생 분기 (Angrist & Krueger) | 소득 |
| 건강경제학 | 흡연량 | 담배세 변화 | 건강 지표 |
| 개발경제학 | 무역 개방도 | 지리적 거리 | 경제 성장 |
| 마케팅 | 광고 노출 | 무작위 광고 배정 | 구매 |
| 역학 | 약물 복용 | 의사의 처방 경향 | 건강 결과 |

> **핵심 직관**: 배제 제한(IV2) 가정은 검증이 불가능합니다. "Z가 T를 통해서만 Y에 영향을 미친다"는 주장은 이론적 논증에 의존합니다. ci-08의 RDD/DID도 유사한 식별 전략을 사용합니다.

---

## 6. 과식별 검정과 진단

도구 변수가 여러 개인 경우, 과식별 검정(overidentification test)으로 배제 제한 가정의 타당성을 간접적으로 검증할 수 있습니다.

$$
J = n \cdot R^2_{\text{2단계 잔차 ~ Z}} \sim \chi^2(m-k)
$$

여기서 $m$은 도구 변수 수, $k$는 내생 변수 수입니다.

| 검정 | 귀무가설 | 해석 |
|------|---------|------|
| Sargan/Hansen J | 모든 IV가 유효 | 기각 시 최소 하나의 IV 위반 |
| Wu-Hausman | 내생성 없음 | 기각 시 IV 필요 |
| Anderson-Rubin | LATE = 0 | 약한 IV에 강건한 검정 |
| Kleibergen-Paap | 1단계 불충분 | 기각 시 약한 IV |

> **핵심 직관**: 과식별 검정은 모든 IV가 유효하다는 귀무가설을 검정합니다. 기각하지 못한다고 해서 IV가 유효한 것은 아닙니다. 단 하나의 IV만 있으면 검정 자체가 불가능합니다.

```python
import numpy as np
import statsmodels.api as sm

# 과식별 검정 (2개 IV)
np.random.seed(42)
n = 5000
U = np.random.normal(0, 1, n)
Z1 = np.random.normal(0, 1, n)
Z2 = np.random.normal(0, 1, n)

T = 0.5 * Z1 + 0.3 * Z2 + 0.5 * U + np.random.normal(0, 0.5, n)
Y = 2.0 * T + 1.5 * U + np.random.normal(0, 1, n)

# 2SLS
Z = sm.add_constant(np.column_stack([Z1, Z2]))
stage1 = sm.OLS(T, Z).fit()
T_hat = stage1.predict(Z)
stage2 = sm.OLS(Y, sm.add_constant(T_hat)).fit()

# Sargan 검정 (개념적)
resid_2sls = Y - stage2.predict(sm.add_constant(T_hat))
sargan_reg = sm.OLS(resid_2sls, Z).fit()
J_stat = n * sargan_reg.rsquared
print(f"2SLS 추정: {stage2.params[1]:.3f}")
print(f"Sargan J-통계량: {J_stat:.3f} (df=1)")
print(f"p-value < 0.05이면 IV 유효성 의심")
```

---

## 핵심 정리

- **도구 변수는 관련성, 배제 제한, 독립성의 세 조건을 만족해야 합니다**: 배제 제한은 검증 불가능하므로 이론적 정당화가 필수적입니다
- **2SLS는 1단계에서 도구 변수로 치료의 외생적 변동을 추출하고, 2단계에서 이를 이용해 인과 효과를 추정합니다**
- **도구 변수가 식별하는 효과는 ATE가 아닌 LATE(순응자의 평균 효과)입니다**: 단조성 가정 하에서 순응자만의 효과가 식별됩니다
- **약한 도구 변수($F < 10$)는 2SLS 추정을 OLS보다 더 편향시킬 수 있으므로 1단계 $F$-통계량을 반드시 보고해야 합니다**
- **좋은 도구 변수를 찾는 것은 순수한 통계 문제가 아니라 도메인 지식과 제도적 이해에 의존합니다**
