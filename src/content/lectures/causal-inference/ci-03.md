# do-연산과 개입

## 왜 do-연산이 필요한가

ci-02에서 SCM과 DAG를 통해 인과 구조를 표현하는 방법을 배웠습니다. 이제 핵심 질문은 "관측 데이터만으로 개입의 효과를 계산할 수 있는가"입니다. Pearl의 do-연산(do-calculus)은 관측 분포 $P(Y \mid X)$에서 개입 분포 $P(Y \mid do(X))$를 도출하는 완전한 규칙 체계를 제공합니다.

---

## 1. do-operator의 정의

do-operator $do(X=x)$는 변수 $X$를 값 $x$로 강제 설정하는 수학적 연산입니다. ci-02에서 본 절단된 모델(mutilated model)을 공식적으로 정의합니다.

$$
P(Y=y \mid do(X=x)) = P_{\mathcal{M}_{\overline{X}}}(Y=y \mid X=x)
$$

여기서 $\mathcal{M}_{\overline{X}}$는 $X$로 들어오는 모든 화살표를 제거한 수정된 DAG입니다.

| 표기법 | 의미 | DAG 조작 |
|--------|------|----------|
| $P(Y \mid X=x)$ | X=x를 관측했을 때 Y의 분포 | 원래 DAG 유지 |
| $P(Y \mid do(X=x))$ | X=x로 개입했을 때 Y의 분포 | X로의 화살표 제거 |
| $\mathcal{M}_{\overline{X}}$ | 절단된 모델 | $\text{Pa}(X) \not\to X$ |
| $\mathcal{M}_{\underline{X}}$ | X에서 나가는 화살표 제거 | $X \not\to \text{Ch}(X)$ |

> **핵심 직관**: 약을 복용하는 사람을 관측하는 것과 약을 무작위 배정하는 것은 근본적으로 다릅니다. do-operator는 이 차이를 수학적으로 포착합니다.

```python
import numpy as np

# do-operator의 효과 시뮬레이션
np.random.seed(42)
n = 50000

# 원래 SCM: Z → X, Z → Y, X → Y
Z = np.random.binomial(1, 0.5, n)       # 교란 변수 (성별 등)
X = np.random.binomial(1, 0.3 + 0.4 * Z, n)  # 치료 (교란됨)
Y = 0.5 * X + 0.8 * Z + np.random.normal(0, 0.5, n)  # 결과

# P(Y | X=1) - P(Y | X=0): 관측적 차이 (편향)
obs_diff = Y[X==1].mean() - Y[X==0].mean()

# P(Y | do(X=1)) - P(Y | do(X=0)): 개입적 차이 (올바른 인과 효과)
# do(X=1): Z→X 연결 절단, X=1 강제
Y_do1 = 0.5 * 1 + 0.8 * Z + np.random.normal(0, 0.5, n)
Y_do0 = 0.5 * 0 + 0.8 * Z + np.random.normal(0, 0.5, n)
causal_effect = Y_do1.mean() - Y_do0.mean()

print(f"관측적 차이 P(Y|X=1)-P(Y|X=0): {obs_diff:.3f}")
print(f"인과 효과 P(Y|do(1))-P(Y|do(0)): {causal_effect:.3f}")  # ≈ 0.5
```

---

## 2. 백도어 기준 (Backdoor Criterion)

백도어 기준은 관측 데이터에서 인과 효과를 식별하기 위해 **어떤 변수를 통제해야 하는지** 알려주는 그래프 기반 조건입니다.

변수 집합 $\mathbf{Z}$가 $(X, Y)$에 대한 백도어 기준을 만족하려면:

$$
\text{1. } \mathbf{Z} \text{가 } X \text{의 자손이 아님}
$$
$$
\text{2. } \mathbf{Z} \text{가 } X \text{와 } Y \text{ 사이의 모든 백도어 경로를 차단}
$$

| 경로 유형 | 예시 | 백도어 여부 |
|----------|------|-----------|
| 인과 경로 | $X \to M \to Y$ | 아님 (프론트도어) |
| 백도어 경로 | $X \leftarrow Z \to Y$ | 맞음 (차단 필요) |
| 차단된 경로 | $X \to C \leftarrow Y$ | 이미 차단됨 |

> **핵심 직관**: 백도어 경로란 X에서 출발하여 X 방향으로 화살표가 들어오는 경로입니다. ci-04에서 d-분리 규칙으로 이를 체계적으로 판단하는 방법을 배웁니다.

---

## 3. 조정 공식 (Adjustment Formula)

백도어 기준이 만족되면, 조정 공식을 통해 관측 데이터에서 인과 효과를 계산할 수 있습니다.

$$
P(Y=y \mid do(X=x)) = \sum_z P(Y=y \mid X=x, Z=z) \cdot P(Z=z)
$$

연속형 변수의 경우:

$$
E[Y \mid do(X=x)] = \int E[Y \mid X=x, Z=z] \cdot f_Z(z) \, dz
$$

| 구성 요소 | 수식 | 의미 |
|----------|------|------|
| 조건부 결과 | $P(Y \mid X, Z)$ | Z로 층화한 후 X와 Y의 관계 |
| 주변 분포 | $P(Z)$ | 교란 변수의 자연 분포 |
| 가중 평균 | $\sum_z \cdot P(Z=z)$ | 각 층의 기여를 가중 합산 |

> **핵심 직관**: 조정 공식은 ci-01의 Simpson's paradox를 해결하는 공식적 방법입니다. 하위 그룹별로 분석한 후 올바르게 가중 합산합니다.

```python
import numpy as np

# 조정 공식 적용 예시
np.random.seed(42)
n = 100000

Z = np.random.binomial(1, 0.5, n)  # 이진 교란 변수
X = np.random.binomial(1, 0.2 + 0.6 * Z, n)
Y = 0.3 * X + 0.7 * Z + np.random.normal(0, 0.5, n)

# Naive (편향): E[Y|X=1] - E[Y|X=0]
naive = Y[X==1].mean() - Y[X==0].mean()

# 조정 공식: sum_z E[Y|X=x,Z=z] * P(Z=z)
adj_effect = 0
for z in [0, 1]:
    mask_x1_z = (X==1) & (Z==z)
    mask_x0_z = (X==0) & (Z==z)
    p_z = (Z==z).mean()
    e_y_x1_z = Y[mask_x1_z].mean()
    e_y_x0_z = Y[mask_x0_z].mean()
    adj_effect += (e_y_x1_z - e_y_x0_z) * p_z

print(f"Naive 추정: {naive:.3f}")
print(f"조정 공식 추정: {adj_effect:.3f}")  # ≈ 0.3
```

---

## 4. 프론트도어 기준 (Front-door Criterion)

교란 변수를 직접 관측할 수 없는 경우에도, **매개 변수**를 통해 인과 효과를 식별할 수 있습니다. 이것이 프론트도어 기준입니다.

DAG: $U \to X$, $U \to Y$, $X \to M \to Y$ (U는 관측 불가)

프론트도어 기준을 만족하는 $M$이 존재하면:

$$
P(Y \mid do(X=x)) = \sum_m P(M=m \mid X=x) \sum_{x'} P(Y \mid X=x', M=m) P(X=x')
$$

| 조건 | 설명 |
|------|------|
| $X$가 $M$으로의 모든 인과 경로를 차단 | $M$은 $X$를 통해서만 영향 받음 |
| $X$에서 $M$으로의 백도어 없음 | $X \to M$ 관계가 교란되지 않음 |
| $M$에서 $Y$로의 백도어가 $X$로 차단 가능 | $X$를 조건화하면 $M \to Y$ 식별 가능 |

> **핵심 직관**: 흡연($X$)→타르($M$)→폐암($Y$)에서 유전적 소인($U$)이 교란 변수라도, 타르를 매개 변수로 활용하면 흡연의 인과 효과를 식별할 수 있습니다.

```python
import numpy as np

# 프론트도어 기준 시뮬레이션
np.random.seed(42)
n = 100000

U = np.random.normal(0, 1, n)  # 관측 불가 교란 변수
X = 0.5 * U + np.random.normal(0, 1, n)   # 흡연
M = 0.8 * X + np.random.normal(0, 0.3, n) # 타르 (매개)
Y = 0.6 * M + 0.4 * U + np.random.normal(0, 0.5, n)  # 폐암

# 프론트도어 공식 적용 (단순화된 버전)
# Step 1: P(M|X) → X→M 효과 추정
beta_xm = np.polyfit(X, M, 1)[0]  # ≈ 0.8

# Step 2: P(Y|M, X) → M→Y 효과 추정 (X로 백도어 차단)
from numpy.linalg import lstsq
A = np.column_stack([M, X, np.ones(n)])
beta_my = lstsq(A, Y, rcond=None)[0][0]  # ≈ 0.6

# 프론트도어 인과 효과: β_XM * β_MY
frontdoor_effect = beta_xm * beta_my
print(f"프론트도어 인과 효과: {frontdoor_effect:.3f}")  # ≈ 0.48
```

---

## 5. do-calculus의 세 가지 규칙

do-calculus는 세 가지 규칙으로 구성되며, 이 규칙들은 do-표현식을 관측 분포로 변환하는 **완전한** 체계입니다.

$$
\textbf{규칙 1 (삽입/삭제 관측):} \quad P(Y \mid do(X), Z, W) = P(Y \mid do(X), W)
$$
$$
\text{if } (Y \perp\!\!\!\perp Z \mid X, W)_{\mathcal{G}_{\overline{X}}}
$$

$$
\textbf{규칙 2 (do↔관측 교환):} \quad P(Y \mid do(X), do(Z), W) = P(Y \mid do(X), Z, W)
$$
$$
\text{if } (Y \perp\!\!\!\perp Z \mid X, W)_{\mathcal{G}_{\overline{X}\underline{Z}}}
$$

$$
\textbf{규칙 3 (do 삭제):} \quad P(Y \mid do(X), do(Z), W) = P(Y \mid do(X), W)
$$
$$
\text{if } (Y \perp\!\!\!\perp Z \mid X, W)_{\mathcal{G}_{\overline{X}\overline{Z(S)}}}
$$

| 규칙 | 효과 | 조건 그래프 |
|------|------|-----------|
| 규칙 1 | 불필요한 관측 변수 제거 | $\mathcal{G}_{\overline{X}}$ |
| 규칙 2 | $do(Z)$를 관측 $Z$로 변환 | $\mathcal{G}_{\overline{X}\underline{Z}}$ |
| 규칙 3 | $do(Z)$ 완전 제거 | $\mathcal{G}_{\overline{X}\overline{Z(S)}}$ |

> **핵심 직관**: do-calculus의 완전성이 증명되어 있으므로, 주어진 DAG에서 인과 효과가 식별 가능하다면 이 세 규칙을 반복 적용하여 반드시 도출할 수 있습니다.

---

## 6. 인과 효과의 식별 가능성

모든 DAG에서 인과 효과가 식별 가능한 것은 아닙니다. 식별 불가능한 경우를 판단하는 것도 중요합니다.

$$
\text{식별 가능} \iff P(Y \mid do(X)) \text{를 관측 분포로 표현 가능}
$$

| 상황 | 식별 가능? | 해결 방법 |
|------|----------|----------|
| 교란 변수가 모두 관측됨 | 가능 | 백도어 조정 |
| 교란 불가 매개 변수 존재 | 가능 | 프론트도어 기준 |
| 관측 불가 교란만 존재 | 불가능 | ci-07의 도구 변수 필요 |
| 복잡한 DAG | do-calculus 적용 | 알고리즘적 판단 |

> **핵심 직관**: "식별 불가능"은 데이터가 부족해서가 아니라, 주어진 인과 구조에서 원리적으로 관측 데이터만으로는 인과 효과를 계산할 수 없다는 의미입니다.

```python
# 식별 가능성 판단 예시 (개념적)
# 실무에서는 DoWhy 라이브러리 활용

# Case 1: 백도어 기준 만족 → 식별 가능
print("Case 1: Z→X, Z→Y, X→Y")
print("  Z를 조건화 → 백도어 차단 → 식별 가능")

# Case 2: 관측 불가 교란만 존재 → 식별 불가
print("\nCase 2: U→X, U→Y, X→Y (U 관측 불가)")
print("  백도어/프론트도어 모두 불가 → 식별 불가능")
print("  → ci-07의 도구 변수 또는 ci-08의 RDD/DID 필요")
```

---

## 핵심 정리

- **do-operator $do(X=x)$는 변수 $X$를 강제로 설정하는 수학적 연산으로, DAG에서 $X$로 들어오는 화살표를 제거합니다**
- **백도어 기준은 교란 변수를 직접 조건화하여 인과 효과를 식별하는 가장 기본적인 방법입니다**: 조정 공식 $P(Y \mid do(X)) = \sum_z P(Y \mid X, Z) P(Z)$로 계산합니다
- **프론트도어 기준은 교란 변수가 관측 불가능할 때 매개 변수를 활용하여 인과 효과를 식별합니다**
- **do-calculus의 세 가지 규칙은 완전한 체계로, 식별 가능한 모든 인과 효과를 도출할 수 있습니다**
- **인과 효과의 식별 가능성은 DAG 구조에 의해 결정되며, 식별 불가능한 경우에는 도구 변수 등 추가 전략이 필요합니다**
