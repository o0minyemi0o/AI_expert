# 구조적 인과 모델 (SCM)

## 왜 인과 구조를 명시적으로 표현해야 하는가

통계 모델은 변수 간의 연관성을 포착하지만, 인과적 방향과 메커니즘을 구분하지 못합니다. 구조적 인과 모델(Structural Causal Model, SCM)은 인과 관계를 수학적으로 정의하고, 개입과 반사실 질문에 답할 수 있는 형식 체계를 제공합니다. ci-01에서 다룬 인과 사다리의 모든 단계를 하나의 프레임워크로 통합합니다.

---

## 1. 구조적 인과 모델의 정의

SCM은 세 가지 요소로 구성된 수학적 모델입니다. Pearl이 제안한 이 프레임워크는 인과 관계를 **함수적** 관계로 표현합니다.

$$
\mathcal{M} = \langle \mathbf{U}, \mathbf{V}, \mathbf{F} \rangle
$$

| 요소 | 기호 | 설명 | 예시 |
|------|------|------|------|
| 외생 변수 | $\mathbf{U}$ | 모델 외부에서 결정되는 변수 | 유전적 소인, 환경 요인 |
| 내생 변수 | $\mathbf{V}$ | 모델 내에서 결정되는 변수 | 흡연, 폐암, 운동량 |
| 구조 방정식 | $\mathbf{F}$ | 각 $V_i$를 부모 변수와 $U_i$의 함수로 정의 | $Y := f_Y(X, Z, U_Y)$ |

> **핵심 직관**: 구조 방정식에서 `:=` 기호는 일반 등호 `=`와 다릅니다. $Y := f(X, U_Y)$는 "X와 $U_Y$가 Y를 *결정한다*"는 인과적 주장입니다.

```python
import numpy as np

# SCM 예시: 흡연 → 타르 → 폐암
np.random.seed(42)
n = 5000

U_smoking = np.random.normal(0, 1, n)    # 외생 변수
U_tar = np.random.normal(0, 0.5, n)
U_cancer = np.random.normal(0, 0.5, n)

# 구조 방정식
smoking = U_smoking                              # X := U_X
tar = 0.7 * smoking + U_tar                      # M := 0.7*X + U_M
cancer = 0.5 * tar + 0.2 * smoking + U_cancer    # Y := 0.5*M + 0.2*X + U_Y

print(f"흡연-폐암 상관: {np.corrcoef(smoking, cancer)[0,1]:.3f}")
print(f"타르-폐암 상관: {np.corrcoef(tar, cancer)[0,1]:.3f}")
```

---

## 2. 방향성 비순환 그래프 (DAG)

SCM의 인과 구조는 DAG(Directed Acyclic Graph)로 시각화됩니다. 각 노드는 변수, 각 화살표는 직접적 인과 관계를 나타냅니다.

$$
X \to M \to Y \quad \text{(체인/매개)}
$$
$$
X \leftarrow Z \to Y \quad \text{(포크/교란)}
$$
$$
X \to Z \leftarrow Y \quad \text{(충돌자/콜라이더)}
$$

| 구조 | 이름 | 경로 유형 | 조건부 독립 |
|------|------|----------|------------|
| $X \to M \to Y$ | 체인 (Chain) | 인과 경로 | $X \perp\!\!\!\perp Y \mid M$ |
| $X \leftarrow Z \to Y$ | 포크 (Fork) | 교란 경로 | $X \perp\!\!\!\perp Y \mid Z$ |
| $X \to Z \leftarrow Y$ | 충돌자 (Collider) | 차단된 경로 | $X \not\!\perp\!\!\!\perp Y \mid Z$ (조건부 시 열림!) |

> **핵심 직관**: 충돌자는 조건화하지 않으면 경로가 차단되지만, 조건화하면 오히려 경로가 열립니다. 이 반직관적 성질은 ci-04에서 d-분리 규칙으로 체계화됩니다.

---

## 3. 구조 방정식과 통계 모델의 차이

구조 방정식은 회귀 모델과 형태가 유사하지만, 본질적으로 다른 의미를 가집니다.

$$
\text{회귀}: \quad E[Y \mid X=x] = \beta_0 + \beta_1 x
$$
$$
\text{구조 방정식}: \quad Y := \beta_0 + \beta_1 X + U_Y
$$

| 비교 항목 | 통계적 회귀 모델 | 구조 방정식 (SCM) |
|----------|----------------|-----------------|
| 해석 | 조건부 기대값 | 데이터 생성 메커니즘 |
| 방향성 | 양방향 ($X$와 $Y$ 교환 가능) | 단방향 ($X$가 $Y$를 생성) |
| 개입 | 정의 불가 | $do(X=x)$로 개입 표현 |
| 반사실 | 정의 불가 | $Y_x(u)$로 반사실 계산 |
| 가정 | 함수형 가정 | 인과적 가정 + 함수형 가정 |

> **핵심 직관**: 같은 $Y = \beta X + \epsilon$ 수식이라도, 회귀에서는 "X가 주어졌을 때 Y의 예측값"이고, SCM에서는 "X가 Y를 $\beta$만큼 변화시킨다"는 인과적 주장입니다.

```python
import numpy as np
import statsmodels.api as sm

# 회귀 vs SCM: 같은 수식, 다른 해석
np.random.seed(42)
n = 1000
Z = np.random.normal(0, 1, n)       # 교란 변수
X = 0.5 * Z + np.random.normal(0, 1, n)  # 구조 방정식 1
Y = 0.3 * X + 0.8 * Z + np.random.normal(0, 1, n)  # 구조 방정식 2

# Naive 회귀 (Z 통제 안 함) → 편향된 계수
model_biased = sm.OLS(Y, sm.add_constant(X)).fit()
print(f"편향된 X 계수: {model_biased.params[1]:.3f}")  # 0.3보다 큼

# Z 통제 회귀 → 올바른 계수
model_correct = sm.OLS(Y, sm.add_constant(np.column_stack([X, Z]))).fit()
print(f"올바른 X 계수: {model_correct.params[1]:.3f}")  # ≈ 0.3
```

---

## 4. 개입과 관측의 차이

SCM에서 개입(intervention)은 구조 방정식을 **강제로 대체**하는 것입니다. ci-03에서 do-연산으로 본격적으로 다루겠지만, 여기서는 개념적 차이를 이해합니다.

$$
\text{관측}: \quad P(Y \mid X=x) \quad \text{(X=x를 관측)}
$$
$$
\text{개입}: \quad P(Y \mid do(X=x)) \quad \text{(X=x로 강제 설정)}
$$

개입 시 $X$의 원래 구조 방정식 $X := f_X(\text{Pa}_X, U_X)$를 $X := x$로 대체합니다. 이를 **절단된 모델(mutilated model)**이라 합니다.

| 구분 | 관측 $P(Y \mid X=x)$ | 개입 $P(Y \mid do(X=x))$ |
|------|---------------------|--------------------------|
| X의 부모 | X의 원인이 그대로 작동 | X의 원인으로부터 분리 |
| DAG 변화 | 원래 DAG 유지 | X로 들어오는 화살표 제거 |
| 교란 | 교란 변수 영향 포함 | 교란 변수 영향 차단 |
| 실현 방법 | 수동적 관찰 | 무작위 배정 (RCT) |

> **핵심 직관**: 바로미터 수치를 관측하면 폭풍을 예측할 수 있지만, 바로미터 눈금을 강제로 돌려도($do$) 폭풍은 오지 않습니다. 개입은 원인의 화살표를 절단합니다.

```python
import numpy as np

# 관측 vs 개입 시뮬레이션
np.random.seed(42)
n = 10000

# 원래 SCM
Z = np.random.normal(0, 1, n)
X = 0.6 * Z + np.random.normal(0, 1, n)
Y = 0.4 * X + 0.7 * Z + np.random.normal(0, 1, n)

# 관측: P(Y | X > 1)
obs_effect = Y[X > 1].mean() - Y[X < -1].mean()

# 개입: do(X = 1) — Z→X 연결 절단
X_do = np.ones(n)  # 강제 설정
Y_do1 = 0.4 * X_do + 0.7 * Z + np.random.normal(0, 1, n)
X_do0 = -np.ones(n)
Y_do0 = 0.4 * X_do0 + 0.7 * Z + np.random.normal(0, 1, n)
interventional_effect = Y_do1.mean() - Y_do0.mean()

print(f"관측적 효과: {obs_effect:.3f}")
print(f"개입적 효과: {interventional_effect:.3f}")  # ≈ 0.8 (= 0.4 * 2)
```

---

## 5. SCM에서의 반사실 추론

SCM의 가장 강력한 기능은 **반사실(counterfactual)** 질문에 답할 수 있다는 것입니다. 이는 ci-01에서 소개한 인과 사다리의 3단계에 해당합니다.

반사실 추론의 세 단계:

$$
\text{1. 관측(Abduction)}: \quad U = f^{-1}(V_{\text{observed}})
$$
$$
\text{2. 개입(Action)}: \quad X := x'
$$
$$
\text{3. 예측(Prediction)}: \quad Y_{x'}(u) = f_Y(x', u)
$$

| 단계 | 연산 | 설명 |
|------|------|------|
| Abduction | 외생 변수 추정 | 관측값으로부터 $U$ 역산 |
| Action | 구조 방정식 수정 | $X$의 방정식을 $X := x'$로 대체 |
| Prediction | 수정된 모델에서 예측 | 새로운 결과 $Y_{x'}$ 계산 |

> **핵심 직관**: "이 환자가 수술을 받았더라면 살았을까?"라는 질문은 해당 환자의 구체적 특성($U$ 값)을 보존한 채 치료만 바꾸는 것입니다. ci-05에서 다룰 Rubin의 잠재 결과와 수학적으로 연결됩니다.

---

## 6. SCM의 실무적 활용과 한계

SCM은 강력한 프레임워크이지만, 실무 적용 시 주의해야 할 점이 있습니다.

| 장점 | 한계 |
|------|------|
| 인과 구조를 명시적으로 표현 | DAG가 올바르다는 보장 없음 |
| 개입과 반사실 질문에 답 가능 | 구조 방정식의 함수형 가정 필요 |
| 식별 가능성을 체계적으로 검증 | 비모수적 SCM은 추정이 어려움 |
| 도메인 지식 통합 용이 | 숨은 변수 존재 시 복잡해짐 |

> **핵심 직관**: SCM의 가장 중요한 실무적 가치는 "어떤 가정 하에서 인과 효과가 식별 가능한가"를 체계적으로 판단할 수 있다는 점입니다. ci-09에서는 데이터로부터 DAG를 학습하는 인과 발견 알고리즘을 다룹니다.

```python
# SCM을 활용한 인과 효과 식별 가능성 판단 (개념적 코드)
# 실제로는 DoWhy, CausalGraphicalModels 등의 라이브러리 사용
# pip install dowhy

# DAG 정의 예시 (개념적)
dag_edges = {
    "Z -> X": "교란",
    "X -> Y": "인과 효과 (관심 대상)",
    "Z -> Y": "교란 경로"
}

# 식별 전략: Z를 조건화하면 X→Y의 인과 효과 식별 가능
# 이는 ci-03의 backdoor criterion과 동일
print("백도어 기준 충족: Z를 조건화하면 X→Y 인과 효과 식별 가능")
```

---

## 핵심 정리

- **SCM은 외생 변수($\mathbf{U}$), 내생 변수($\mathbf{V}$), 구조 방정식($\mathbf{F}$)의 삼중체로 정의됩니다**: 인과 관계를 함수적으로 표현합니다
- **DAG는 체인, 포크, 충돌자 세 가지 기본 구조로 구성됩니다**: 각 구조가 조건부 독립에 미치는 영향이 서로 다릅니다
- **구조 방정식은 회귀 모델과 형태는 같지만 인과적 해석을 포함합니다**: `:=` 기호는 데이터 생성 메커니즘을 나타냅니다
- **개입은 구조 방정식을 강제로 대체하여 X로 들어오는 화살표를 절단합니다**: $P(Y \mid do(X))$와 $P(Y \mid X)$는 일반적으로 다릅니다
- **SCM은 반사실 추론까지 가능한 완전한 인과 프레임워크입니다**: Abduction-Action-Prediction의 세 단계를 통해 개인 수준의 반사실을 계산합니다
